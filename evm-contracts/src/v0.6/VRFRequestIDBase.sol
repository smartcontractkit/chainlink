pragma solidity ^0.6.0;

contract VRFRequestIDBase {

  /**
   * @notice returns the seed which is actually input to the VRF
   *
   * @dev To prevent repetition of VRF output due to repetition against the
   * @dev user-supplied seed, that seed is combined in a hash with the a
   * @dev user-specific nonce, and the address of the consuming contract.
   *
   * @dev Of course, crucial security guranatees would be broken by repetition
   * @dev of the user-supplied seed, as all the other inputs can be anticipated
   * @dev and the user-specified seed is public once the initial request is
   * @dev made, so if the oracle has reason to belive that a user-specified seed
   * @dev will be repeated, it may be able to anticipate its future outputs. So
   * @dev it may make sense, for certain applications, for the VRF framework to
   * @dev simply refuse to operate, if given a seed it's seen before.
   *
   * @param _userSeed VRF seed input provided by user
   * @param _requester Address of the requesting contract
   * @param _nonce User-specific nonce at the time of the request
   */
  function makeVRFInputSeed(bytes32 _keyHash, uint256 _userSeed,
    address _requester, uint256 _nonce)
    internal pure returns (uint256)
  {
    return  uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));
  }

  /**
   * @notice Returns the id for this request
   * @param _keyHash The serviceAgreement ID to be used for this request
   * @param _vRFInputSeed The seed to be passed directly to the VRF
   * @return The id for this request
   *
   * @dev Note that _vRFInputSeed is not the seed passed by the consuming
   * @dev contract, but the one generated by makeVRFInputSeed
   */
  function makeRequestId(
    bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {
    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));
  }
}
