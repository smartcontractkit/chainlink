// Code generated by mockery v2.38.0. DO NOT EDIT.

package mock_contracts

import (
	big "math/big"

	bind "github.com/ethereum/go-ethereum/accounts/abi/bind"
	common "github.com/ethereum/go-ethereum/common"
	commit_store "github.com/smartcontractkit/chainlink/v2/core/gethwrappers/ccip/generated/commit_store"

	event "github.com/ethereum/go-ethereum/event"

	generated "github.com/smartcontractkit/chainlink/v2/core/gethwrappers/generated"

	mock "github.com/stretchr/testify/mock"

	types "github.com/ethereum/go-ethereum/core/types"
)

// CommitStoreInterface is an autogenerated mock type for the CommitStoreInterface type
type CommitStoreInterface struct {
	mock.Mock
}

// AcceptOwnership provides a mock function with given fields: opts
func (_m *CommitStoreInterface) AcceptOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for AcceptOwnership")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts) (*types.Transaction, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts) *types.Transaction); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Address provides a mock function with given fields:
func (_m *CommitStoreInterface) Address() common.Address {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Address")
	}

	var r0 common.Address
	if rf, ok := ret.Get(0).(func() common.Address); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	return r0
}

// FilterConfigSet provides a mock function with given fields: opts
func (_m *CommitStoreInterface) FilterConfigSet(opts *bind.FilterOpts) (*commit_store.CommitStoreConfigSetIterator, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for FilterConfigSet")
	}

	var r0 *commit_store.CommitStoreConfigSetIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) (*commit_store.CommitStoreConfigSetIterator, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *commit_store.CommitStoreConfigSetIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commit_store.CommitStoreConfigSetIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterConfigSet0 provides a mock function with given fields: opts
func (_m *CommitStoreInterface) FilterConfigSet0(opts *bind.FilterOpts) (*commit_store.CommitStoreConfigSet0Iterator, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for FilterConfigSet0")
	}

	var r0 *commit_store.CommitStoreConfigSet0Iterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) (*commit_store.CommitStoreConfigSet0Iterator, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *commit_store.CommitStoreConfigSet0Iterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commit_store.CommitStoreConfigSet0Iterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterOwnershipTransferRequested provides a mock function with given fields: opts, from, to
func (_m *CommitStoreInterface) FilterOwnershipTransferRequested(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*commit_store.CommitStoreOwnershipTransferRequestedIterator, error) {
	ret := _m.Called(opts, from, to)

	if len(ret) == 0 {
		panic("no return value specified for FilterOwnershipTransferRequested")
	}

	var r0 *commit_store.CommitStoreOwnershipTransferRequestedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address, []common.Address) (*commit_store.CommitStoreOwnershipTransferRequestedIterator, error)); ok {
		return rf(opts, from, to)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address, []common.Address) *commit_store.CommitStoreOwnershipTransferRequestedIterator); ok {
		r0 = rf(opts, from, to)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commit_store.CommitStoreOwnershipTransferRequestedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, from, to)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterOwnershipTransferred provides a mock function with given fields: opts, from, to
func (_m *CommitStoreInterface) FilterOwnershipTransferred(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*commit_store.CommitStoreOwnershipTransferredIterator, error) {
	ret := _m.Called(opts, from, to)

	if len(ret) == 0 {
		panic("no return value specified for FilterOwnershipTransferred")
	}

	var r0 *commit_store.CommitStoreOwnershipTransferredIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address, []common.Address) (*commit_store.CommitStoreOwnershipTransferredIterator, error)); ok {
		return rf(opts, from, to)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address, []common.Address) *commit_store.CommitStoreOwnershipTransferredIterator); ok {
		r0 = rf(opts, from, to)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commit_store.CommitStoreOwnershipTransferredIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, from, to)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterPaused provides a mock function with given fields: opts
func (_m *CommitStoreInterface) FilterPaused(opts *bind.FilterOpts) (*commit_store.CommitStorePausedIterator, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for FilterPaused")
	}

	var r0 *commit_store.CommitStorePausedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) (*commit_store.CommitStorePausedIterator, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *commit_store.CommitStorePausedIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commit_store.CommitStorePausedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterReportAccepted provides a mock function with given fields: opts
func (_m *CommitStoreInterface) FilterReportAccepted(opts *bind.FilterOpts) (*commit_store.CommitStoreReportAcceptedIterator, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for FilterReportAccepted")
	}

	var r0 *commit_store.CommitStoreReportAcceptedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) (*commit_store.CommitStoreReportAcceptedIterator, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *commit_store.CommitStoreReportAcceptedIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commit_store.CommitStoreReportAcceptedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterRootRemoved provides a mock function with given fields: opts
func (_m *CommitStoreInterface) FilterRootRemoved(opts *bind.FilterOpts) (*commit_store.CommitStoreRootRemovedIterator, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for FilterRootRemoved")
	}

	var r0 *commit_store.CommitStoreRootRemovedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) (*commit_store.CommitStoreRootRemovedIterator, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *commit_store.CommitStoreRootRemovedIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commit_store.CommitStoreRootRemovedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterTransmitted provides a mock function with given fields: opts
func (_m *CommitStoreInterface) FilterTransmitted(opts *bind.FilterOpts) (*commit_store.CommitStoreTransmittedIterator, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for FilterTransmitted")
	}

	var r0 *commit_store.CommitStoreTransmittedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) (*commit_store.CommitStoreTransmittedIterator, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *commit_store.CommitStoreTransmittedIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commit_store.CommitStoreTransmittedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterUnpaused provides a mock function with given fields: opts
func (_m *CommitStoreInterface) FilterUnpaused(opts *bind.FilterOpts) (*commit_store.CommitStoreUnpausedIterator, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for FilterUnpaused")
	}

	var r0 *commit_store.CommitStoreUnpausedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) (*commit_store.CommitStoreUnpausedIterator, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *commit_store.CommitStoreUnpausedIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commit_store.CommitStoreUnpausedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDynamicConfig provides a mock function with given fields: opts
func (_m *CommitStoreInterface) GetDynamicConfig(opts *bind.CallOpts) (commit_store.CommitStoreDynamicConfig, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for GetDynamicConfig")
	}

	var r0 commit_store.CommitStoreDynamicConfig
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (commit_store.CommitStoreDynamicConfig, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) commit_store.CommitStoreDynamicConfig); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(commit_store.CommitStoreDynamicConfig)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetExpectedNextSequenceNumber provides a mock function with given fields: opts
func (_m *CommitStoreInterface) GetExpectedNextSequenceNumber(opts *bind.CallOpts) (uint64, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for GetExpectedNextSequenceNumber")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (uint64, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) uint64); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLatestPriceEpochAndRound provides a mock function with given fields: opts
func (_m *CommitStoreInterface) GetLatestPriceEpochAndRound(opts *bind.CallOpts) (uint64, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for GetLatestPriceEpochAndRound")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (uint64, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) uint64); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMerkleRoot provides a mock function with given fields: opts, root
func (_m *CommitStoreInterface) GetMerkleRoot(opts *bind.CallOpts, root [32]byte) (*big.Int, error) {
	ret := _m.Called(opts, root)

	if len(ret) == 0 {
		panic("no return value specified for GetMerkleRoot")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, [32]byte) (*big.Int, error)); ok {
		return rf(opts, root)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, [32]byte) *big.Int); ok {
		r0 = rf(opts, root)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, [32]byte) error); ok {
		r1 = rf(opts, root)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetStaticConfig provides a mock function with given fields: opts
func (_m *CommitStoreInterface) GetStaticConfig(opts *bind.CallOpts) (commit_store.CommitStoreStaticConfig, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for GetStaticConfig")
	}

	var r0 commit_store.CommitStoreStaticConfig
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (commit_store.CommitStoreStaticConfig, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) commit_store.CommitStoreStaticConfig); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(commit_store.CommitStoreStaticConfig)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransmitters provides a mock function with given fields: opts
func (_m *CommitStoreInterface) GetTransmitters(opts *bind.CallOpts) ([]common.Address, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for GetTransmitters")
	}

	var r0 []common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) ([]common.Address, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) []common.Address); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsARMHealthy provides a mock function with given fields: opts
func (_m *CommitStoreInterface) IsARMHealthy(opts *bind.CallOpts) (bool, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for IsARMHealthy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (bool, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) bool); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsBlessed provides a mock function with given fields: opts, root
func (_m *CommitStoreInterface) IsBlessed(opts *bind.CallOpts, root [32]byte) (bool, error) {
	ret := _m.Called(opts, root)

	if len(ret) == 0 {
		panic("no return value specified for IsBlessed")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, [32]byte) (bool, error)); ok {
		return rf(opts, root)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, [32]byte) bool); ok {
		r0 = rf(opts, root)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, [32]byte) error); ok {
		r1 = rf(opts, root)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsUnpausedAndARMHealthy provides a mock function with given fields: opts
func (_m *CommitStoreInterface) IsUnpausedAndARMHealthy(opts *bind.CallOpts) (bool, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for IsUnpausedAndARMHealthy")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (bool, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) bool); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LatestConfigDetails provides a mock function with given fields: opts
func (_m *CommitStoreInterface) LatestConfigDetails(opts *bind.CallOpts) (commit_store.LatestConfigDetails, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for LatestConfigDetails")
	}

	var r0 commit_store.LatestConfigDetails
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (commit_store.LatestConfigDetails, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) commit_store.LatestConfigDetails); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(commit_store.LatestConfigDetails)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LatestConfigDigestAndEpoch provides a mock function with given fields: opts
func (_m *CommitStoreInterface) LatestConfigDigestAndEpoch(opts *bind.CallOpts) (commit_store.LatestConfigDigestAndEpoch, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for LatestConfigDigestAndEpoch")
	}

	var r0 commit_store.LatestConfigDigestAndEpoch
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (commit_store.LatestConfigDigestAndEpoch, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) commit_store.LatestConfigDigestAndEpoch); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(commit_store.LatestConfigDigestAndEpoch)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Owner provides a mock function with given fields: opts
func (_m *CommitStoreInterface) Owner(opts *bind.CallOpts) (common.Address, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for Owner")
	}

	var r0 common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (common.Address, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) common.Address); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseConfigSet provides a mock function with given fields: log
func (_m *CommitStoreInterface) ParseConfigSet(log types.Log) (*commit_store.CommitStoreConfigSet, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseConfigSet")
	}

	var r0 *commit_store.CommitStoreConfigSet
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*commit_store.CommitStoreConfigSet, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *commit_store.CommitStoreConfigSet); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commit_store.CommitStoreConfigSet)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseConfigSet0 provides a mock function with given fields: log
func (_m *CommitStoreInterface) ParseConfigSet0(log types.Log) (*commit_store.CommitStoreConfigSet0, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseConfigSet0")
	}

	var r0 *commit_store.CommitStoreConfigSet0
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*commit_store.CommitStoreConfigSet0, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *commit_store.CommitStoreConfigSet0); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commit_store.CommitStoreConfigSet0)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseLog provides a mock function with given fields: log
func (_m *CommitStoreInterface) ParseLog(log types.Log) (generated.AbigenLog, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseLog")
	}

	var r0 generated.AbigenLog
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (generated.AbigenLog, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) generated.AbigenLog); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(generated.AbigenLog)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseOwnershipTransferRequested provides a mock function with given fields: log
func (_m *CommitStoreInterface) ParseOwnershipTransferRequested(log types.Log) (*commit_store.CommitStoreOwnershipTransferRequested, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseOwnershipTransferRequested")
	}

	var r0 *commit_store.CommitStoreOwnershipTransferRequested
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*commit_store.CommitStoreOwnershipTransferRequested, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *commit_store.CommitStoreOwnershipTransferRequested); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commit_store.CommitStoreOwnershipTransferRequested)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseOwnershipTransferred provides a mock function with given fields: log
func (_m *CommitStoreInterface) ParseOwnershipTransferred(log types.Log) (*commit_store.CommitStoreOwnershipTransferred, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseOwnershipTransferred")
	}

	var r0 *commit_store.CommitStoreOwnershipTransferred
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*commit_store.CommitStoreOwnershipTransferred, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *commit_store.CommitStoreOwnershipTransferred); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commit_store.CommitStoreOwnershipTransferred)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParsePaused provides a mock function with given fields: log
func (_m *CommitStoreInterface) ParsePaused(log types.Log) (*commit_store.CommitStorePaused, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParsePaused")
	}

	var r0 *commit_store.CommitStorePaused
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*commit_store.CommitStorePaused, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *commit_store.CommitStorePaused); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commit_store.CommitStorePaused)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseReportAccepted provides a mock function with given fields: log
func (_m *CommitStoreInterface) ParseReportAccepted(log types.Log) (*commit_store.CommitStoreReportAccepted, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseReportAccepted")
	}

	var r0 *commit_store.CommitStoreReportAccepted
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*commit_store.CommitStoreReportAccepted, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *commit_store.CommitStoreReportAccepted); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commit_store.CommitStoreReportAccepted)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseRootRemoved provides a mock function with given fields: log
func (_m *CommitStoreInterface) ParseRootRemoved(log types.Log) (*commit_store.CommitStoreRootRemoved, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseRootRemoved")
	}

	var r0 *commit_store.CommitStoreRootRemoved
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*commit_store.CommitStoreRootRemoved, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *commit_store.CommitStoreRootRemoved); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commit_store.CommitStoreRootRemoved)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseTransmitted provides a mock function with given fields: log
func (_m *CommitStoreInterface) ParseTransmitted(log types.Log) (*commit_store.CommitStoreTransmitted, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseTransmitted")
	}

	var r0 *commit_store.CommitStoreTransmitted
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*commit_store.CommitStoreTransmitted, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *commit_store.CommitStoreTransmitted); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commit_store.CommitStoreTransmitted)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseUnpaused provides a mock function with given fields: log
func (_m *CommitStoreInterface) ParseUnpaused(log types.Log) (*commit_store.CommitStoreUnpaused, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseUnpaused")
	}

	var r0 *commit_store.CommitStoreUnpaused
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*commit_store.CommitStoreUnpaused, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *commit_store.CommitStoreUnpaused); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*commit_store.CommitStoreUnpaused)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Pause provides a mock function with given fields: opts
func (_m *CommitStoreInterface) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for Pause")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts) (*types.Transaction, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts) *types.Transaction); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Paused provides a mock function with given fields: opts
func (_m *CommitStoreInterface) Paused(opts *bind.CallOpts) (bool, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for Paused")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (bool, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) bool); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResetUnblessedRoots provides a mock function with given fields: opts, rootToReset
func (_m *CommitStoreInterface) ResetUnblessedRoots(opts *bind.TransactOpts, rootToReset [][32]byte) (*types.Transaction, error) {
	ret := _m.Called(opts, rootToReset)

	if len(ret) == 0 {
		panic("no return value specified for ResetUnblessedRoots")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, [][32]byte) (*types.Transaction, error)); ok {
		return rf(opts, rootToReset)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, [][32]byte) *types.Transaction); ok {
		r0 = rf(opts, rootToReset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, [][32]byte) error); ok {
		r1 = rf(opts, rootToReset)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetLatestPriceEpochAndRound provides a mock function with given fields: opts, latestPriceEpochAndRound
func (_m *CommitStoreInterface) SetLatestPriceEpochAndRound(opts *bind.TransactOpts, latestPriceEpochAndRound *big.Int) (*types.Transaction, error) {
	ret := _m.Called(opts, latestPriceEpochAndRound)

	if len(ret) == 0 {
		panic("no return value specified for SetLatestPriceEpochAndRound")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, *big.Int) (*types.Transaction, error)); ok {
		return rf(opts, latestPriceEpochAndRound)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, *big.Int) *types.Transaction); ok {
		r0 = rf(opts, latestPriceEpochAndRound)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, *big.Int) error); ok {
		r1 = rf(opts, latestPriceEpochAndRound)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetMinSeqNr provides a mock function with given fields: opts, minSeqNr
func (_m *CommitStoreInterface) SetMinSeqNr(opts *bind.TransactOpts, minSeqNr uint64) (*types.Transaction, error) {
	ret := _m.Called(opts, minSeqNr)

	if len(ret) == 0 {
		panic("no return value specified for SetMinSeqNr")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, uint64) (*types.Transaction, error)); ok {
		return rf(opts, minSeqNr)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, uint64) *types.Transaction); ok {
		r0 = rf(opts, minSeqNr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, uint64) error); ok {
		r1 = rf(opts, minSeqNr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetOCR2Config provides a mock function with given fields: opts, signers, transmitters, f, onchainConfig, offchainConfigVersion, offchainConfig
func (_m *CommitStoreInterface) SetOCR2Config(opts *bind.TransactOpts, signers []common.Address, transmitters []common.Address, f uint8, onchainConfig []byte, offchainConfigVersion uint64, offchainConfig []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, signers, transmitters, f, onchainConfig, offchainConfigVersion, offchainConfig)

	if len(ret) == 0 {
		panic("no return value specified for SetOCR2Config")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []common.Address, []common.Address, uint8, []byte, uint64, []byte) (*types.Transaction, error)); ok {
		return rf(opts, signers, transmitters, f, onchainConfig, offchainConfigVersion, offchainConfig)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []common.Address, []common.Address, uint8, []byte, uint64, []byte) *types.Transaction); ok {
		r0 = rf(opts, signers, transmitters, f, onchainConfig, offchainConfigVersion, offchainConfig)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, []common.Address, []common.Address, uint8, []byte, uint64, []byte) error); ok {
		r1 = rf(opts, signers, transmitters, f, onchainConfig, offchainConfigVersion, offchainConfig)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TransferOwnership provides a mock function with given fields: opts, to
func (_m *CommitStoreInterface) TransferOwnership(opts *bind.TransactOpts, to common.Address) (*types.Transaction, error) {
	ret := _m.Called(opts, to)

	if len(ret) == 0 {
		panic("no return value specified for TransferOwnership")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address) (*types.Transaction, error)); ok {
		return rf(opts, to)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address) *types.Transaction); ok {
		r0 = rf(opts, to)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, common.Address) error); ok {
		r1 = rf(opts, to)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Transmit provides a mock function with given fields: opts, reportContext, report, rs, ss, rawVs
func (_m *CommitStoreInterface) Transmit(opts *bind.TransactOpts, reportContext [3][32]byte, report []byte, rs [][32]byte, ss [][32]byte, rawVs [32]byte) (*types.Transaction, error) {
	ret := _m.Called(opts, reportContext, report, rs, ss, rawVs)

	if len(ret) == 0 {
		panic("no return value specified for Transmit")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, [3][32]byte, []byte, [][32]byte, [][32]byte, [32]byte) (*types.Transaction, error)); ok {
		return rf(opts, reportContext, report, rs, ss, rawVs)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, [3][32]byte, []byte, [][32]byte, [][32]byte, [32]byte) *types.Transaction); ok {
		r0 = rf(opts, reportContext, report, rs, ss, rawVs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, [3][32]byte, []byte, [][32]byte, [][32]byte, [32]byte) error); ok {
		r1 = rf(opts, reportContext, report, rs, ss, rawVs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TypeAndVersion provides a mock function with given fields: opts
func (_m *CommitStoreInterface) TypeAndVersion(opts *bind.CallOpts) (string, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for TypeAndVersion")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (string, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) string); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Unpause provides a mock function with given fields: opts
func (_m *CommitStoreInterface) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for Unpause")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts) (*types.Transaction, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts) *types.Transaction); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Verify provides a mock function with given fields: opts, hashedLeaves, proofs, proofFlagBits
func (_m *CommitStoreInterface) Verify(opts *bind.CallOpts, hashedLeaves [][32]byte, proofs [][32]byte, proofFlagBits *big.Int) (*big.Int, error) {
	ret := _m.Called(opts, hashedLeaves, proofs, proofFlagBits)

	if len(ret) == 0 {
		panic("no return value specified for Verify")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, [][32]byte, [][32]byte, *big.Int) (*big.Int, error)); ok {
		return rf(opts, hashedLeaves, proofs, proofFlagBits)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, [][32]byte, [][32]byte, *big.Int) *big.Int); ok {
		r0 = rf(opts, hashedLeaves, proofs, proofFlagBits)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, [][32]byte, [][32]byte, *big.Int) error); ok {
		r1 = rf(opts, hashedLeaves, proofs, proofFlagBits)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchConfigSet provides a mock function with given fields: opts, sink
func (_m *CommitStoreInterface) WatchConfigSet(opts *bind.WatchOpts, sink chan<- *commit_store.CommitStoreConfigSet) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	if len(ret) == 0 {
		panic("no return value specified for WatchConfigSet")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *commit_store.CommitStoreConfigSet) (event.Subscription, error)); ok {
		return rf(opts, sink)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *commit_store.CommitStoreConfigSet) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *commit_store.CommitStoreConfigSet) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchConfigSet0 provides a mock function with given fields: opts, sink
func (_m *CommitStoreInterface) WatchConfigSet0(opts *bind.WatchOpts, sink chan<- *commit_store.CommitStoreConfigSet0) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	if len(ret) == 0 {
		panic("no return value specified for WatchConfigSet0")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *commit_store.CommitStoreConfigSet0) (event.Subscription, error)); ok {
		return rf(opts, sink)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *commit_store.CommitStoreConfigSet0) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *commit_store.CommitStoreConfigSet0) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchOwnershipTransferRequested provides a mock function with given fields: opts, sink, from, to
func (_m *CommitStoreInterface) WatchOwnershipTransferRequested(opts *bind.WatchOpts, sink chan<- *commit_store.CommitStoreOwnershipTransferRequested, from []common.Address, to []common.Address) (event.Subscription, error) {
	ret := _m.Called(opts, sink, from, to)

	if len(ret) == 0 {
		panic("no return value specified for WatchOwnershipTransferRequested")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *commit_store.CommitStoreOwnershipTransferRequested, []common.Address, []common.Address) (event.Subscription, error)); ok {
		return rf(opts, sink, from, to)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *commit_store.CommitStoreOwnershipTransferRequested, []common.Address, []common.Address) event.Subscription); ok {
		r0 = rf(opts, sink, from, to)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *commit_store.CommitStoreOwnershipTransferRequested, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, sink, from, to)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchOwnershipTransferred provides a mock function with given fields: opts, sink, from, to
func (_m *CommitStoreInterface) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *commit_store.CommitStoreOwnershipTransferred, from []common.Address, to []common.Address) (event.Subscription, error) {
	ret := _m.Called(opts, sink, from, to)

	if len(ret) == 0 {
		panic("no return value specified for WatchOwnershipTransferred")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *commit_store.CommitStoreOwnershipTransferred, []common.Address, []common.Address) (event.Subscription, error)); ok {
		return rf(opts, sink, from, to)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *commit_store.CommitStoreOwnershipTransferred, []common.Address, []common.Address) event.Subscription); ok {
		r0 = rf(opts, sink, from, to)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *commit_store.CommitStoreOwnershipTransferred, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, sink, from, to)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchPaused provides a mock function with given fields: opts, sink
func (_m *CommitStoreInterface) WatchPaused(opts *bind.WatchOpts, sink chan<- *commit_store.CommitStorePaused) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	if len(ret) == 0 {
		panic("no return value specified for WatchPaused")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *commit_store.CommitStorePaused) (event.Subscription, error)); ok {
		return rf(opts, sink)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *commit_store.CommitStorePaused) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *commit_store.CommitStorePaused) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchReportAccepted provides a mock function with given fields: opts, sink
func (_m *CommitStoreInterface) WatchReportAccepted(opts *bind.WatchOpts, sink chan<- *commit_store.CommitStoreReportAccepted) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	if len(ret) == 0 {
		panic("no return value specified for WatchReportAccepted")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *commit_store.CommitStoreReportAccepted) (event.Subscription, error)); ok {
		return rf(opts, sink)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *commit_store.CommitStoreReportAccepted) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *commit_store.CommitStoreReportAccepted) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchRootRemoved provides a mock function with given fields: opts, sink
func (_m *CommitStoreInterface) WatchRootRemoved(opts *bind.WatchOpts, sink chan<- *commit_store.CommitStoreRootRemoved) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	if len(ret) == 0 {
		panic("no return value specified for WatchRootRemoved")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *commit_store.CommitStoreRootRemoved) (event.Subscription, error)); ok {
		return rf(opts, sink)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *commit_store.CommitStoreRootRemoved) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *commit_store.CommitStoreRootRemoved) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchTransmitted provides a mock function with given fields: opts, sink
func (_m *CommitStoreInterface) WatchTransmitted(opts *bind.WatchOpts, sink chan<- *commit_store.CommitStoreTransmitted) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	if len(ret) == 0 {
		panic("no return value specified for WatchTransmitted")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *commit_store.CommitStoreTransmitted) (event.Subscription, error)); ok {
		return rf(opts, sink)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *commit_store.CommitStoreTransmitted) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *commit_store.CommitStoreTransmitted) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchUnpaused provides a mock function with given fields: opts, sink
func (_m *CommitStoreInterface) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *commit_store.CommitStoreUnpaused) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	if len(ret) == 0 {
		panic("no return value specified for WatchUnpaused")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *commit_store.CommitStoreUnpaused) (event.Subscription, error)); ok {
		return rf(opts, sink)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *commit_store.CommitStoreUnpaused) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *commit_store.CommitStoreUnpaused) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewCommitStoreInterface creates a new instance of CommitStoreInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCommitStoreInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *CommitStoreInterface {
	mock := &CommitStoreInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
