// Code generated by mockery v2.38.0. DO NOT EDIT.

package mock_arbitrum_rollup_core

import (
	big "math/big"

	arbitrum_rollup_core "github.com/smartcontractkit/chainlink/v2/core/gethwrappers/rebalancer/generated/arbitrum_rollup_core"

	bind "github.com/ethereum/go-ethereum/accounts/abi/bind"

	common "github.com/ethereum/go-ethereum/common"

	event "github.com/ethereum/go-ethereum/event"

	generated "github.com/smartcontractkit/chainlink/v2/core/gethwrappers/generated"

	mock "github.com/stretchr/testify/mock"

	types "github.com/ethereum/go-ethereum/core/types"
)

// ArbRollupCoreInterface is an autogenerated mock type for the ArbRollupCoreInterface type
type ArbRollupCoreInterface struct {
	mock.Mock
}

// Address provides a mock function with given fields:
func (_m *ArbRollupCoreInterface) Address() common.Address {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Address")
	}

	var r0 common.Address
	if rf, ok := ret.Get(0).(func() common.Address); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	return r0
}

// AmountStaked provides a mock function with given fields: opts, staker
func (_m *ArbRollupCoreInterface) AmountStaked(opts *bind.CallOpts, staker common.Address) (*big.Int, error) {
	ret := _m.Called(opts, staker)

	if len(ret) == 0 {
		panic("no return value specified for AmountStaked")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, common.Address) (*big.Int, error)); ok {
		return rf(opts, staker)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, common.Address) *big.Int); ok {
		r0 = rf(opts, staker)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, common.Address) error); ok {
		r1 = rf(opts, staker)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BaseStake provides a mock function with given fields: opts
func (_m *ArbRollupCoreInterface) BaseStake(opts *bind.CallOpts) (*big.Int, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for BaseStake")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (*big.Int, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) *big.Int); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Bridge provides a mock function with given fields: opts
func (_m *ArbRollupCoreInterface) Bridge(opts *bind.CallOpts) (common.Address, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for Bridge")
	}

	var r0 common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (common.Address, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) common.Address); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainId provides a mock function with given fields: opts
func (_m *ArbRollupCoreInterface) ChainId(opts *bind.CallOpts) (*big.Int, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for ChainId")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (*big.Int, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) *big.Int); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChallengeManager provides a mock function with given fields: opts
func (_m *ArbRollupCoreInterface) ChallengeManager(opts *bind.CallOpts) (common.Address, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for ChallengeManager")
	}

	var r0 common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (common.Address, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) common.Address); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ConfirmPeriodBlocks provides a mock function with given fields: opts
func (_m *ArbRollupCoreInterface) ConfirmPeriodBlocks(opts *bind.CallOpts) (uint64, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for ConfirmPeriodBlocks")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (uint64, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) uint64); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CurrentChallenge provides a mock function with given fields: opts, staker
func (_m *ArbRollupCoreInterface) CurrentChallenge(opts *bind.CallOpts, staker common.Address) (uint64, error) {
	ret := _m.Called(opts, staker)

	if len(ret) == 0 {
		panic("no return value specified for CurrentChallenge")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, common.Address) (uint64, error)); ok {
		return rf(opts, staker)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, common.Address) uint64); ok {
		r0 = rf(opts, staker)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, common.Address) error); ok {
		r1 = rf(opts, staker)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExtraChallengeTimeBlocks provides a mock function with given fields: opts
func (_m *ArbRollupCoreInterface) ExtraChallengeTimeBlocks(opts *bind.CallOpts) (uint64, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for ExtraChallengeTimeBlocks")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (uint64, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) uint64); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterNodeConfirmed provides a mock function with given fields: opts, nodeNum
func (_m *ArbRollupCoreInterface) FilterNodeConfirmed(opts *bind.FilterOpts, nodeNum []uint64) (*arbitrum_rollup_core.ArbRollupCoreNodeConfirmedIterator, error) {
	ret := _m.Called(opts, nodeNum)

	if len(ret) == 0 {
		panic("no return value specified for FilterNodeConfirmed")
	}

	var r0 *arbitrum_rollup_core.ArbRollupCoreNodeConfirmedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []uint64) (*arbitrum_rollup_core.ArbRollupCoreNodeConfirmedIterator, error)); ok {
		return rf(opts, nodeNum)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []uint64) *arbitrum_rollup_core.ArbRollupCoreNodeConfirmedIterator); ok {
		r0 = rf(opts, nodeNum)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*arbitrum_rollup_core.ArbRollupCoreNodeConfirmedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []uint64) error); ok {
		r1 = rf(opts, nodeNum)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterNodeCreated provides a mock function with given fields: opts, nodeNum, parentNodeHash, nodeHash
func (_m *ArbRollupCoreInterface) FilterNodeCreated(opts *bind.FilterOpts, nodeNum []uint64, parentNodeHash [][32]byte, nodeHash [][32]byte) (*arbitrum_rollup_core.ArbRollupCoreNodeCreatedIterator, error) {
	ret := _m.Called(opts, nodeNum, parentNodeHash, nodeHash)

	if len(ret) == 0 {
		panic("no return value specified for FilterNodeCreated")
	}

	var r0 *arbitrum_rollup_core.ArbRollupCoreNodeCreatedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []uint64, [][32]byte, [][32]byte) (*arbitrum_rollup_core.ArbRollupCoreNodeCreatedIterator, error)); ok {
		return rf(opts, nodeNum, parentNodeHash, nodeHash)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []uint64, [][32]byte, [][32]byte) *arbitrum_rollup_core.ArbRollupCoreNodeCreatedIterator); ok {
		r0 = rf(opts, nodeNum, parentNodeHash, nodeHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*arbitrum_rollup_core.ArbRollupCoreNodeCreatedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []uint64, [][32]byte, [][32]byte) error); ok {
		r1 = rf(opts, nodeNum, parentNodeHash, nodeHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterNodeRejected provides a mock function with given fields: opts, nodeNum
func (_m *ArbRollupCoreInterface) FilterNodeRejected(opts *bind.FilterOpts, nodeNum []uint64) (*arbitrum_rollup_core.ArbRollupCoreNodeRejectedIterator, error) {
	ret := _m.Called(opts, nodeNum)

	if len(ret) == 0 {
		panic("no return value specified for FilterNodeRejected")
	}

	var r0 *arbitrum_rollup_core.ArbRollupCoreNodeRejectedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []uint64) (*arbitrum_rollup_core.ArbRollupCoreNodeRejectedIterator, error)); ok {
		return rf(opts, nodeNum)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []uint64) *arbitrum_rollup_core.ArbRollupCoreNodeRejectedIterator); ok {
		r0 = rf(opts, nodeNum)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*arbitrum_rollup_core.ArbRollupCoreNodeRejectedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []uint64) error); ok {
		r1 = rf(opts, nodeNum)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterRollupChallengeStarted provides a mock function with given fields: opts, challengeIndex
func (_m *ArbRollupCoreInterface) FilterRollupChallengeStarted(opts *bind.FilterOpts, challengeIndex []uint64) (*arbitrum_rollup_core.ArbRollupCoreRollupChallengeStartedIterator, error) {
	ret := _m.Called(opts, challengeIndex)

	if len(ret) == 0 {
		panic("no return value specified for FilterRollupChallengeStarted")
	}

	var r0 *arbitrum_rollup_core.ArbRollupCoreRollupChallengeStartedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []uint64) (*arbitrum_rollup_core.ArbRollupCoreRollupChallengeStartedIterator, error)); ok {
		return rf(opts, challengeIndex)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []uint64) *arbitrum_rollup_core.ArbRollupCoreRollupChallengeStartedIterator); ok {
		r0 = rf(opts, challengeIndex)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*arbitrum_rollup_core.ArbRollupCoreRollupChallengeStartedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []uint64) error); ok {
		r1 = rf(opts, challengeIndex)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterRollupInitialized provides a mock function with given fields: opts
func (_m *ArbRollupCoreInterface) FilterRollupInitialized(opts *bind.FilterOpts) (*arbitrum_rollup_core.ArbRollupCoreRollupInitializedIterator, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for FilterRollupInitialized")
	}

	var r0 *arbitrum_rollup_core.ArbRollupCoreRollupInitializedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) (*arbitrum_rollup_core.ArbRollupCoreRollupInitializedIterator, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *arbitrum_rollup_core.ArbRollupCoreRollupInitializedIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*arbitrum_rollup_core.ArbRollupCoreRollupInitializedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterUserStakeUpdated provides a mock function with given fields: opts, user
func (_m *ArbRollupCoreInterface) FilterUserStakeUpdated(opts *bind.FilterOpts, user []common.Address) (*arbitrum_rollup_core.ArbRollupCoreUserStakeUpdatedIterator, error) {
	ret := _m.Called(opts, user)

	if len(ret) == 0 {
		panic("no return value specified for FilterUserStakeUpdated")
	}

	var r0 *arbitrum_rollup_core.ArbRollupCoreUserStakeUpdatedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address) (*arbitrum_rollup_core.ArbRollupCoreUserStakeUpdatedIterator, error)); ok {
		return rf(opts, user)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address) *arbitrum_rollup_core.ArbRollupCoreUserStakeUpdatedIterator); ok {
		r0 = rf(opts, user)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*arbitrum_rollup_core.ArbRollupCoreUserStakeUpdatedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []common.Address) error); ok {
		r1 = rf(opts, user)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterUserWithdrawableFundsUpdated provides a mock function with given fields: opts, user
func (_m *ArbRollupCoreInterface) FilterUserWithdrawableFundsUpdated(opts *bind.FilterOpts, user []common.Address) (*arbitrum_rollup_core.ArbRollupCoreUserWithdrawableFundsUpdatedIterator, error) {
	ret := _m.Called(opts, user)

	if len(ret) == 0 {
		panic("no return value specified for FilterUserWithdrawableFundsUpdated")
	}

	var r0 *arbitrum_rollup_core.ArbRollupCoreUserWithdrawableFundsUpdatedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address) (*arbitrum_rollup_core.ArbRollupCoreUserWithdrawableFundsUpdatedIterator, error)); ok {
		return rf(opts, user)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address) *arbitrum_rollup_core.ArbRollupCoreUserWithdrawableFundsUpdatedIterator); ok {
		r0 = rf(opts, user)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*arbitrum_rollup_core.ArbRollupCoreUserWithdrawableFundsUpdatedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []common.Address) error); ok {
		r1 = rf(opts, user)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FirstUnresolvedNode provides a mock function with given fields: opts
func (_m *ArbRollupCoreInterface) FirstUnresolvedNode(opts *bind.CallOpts) (uint64, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for FirstUnresolvedNode")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (uint64, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) uint64); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNode provides a mock function with given fields: opts, nodeNum
func (_m *ArbRollupCoreInterface) GetNode(opts *bind.CallOpts, nodeNum uint64) (arbitrum_rollup_core.Node, error) {
	ret := _m.Called(opts, nodeNum)

	if len(ret) == 0 {
		panic("no return value specified for GetNode")
	}

	var r0 arbitrum_rollup_core.Node
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, uint64) (arbitrum_rollup_core.Node, error)); ok {
		return rf(opts, nodeNum)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, uint64) arbitrum_rollup_core.Node); ok {
		r0 = rf(opts, nodeNum)
	} else {
		r0 = ret.Get(0).(arbitrum_rollup_core.Node)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, uint64) error); ok {
		r1 = rf(opts, nodeNum)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNodeCreationBlockForLogLookup provides a mock function with given fields: opts, nodeNum
func (_m *ArbRollupCoreInterface) GetNodeCreationBlockForLogLookup(opts *bind.CallOpts, nodeNum uint64) (*big.Int, error) {
	ret := _m.Called(opts, nodeNum)

	if len(ret) == 0 {
		panic("no return value specified for GetNodeCreationBlockForLogLookup")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, uint64) (*big.Int, error)); ok {
		return rf(opts, nodeNum)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, uint64) *big.Int); ok {
		r0 = rf(opts, nodeNum)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, uint64) error); ok {
		r1 = rf(opts, nodeNum)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetStaker provides a mock function with given fields: opts, staker
func (_m *ArbRollupCoreInterface) GetStaker(opts *bind.CallOpts, staker common.Address) (arbitrum_rollup_core.IRollupCoreStaker, error) {
	ret := _m.Called(opts, staker)

	if len(ret) == 0 {
		panic("no return value specified for GetStaker")
	}

	var r0 arbitrum_rollup_core.IRollupCoreStaker
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, common.Address) (arbitrum_rollup_core.IRollupCoreStaker, error)); ok {
		return rf(opts, staker)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, common.Address) arbitrum_rollup_core.IRollupCoreStaker); ok {
		r0 = rf(opts, staker)
	} else {
		r0 = ret.Get(0).(arbitrum_rollup_core.IRollupCoreStaker)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, common.Address) error); ok {
		r1 = rf(opts, staker)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetStakerAddress provides a mock function with given fields: opts, stakerNum
func (_m *ArbRollupCoreInterface) GetStakerAddress(opts *bind.CallOpts, stakerNum uint64) (common.Address, error) {
	ret := _m.Called(opts, stakerNum)

	if len(ret) == 0 {
		panic("no return value specified for GetStakerAddress")
	}

	var r0 common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, uint64) (common.Address, error)); ok {
		return rf(opts, stakerNum)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, uint64) common.Address); ok {
		r0 = rf(opts, stakerNum)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, uint64) error); ok {
		r1 = rf(opts, stakerNum)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsStaked provides a mock function with given fields: opts, staker
func (_m *ArbRollupCoreInterface) IsStaked(opts *bind.CallOpts, staker common.Address) (bool, error) {
	ret := _m.Called(opts, staker)

	if len(ret) == 0 {
		panic("no return value specified for IsStaked")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, common.Address) (bool, error)); ok {
		return rf(opts, staker)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, common.Address) bool); ok {
		r0 = rf(opts, staker)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, common.Address) error); ok {
		r1 = rf(opts, staker)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsValidator provides a mock function with given fields: opts, arg0
func (_m *ArbRollupCoreInterface) IsValidator(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	ret := _m.Called(opts, arg0)

	if len(ret) == 0 {
		panic("no return value specified for IsValidator")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, common.Address) (bool, error)); ok {
		return rf(opts, arg0)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, common.Address) bool); ok {
		r0 = rf(opts, arg0)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, common.Address) error); ok {
		r1 = rf(opts, arg0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsZombie provides a mock function with given fields: opts, staker
func (_m *ArbRollupCoreInterface) IsZombie(opts *bind.CallOpts, staker common.Address) (bool, error) {
	ret := _m.Called(opts, staker)

	if len(ret) == 0 {
		panic("no return value specified for IsZombie")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, common.Address) (bool, error)); ok {
		return rf(opts, staker)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, common.Address) bool); ok {
		r0 = rf(opts, staker)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, common.Address) error); ok {
		r1 = rf(opts, staker)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LastStakeBlock provides a mock function with given fields: opts
func (_m *ArbRollupCoreInterface) LastStakeBlock(opts *bind.CallOpts) (uint64, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for LastStakeBlock")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (uint64, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) uint64); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LatestConfirmed provides a mock function with given fields: opts
func (_m *ArbRollupCoreInterface) LatestConfirmed(opts *bind.CallOpts) (uint64, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for LatestConfirmed")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (uint64, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) uint64); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LatestNodeCreated provides a mock function with given fields: opts
func (_m *ArbRollupCoreInterface) LatestNodeCreated(opts *bind.CallOpts) (uint64, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for LatestNodeCreated")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (uint64, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) uint64); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LatestStakedNode provides a mock function with given fields: opts, staker
func (_m *ArbRollupCoreInterface) LatestStakedNode(opts *bind.CallOpts, staker common.Address) (uint64, error) {
	ret := _m.Called(opts, staker)

	if len(ret) == 0 {
		panic("no return value specified for LatestStakedNode")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, common.Address) (uint64, error)); ok {
		return rf(opts, staker)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, common.Address) uint64); ok {
		r0 = rf(opts, staker)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, common.Address) error); ok {
		r1 = rf(opts, staker)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LoserStakeEscrow provides a mock function with given fields: opts
func (_m *ArbRollupCoreInterface) LoserStakeEscrow(opts *bind.CallOpts) (common.Address, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for LoserStakeEscrow")
	}

	var r0 common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (common.Address, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) common.Address); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MinimumAssertionPeriod provides a mock function with given fields: opts
func (_m *ArbRollupCoreInterface) MinimumAssertionPeriod(opts *bind.CallOpts) (*big.Int, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for MinimumAssertionPeriod")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (*big.Int, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) *big.Int); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NodeHasStaker provides a mock function with given fields: opts, nodeNum, staker
func (_m *ArbRollupCoreInterface) NodeHasStaker(opts *bind.CallOpts, nodeNum uint64, staker common.Address) (bool, error) {
	ret := _m.Called(opts, nodeNum, staker)

	if len(ret) == 0 {
		panic("no return value specified for NodeHasStaker")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, uint64, common.Address) (bool, error)); ok {
		return rf(opts, nodeNum, staker)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, uint64, common.Address) bool); ok {
		r0 = rf(opts, nodeNum, staker)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, uint64, common.Address) error); ok {
		r1 = rf(opts, nodeNum, staker)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Outbox provides a mock function with given fields: opts
func (_m *ArbRollupCoreInterface) Outbox(opts *bind.CallOpts) (common.Address, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for Outbox")
	}

	var r0 common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (common.Address, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) common.Address); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseLog provides a mock function with given fields: log
func (_m *ArbRollupCoreInterface) ParseLog(log types.Log) (generated.AbigenLog, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseLog")
	}

	var r0 generated.AbigenLog
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (generated.AbigenLog, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) generated.AbigenLog); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(generated.AbigenLog)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseNodeConfirmed provides a mock function with given fields: log
func (_m *ArbRollupCoreInterface) ParseNodeConfirmed(log types.Log) (*arbitrum_rollup_core.ArbRollupCoreNodeConfirmed, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseNodeConfirmed")
	}

	var r0 *arbitrum_rollup_core.ArbRollupCoreNodeConfirmed
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*arbitrum_rollup_core.ArbRollupCoreNodeConfirmed, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *arbitrum_rollup_core.ArbRollupCoreNodeConfirmed); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*arbitrum_rollup_core.ArbRollupCoreNodeConfirmed)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseNodeCreated provides a mock function with given fields: log
func (_m *ArbRollupCoreInterface) ParseNodeCreated(log types.Log) (*arbitrum_rollup_core.ArbRollupCoreNodeCreated, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseNodeCreated")
	}

	var r0 *arbitrum_rollup_core.ArbRollupCoreNodeCreated
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*arbitrum_rollup_core.ArbRollupCoreNodeCreated, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *arbitrum_rollup_core.ArbRollupCoreNodeCreated); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*arbitrum_rollup_core.ArbRollupCoreNodeCreated)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseNodeRejected provides a mock function with given fields: log
func (_m *ArbRollupCoreInterface) ParseNodeRejected(log types.Log) (*arbitrum_rollup_core.ArbRollupCoreNodeRejected, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseNodeRejected")
	}

	var r0 *arbitrum_rollup_core.ArbRollupCoreNodeRejected
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*arbitrum_rollup_core.ArbRollupCoreNodeRejected, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *arbitrum_rollup_core.ArbRollupCoreNodeRejected); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*arbitrum_rollup_core.ArbRollupCoreNodeRejected)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseRollupChallengeStarted provides a mock function with given fields: log
func (_m *ArbRollupCoreInterface) ParseRollupChallengeStarted(log types.Log) (*arbitrum_rollup_core.ArbRollupCoreRollupChallengeStarted, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseRollupChallengeStarted")
	}

	var r0 *arbitrum_rollup_core.ArbRollupCoreRollupChallengeStarted
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*arbitrum_rollup_core.ArbRollupCoreRollupChallengeStarted, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *arbitrum_rollup_core.ArbRollupCoreRollupChallengeStarted); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*arbitrum_rollup_core.ArbRollupCoreRollupChallengeStarted)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseRollupInitialized provides a mock function with given fields: log
func (_m *ArbRollupCoreInterface) ParseRollupInitialized(log types.Log) (*arbitrum_rollup_core.ArbRollupCoreRollupInitialized, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseRollupInitialized")
	}

	var r0 *arbitrum_rollup_core.ArbRollupCoreRollupInitialized
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*arbitrum_rollup_core.ArbRollupCoreRollupInitialized, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *arbitrum_rollup_core.ArbRollupCoreRollupInitialized); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*arbitrum_rollup_core.ArbRollupCoreRollupInitialized)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseUserStakeUpdated provides a mock function with given fields: log
func (_m *ArbRollupCoreInterface) ParseUserStakeUpdated(log types.Log) (*arbitrum_rollup_core.ArbRollupCoreUserStakeUpdated, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseUserStakeUpdated")
	}

	var r0 *arbitrum_rollup_core.ArbRollupCoreUserStakeUpdated
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*arbitrum_rollup_core.ArbRollupCoreUserStakeUpdated, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *arbitrum_rollup_core.ArbRollupCoreUserStakeUpdated); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*arbitrum_rollup_core.ArbRollupCoreUserStakeUpdated)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseUserWithdrawableFundsUpdated provides a mock function with given fields: log
func (_m *ArbRollupCoreInterface) ParseUserWithdrawableFundsUpdated(log types.Log) (*arbitrum_rollup_core.ArbRollupCoreUserWithdrawableFundsUpdated, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseUserWithdrawableFundsUpdated")
	}

	var r0 *arbitrum_rollup_core.ArbRollupCoreUserWithdrawableFundsUpdated
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*arbitrum_rollup_core.ArbRollupCoreUserWithdrawableFundsUpdated, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *arbitrum_rollup_core.ArbRollupCoreUserWithdrawableFundsUpdated); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*arbitrum_rollup_core.ArbRollupCoreUserWithdrawableFundsUpdated)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RollupEventInbox provides a mock function with given fields: opts
func (_m *ArbRollupCoreInterface) RollupEventInbox(opts *bind.CallOpts) (common.Address, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for RollupEventInbox")
	}

	var r0 common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (common.Address, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) common.Address); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SequencerInbox provides a mock function with given fields: opts
func (_m *ArbRollupCoreInterface) SequencerInbox(opts *bind.CallOpts) (common.Address, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for SequencerInbox")
	}

	var r0 common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (common.Address, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) common.Address); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StakeToken provides a mock function with given fields: opts
func (_m *ArbRollupCoreInterface) StakeToken(opts *bind.CallOpts) (common.Address, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for StakeToken")
	}

	var r0 common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (common.Address, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) common.Address); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StakerCount provides a mock function with given fields: opts
func (_m *ArbRollupCoreInterface) StakerCount(opts *bind.CallOpts) (uint64, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for StakerCount")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (uint64, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) uint64); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ValidatorWhitelistDisabled provides a mock function with given fields: opts
func (_m *ArbRollupCoreInterface) ValidatorWhitelistDisabled(opts *bind.CallOpts) (bool, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for ValidatorWhitelistDisabled")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (bool, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) bool); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WasmModuleRoot provides a mock function with given fields: opts
func (_m *ArbRollupCoreInterface) WasmModuleRoot(opts *bind.CallOpts) ([32]byte, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for WasmModuleRoot")
	}

	var r0 [32]byte
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) ([32]byte, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) [32]byte); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([32]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchNodeConfirmed provides a mock function with given fields: opts, sink, nodeNum
func (_m *ArbRollupCoreInterface) WatchNodeConfirmed(opts *bind.WatchOpts, sink chan<- *arbitrum_rollup_core.ArbRollupCoreNodeConfirmed, nodeNum []uint64) (event.Subscription, error) {
	ret := _m.Called(opts, sink, nodeNum)

	if len(ret) == 0 {
		panic("no return value specified for WatchNodeConfirmed")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *arbitrum_rollup_core.ArbRollupCoreNodeConfirmed, []uint64) (event.Subscription, error)); ok {
		return rf(opts, sink, nodeNum)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *arbitrum_rollup_core.ArbRollupCoreNodeConfirmed, []uint64) event.Subscription); ok {
		r0 = rf(opts, sink, nodeNum)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *arbitrum_rollup_core.ArbRollupCoreNodeConfirmed, []uint64) error); ok {
		r1 = rf(opts, sink, nodeNum)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchNodeCreated provides a mock function with given fields: opts, sink, nodeNum, parentNodeHash, nodeHash
func (_m *ArbRollupCoreInterface) WatchNodeCreated(opts *bind.WatchOpts, sink chan<- *arbitrum_rollup_core.ArbRollupCoreNodeCreated, nodeNum []uint64, parentNodeHash [][32]byte, nodeHash [][32]byte) (event.Subscription, error) {
	ret := _m.Called(opts, sink, nodeNum, parentNodeHash, nodeHash)

	if len(ret) == 0 {
		panic("no return value specified for WatchNodeCreated")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *arbitrum_rollup_core.ArbRollupCoreNodeCreated, []uint64, [][32]byte, [][32]byte) (event.Subscription, error)); ok {
		return rf(opts, sink, nodeNum, parentNodeHash, nodeHash)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *arbitrum_rollup_core.ArbRollupCoreNodeCreated, []uint64, [][32]byte, [][32]byte) event.Subscription); ok {
		r0 = rf(opts, sink, nodeNum, parentNodeHash, nodeHash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *arbitrum_rollup_core.ArbRollupCoreNodeCreated, []uint64, [][32]byte, [][32]byte) error); ok {
		r1 = rf(opts, sink, nodeNum, parentNodeHash, nodeHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchNodeRejected provides a mock function with given fields: opts, sink, nodeNum
func (_m *ArbRollupCoreInterface) WatchNodeRejected(opts *bind.WatchOpts, sink chan<- *arbitrum_rollup_core.ArbRollupCoreNodeRejected, nodeNum []uint64) (event.Subscription, error) {
	ret := _m.Called(opts, sink, nodeNum)

	if len(ret) == 0 {
		panic("no return value specified for WatchNodeRejected")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *arbitrum_rollup_core.ArbRollupCoreNodeRejected, []uint64) (event.Subscription, error)); ok {
		return rf(opts, sink, nodeNum)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *arbitrum_rollup_core.ArbRollupCoreNodeRejected, []uint64) event.Subscription); ok {
		r0 = rf(opts, sink, nodeNum)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *arbitrum_rollup_core.ArbRollupCoreNodeRejected, []uint64) error); ok {
		r1 = rf(opts, sink, nodeNum)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchRollupChallengeStarted provides a mock function with given fields: opts, sink, challengeIndex
func (_m *ArbRollupCoreInterface) WatchRollupChallengeStarted(opts *bind.WatchOpts, sink chan<- *arbitrum_rollup_core.ArbRollupCoreRollupChallengeStarted, challengeIndex []uint64) (event.Subscription, error) {
	ret := _m.Called(opts, sink, challengeIndex)

	if len(ret) == 0 {
		panic("no return value specified for WatchRollupChallengeStarted")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *arbitrum_rollup_core.ArbRollupCoreRollupChallengeStarted, []uint64) (event.Subscription, error)); ok {
		return rf(opts, sink, challengeIndex)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *arbitrum_rollup_core.ArbRollupCoreRollupChallengeStarted, []uint64) event.Subscription); ok {
		r0 = rf(opts, sink, challengeIndex)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *arbitrum_rollup_core.ArbRollupCoreRollupChallengeStarted, []uint64) error); ok {
		r1 = rf(opts, sink, challengeIndex)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchRollupInitialized provides a mock function with given fields: opts, sink
func (_m *ArbRollupCoreInterface) WatchRollupInitialized(opts *bind.WatchOpts, sink chan<- *arbitrum_rollup_core.ArbRollupCoreRollupInitialized) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	if len(ret) == 0 {
		panic("no return value specified for WatchRollupInitialized")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *arbitrum_rollup_core.ArbRollupCoreRollupInitialized) (event.Subscription, error)); ok {
		return rf(opts, sink)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *arbitrum_rollup_core.ArbRollupCoreRollupInitialized) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *arbitrum_rollup_core.ArbRollupCoreRollupInitialized) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchUserStakeUpdated provides a mock function with given fields: opts, sink, user
func (_m *ArbRollupCoreInterface) WatchUserStakeUpdated(opts *bind.WatchOpts, sink chan<- *arbitrum_rollup_core.ArbRollupCoreUserStakeUpdated, user []common.Address) (event.Subscription, error) {
	ret := _m.Called(opts, sink, user)

	if len(ret) == 0 {
		panic("no return value specified for WatchUserStakeUpdated")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *arbitrum_rollup_core.ArbRollupCoreUserStakeUpdated, []common.Address) (event.Subscription, error)); ok {
		return rf(opts, sink, user)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *arbitrum_rollup_core.ArbRollupCoreUserStakeUpdated, []common.Address) event.Subscription); ok {
		r0 = rf(opts, sink, user)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *arbitrum_rollup_core.ArbRollupCoreUserStakeUpdated, []common.Address) error); ok {
		r1 = rf(opts, sink, user)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchUserWithdrawableFundsUpdated provides a mock function with given fields: opts, sink, user
func (_m *ArbRollupCoreInterface) WatchUserWithdrawableFundsUpdated(opts *bind.WatchOpts, sink chan<- *arbitrum_rollup_core.ArbRollupCoreUserWithdrawableFundsUpdated, user []common.Address) (event.Subscription, error) {
	ret := _m.Called(opts, sink, user)

	if len(ret) == 0 {
		panic("no return value specified for WatchUserWithdrawableFundsUpdated")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *arbitrum_rollup_core.ArbRollupCoreUserWithdrawableFundsUpdated, []common.Address) (event.Subscription, error)); ok {
		return rf(opts, sink, user)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *arbitrum_rollup_core.ArbRollupCoreUserWithdrawableFundsUpdated, []common.Address) event.Subscription); ok {
		r0 = rf(opts, sink, user)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *arbitrum_rollup_core.ArbRollupCoreUserWithdrawableFundsUpdated, []common.Address) error); ok {
		r1 = rf(opts, sink, user)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WithdrawableFunds provides a mock function with given fields: opts, owner
func (_m *ArbRollupCoreInterface) WithdrawableFunds(opts *bind.CallOpts, owner common.Address) (*big.Int, error) {
	ret := _m.Called(opts, owner)

	if len(ret) == 0 {
		panic("no return value specified for WithdrawableFunds")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, common.Address) (*big.Int, error)); ok {
		return rf(opts, owner)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, common.Address) *big.Int); ok {
		r0 = rf(opts, owner)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, common.Address) error); ok {
		r1 = rf(opts, owner)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ZombieAddress provides a mock function with given fields: opts, zombieNum
func (_m *ArbRollupCoreInterface) ZombieAddress(opts *bind.CallOpts, zombieNum *big.Int) (common.Address, error) {
	ret := _m.Called(opts, zombieNum)

	if len(ret) == 0 {
		panic("no return value specified for ZombieAddress")
	}

	var r0 common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, *big.Int) (common.Address, error)); ok {
		return rf(opts, zombieNum)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, *big.Int) common.Address); ok {
		r0 = rf(opts, zombieNum)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, *big.Int) error); ok {
		r1 = rf(opts, zombieNum)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ZombieCount provides a mock function with given fields: opts
func (_m *ArbRollupCoreInterface) ZombieCount(opts *bind.CallOpts) (*big.Int, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for ZombieCount")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (*big.Int, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) *big.Int); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ZombieLatestStakedNode provides a mock function with given fields: opts, zombieNum
func (_m *ArbRollupCoreInterface) ZombieLatestStakedNode(opts *bind.CallOpts, zombieNum *big.Int) (uint64, error) {
	ret := _m.Called(opts, zombieNum)

	if len(ret) == 0 {
		panic("no return value specified for ZombieLatestStakedNode")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, *big.Int) (uint64, error)); ok {
		return rf(opts, zombieNum)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, *big.Int) uint64); ok {
		r0 = rf(opts, zombieNum)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, *big.Int) error); ok {
		r1 = rf(opts, zombieNum)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewArbRollupCoreInterface creates a new instance of ArbRollupCoreInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewArbRollupCoreInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *ArbRollupCoreInterface {
	mock := &ArbRollupCoreInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
