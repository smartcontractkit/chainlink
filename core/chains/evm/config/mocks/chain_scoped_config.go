// Code generated by mockery v2.8.0. DO NOT EDIT.

package mocks

import (
	big "math/big"

	assets "github.com/smartcontractkit/chainlink/core/assets"

	chains "github.com/smartcontractkit/chainlink/core/chains"

	common "github.com/ethereum/go-ethereum/common"

	context "context"

	dialects "github.com/smartcontractkit/chainlink/core/store/dialects"

	ethkey "github.com/smartcontractkit/chainlink/core/services/keystore/keys/ethkey"

	gorm "gorm.io/gorm"

	logger "github.com/smartcontractkit/chainlink/core/logger"

	mock "github.com/stretchr/testify/mock"

	models "github.com/smartcontractkit/chainlink/core/store/models"

	net "net"

	networking "github.com/smartcontractkit/libocr/networking"

	offchainreportingtypes "github.com/smartcontractkit/libocr/offchainreporting/types"

	p2pkey "github.com/smartcontractkit/chainlink/core/services/keystore/keys/p2pkey"

	sessions "github.com/gin-gonic/contrib/sessions"

	storeconfig "github.com/smartcontractkit/chainlink/core/store/config"

	time "time"

	types "github.com/smartcontractkit/chainlink/core/chains/evm/types"

	url "net/url"
)

// ChainScopedConfig is an autogenerated mock type for the ChainScopedConfig type
type ChainScopedConfig struct {
	mock.Mock
}

// AdminCredentialsFile provides a mock function with given fields:
func (_m *ChainScopedConfig) AdminCredentialsFile() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// AllowOrigins provides a mock function with given fields:
func (_m *ChainScopedConfig) AllowOrigins() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// AuthenticatedRateLimit provides a mock function with given fields:
func (_m *ChainScopedConfig) AuthenticatedRateLimit() int64 {
	ret := _m.Called()

	var r0 int64
	if rf, ok := ret.Get(0).(func() int64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int64)
	}

	return r0
}

// AuthenticatedRateLimitPeriod provides a mock function with given fields:
func (_m *ChainScopedConfig) AuthenticatedRateLimitPeriod() models.Duration {
	ret := _m.Called()

	var r0 models.Duration
	if rf, ok := ret.Get(0).(func() models.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(models.Duration)
	}

	return r0
}

// BalanceMonitorEnabled provides a mock function with given fields:
func (_m *ChainScopedConfig) BalanceMonitorEnabled() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// BlockBackfillDepth provides a mock function with given fields:
func (_m *ChainScopedConfig) BlockBackfillDepth() uint64 {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// BlockBackfillSkip provides a mock function with given fields:
func (_m *ChainScopedConfig) BlockBackfillSkip() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// BlockEmissionIdleWarningThreshold provides a mock function with given fields:
func (_m *ChainScopedConfig) BlockEmissionIdleWarningThreshold() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// BlockHistoryEstimatorBatchSize provides a mock function with given fields:
func (_m *ChainScopedConfig) BlockHistoryEstimatorBatchSize() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// BlockHistoryEstimatorBlockDelay provides a mock function with given fields:
func (_m *ChainScopedConfig) BlockHistoryEstimatorBlockDelay() uint16 {
	ret := _m.Called()

	var r0 uint16
	if rf, ok := ret.Get(0).(func() uint16); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint16)
	}

	return r0
}

// BlockHistoryEstimatorBlockHistorySize provides a mock function with given fields:
func (_m *ChainScopedConfig) BlockHistoryEstimatorBlockHistorySize() uint16 {
	ret := _m.Called()

	var r0 uint16
	if rf, ok := ret.Get(0).(func() uint16); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint16)
	}

	return r0
}

// BlockHistoryEstimatorTransactionPercentile provides a mock function with given fields:
func (_m *ChainScopedConfig) BlockHistoryEstimatorTransactionPercentile() uint16 {
	ret := _m.Called()

	var r0 uint16
	if rf, ok := ret.Get(0).(func() uint16); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint16)
	}

	return r0
}

// BridgeResponseURL provides a mock function with given fields:
func (_m *ChainScopedConfig) BridgeResponseURL() *url.URL {
	ret := _m.Called()

	var r0 *url.URL
	if rf, ok := ret.Get(0).(func() *url.URL); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*url.URL)
		}
	}

	return r0
}

// CertFile provides a mock function with given fields:
func (_m *ChainScopedConfig) CertFile() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// ChainID provides a mock function with given fields:
func (_m *ChainScopedConfig) ChainID() *big.Int {
	ret := _m.Called()

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func() *big.Int); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	return r0
}

// ChainType provides a mock function with given fields:
func (_m *ChainScopedConfig) ChainType() chains.ChainType {
	ret := _m.Called()

	var r0 chains.ChainType
	if rf, ok := ret.Get(0).(func() chains.ChainType); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(chains.ChainType)
	}

	return r0
}

// ClientNodeURL provides a mock function with given fields:
func (_m *ChainScopedConfig) ClientNodeURL() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// ClobberNodesFromEnv provides a mock function with given fields:
func (_m *ChainScopedConfig) ClobberNodesFromEnv() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Configure provides a mock function with given fields: _a0
func (_m *ChainScopedConfig) Configure(_a0 types.ChainCfg) error {
	ret := _m.Called(_a0)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.ChainCfg) error); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateProductionLogger provides a mock function with given fields:
func (_m *ChainScopedConfig) CreateProductionLogger() logger.Logger {
	ret := _m.Called()

	var r0 logger.Logger
	if rf, ok := ret.Get(0).(func() logger.Logger); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(logger.Logger)
		}
	}

	return r0
}

// DatabaseBackupDir provides a mock function with given fields:
func (_m *ChainScopedConfig) DatabaseBackupDir() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// DatabaseBackupFrequency provides a mock function with given fields:
func (_m *ChainScopedConfig) DatabaseBackupFrequency() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// DatabaseBackupMode provides a mock function with given fields:
func (_m *ChainScopedConfig) DatabaseBackupMode() storeconfig.DatabaseBackupMode {
	ret := _m.Called()

	var r0 storeconfig.DatabaseBackupMode
	if rf, ok := ret.Get(0).(func() storeconfig.DatabaseBackupMode); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(storeconfig.DatabaseBackupMode)
	}

	return r0
}

// DatabaseBackupURL provides a mock function with given fields:
func (_m *ChainScopedConfig) DatabaseBackupURL() *url.URL {
	ret := _m.Called()

	var r0 *url.URL
	if rf, ok := ret.Get(0).(func() *url.URL); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*url.URL)
		}
	}

	return r0
}

// DatabaseListenerMaxReconnectDuration provides a mock function with given fields:
func (_m *ChainScopedConfig) DatabaseListenerMaxReconnectDuration() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// DatabaseListenerMinReconnectInterval provides a mock function with given fields:
func (_m *ChainScopedConfig) DatabaseListenerMinReconnectInterval() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// DatabaseMaximumTxDuration provides a mock function with given fields:
func (_m *ChainScopedConfig) DatabaseMaximumTxDuration() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// DatabaseTimeout provides a mock function with given fields:
func (_m *ChainScopedConfig) DatabaseTimeout() models.Duration {
	ret := _m.Called()

	var r0 models.Duration
	if rf, ok := ret.Get(0).(func() models.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(models.Duration)
	}

	return r0
}

// DatabaseURL provides a mock function with given fields:
func (_m *ChainScopedConfig) DatabaseURL() url.URL {
	ret := _m.Called()

	var r0 url.URL
	if rf, ok := ret.Get(0).(func() url.URL); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(url.URL)
	}

	return r0
}

// DefaultChainID provides a mock function with given fields:
func (_m *ChainScopedConfig) DefaultChainID() *big.Int {
	ret := _m.Called()

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func() *big.Int); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	return r0
}

// DefaultHTTPAllowUnrestrictedNetworkAccess provides a mock function with given fields:
func (_m *ChainScopedConfig) DefaultHTTPAllowUnrestrictedNetworkAccess() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// DefaultHTTPLimit provides a mock function with given fields:
func (_m *ChainScopedConfig) DefaultHTTPLimit() int64 {
	ret := _m.Called()

	var r0 int64
	if rf, ok := ret.Get(0).(func() int64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int64)
	}

	return r0
}

// DefaultHTTPTimeout provides a mock function with given fields:
func (_m *ChainScopedConfig) DefaultHTTPTimeout() models.Duration {
	ret := _m.Called()

	var r0 models.Duration
	if rf, ok := ret.Get(0).(func() models.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(models.Duration)
	}

	return r0
}

// DefaultMaxHTTPAttempts provides a mock function with given fields:
func (_m *ChainScopedConfig) DefaultMaxHTTPAttempts() uint {
	ret := _m.Called()

	var r0 uint
	if rf, ok := ret.Get(0).(func() uint); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint)
	}

	return r0
}

// Dev provides a mock function with given fields:
func (_m *ChainScopedConfig) Dev() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// EVMDisabled provides a mock function with given fields:
func (_m *ChainScopedConfig) EVMDisabled() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// EthTxReaperInterval provides a mock function with given fields:
func (_m *ChainScopedConfig) EthTxReaperInterval() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// EthTxReaperThreshold provides a mock function with given fields:
func (_m *ChainScopedConfig) EthTxReaperThreshold() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// EthTxResendAfterThreshold provides a mock function with given fields:
func (_m *ChainScopedConfig) EthTxResendAfterThreshold() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// EthereumDisabled provides a mock function with given fields:
func (_m *ChainScopedConfig) EthereumDisabled() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// EthereumHTTPURL provides a mock function with given fields:
func (_m *ChainScopedConfig) EthereumHTTPURL() *url.URL {
	ret := _m.Called()

	var r0 *url.URL
	if rf, ok := ret.Get(0).(func() *url.URL); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*url.URL)
		}
	}

	return r0
}

// EthereumSecondaryURLs provides a mock function with given fields:
func (_m *ChainScopedConfig) EthereumSecondaryURLs() []url.URL {
	ret := _m.Called()

	var r0 []url.URL
	if rf, ok := ret.Get(0).(func() []url.URL); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]url.URL)
		}
	}

	return r0
}

// EthereumURL provides a mock function with given fields:
func (_m *ChainScopedConfig) EthereumURL() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// EvmDefaultBatchSize provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmDefaultBatchSize() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// EvmEIP1559DynamicFees provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmEIP1559DynamicFees() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// EvmFinalityDepth provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmFinalityDepth() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// EvmGasBumpPercent provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmGasBumpPercent() uint16 {
	ret := _m.Called()

	var r0 uint16
	if rf, ok := ret.Get(0).(func() uint16); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint16)
	}

	return r0
}

// EvmGasBumpThreshold provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmGasBumpThreshold() uint64 {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// EvmGasBumpTxDepth provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmGasBumpTxDepth() uint16 {
	ret := _m.Called()

	var r0 uint16
	if rf, ok := ret.Get(0).(func() uint16); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint16)
	}

	return r0
}

// EvmGasBumpWei provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmGasBumpWei() *big.Int {
	ret := _m.Called()

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func() *big.Int); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	return r0
}

// EvmGasFeeCap provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmGasFeeCap() *big.Int {
	ret := _m.Called()

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func() *big.Int); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	return r0
}

// EvmGasLimitDefault provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmGasLimitDefault() uint64 {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// EvmGasLimitMultiplier provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmGasLimitMultiplier() float32 {
	ret := _m.Called()

	var r0 float32
	if rf, ok := ret.Get(0).(func() float32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(float32)
	}

	return r0
}

// EvmGasLimitTransfer provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmGasLimitTransfer() uint64 {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// EvmGasPriceDefault provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmGasPriceDefault() *big.Int {
	ret := _m.Called()

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func() *big.Int); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	return r0
}

// EvmGasTipCapDefault provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmGasTipCapDefault() *big.Int {
	ret := _m.Called()

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func() *big.Int); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	return r0
}

// EvmGasTipCapMinimum provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmGasTipCapMinimum() *big.Int {
	ret := _m.Called()

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func() *big.Int); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	return r0
}

// EvmHeadTrackerHistoryDepth provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmHeadTrackerHistoryDepth() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// EvmHeadTrackerMaxBufferSize provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmHeadTrackerMaxBufferSize() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// EvmHeadTrackerSamplingInterval provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmHeadTrackerSamplingInterval() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// EvmLogBackfillBatchSize provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmLogBackfillBatchSize() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// EvmMaxGasPriceWei provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmMaxGasPriceWei() *big.Int {
	ret := _m.Called()

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func() *big.Int); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	return r0
}

// EvmMaxInFlightTransactions provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmMaxInFlightTransactions() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// EvmMaxQueuedTransactions provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmMaxQueuedTransactions() uint64 {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// EvmMinGasPriceWei provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmMinGasPriceWei() *big.Int {
	ret := _m.Called()

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func() *big.Int); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	return r0
}

// EvmNonceAutoSync provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmNonceAutoSync() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// EvmRPCDefaultBatchSize provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmRPCDefaultBatchSize() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// ExplorerAccessKey provides a mock function with given fields:
func (_m *ChainScopedConfig) ExplorerAccessKey() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// ExplorerSecret provides a mock function with given fields:
func (_m *ChainScopedConfig) ExplorerSecret() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// ExplorerURL provides a mock function with given fields:
func (_m *ChainScopedConfig) ExplorerURL() *url.URL {
	ret := _m.Called()

	var r0 *url.URL
	if rf, ok := ret.Get(0).(func() *url.URL); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*url.URL)
		}
	}

	return r0
}

// FMDefaultTransactionQueueDepth provides a mock function with given fields:
func (_m *ChainScopedConfig) FMDefaultTransactionQueueDepth() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// FMSimulateTransactions provides a mock function with given fields:
func (_m *ChainScopedConfig) FMSimulateTransactions() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// FeatureExternalInitiators provides a mock function with given fields:
func (_m *ChainScopedConfig) FeatureExternalInitiators() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// FeatureOffchainReporting provides a mock function with given fields:
func (_m *ChainScopedConfig) FeatureOffchainReporting() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// FeatureUICSAKeys provides a mock function with given fields:
func (_m *ChainScopedConfig) FeatureUICSAKeys() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// FeatureUIFeedsManager provides a mock function with given fields:
func (_m *ChainScopedConfig) FeatureUIFeedsManager() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// FlagsContractAddress provides a mock function with given fields:
func (_m *ChainScopedConfig) FlagsContractAddress() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GasEstimatorMode provides a mock function with given fields:
func (_m *ChainScopedConfig) GasEstimatorMode() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetAdvisoryLockIDConfiguredOrDefault provides a mock function with given fields:
func (_m *ChainScopedConfig) GetAdvisoryLockIDConfiguredOrDefault() int64 {
	ret := _m.Called()

	var r0 int64
	if rf, ok := ret.Get(0).(func() int64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int64)
	}

	return r0
}

// GetDatabaseDialectConfiguredOrDefault provides a mock function with given fields:
func (_m *ChainScopedConfig) GetDatabaseDialectConfiguredOrDefault() dialects.DialectName {
	ret := _m.Called()

	var r0 dialects.DialectName
	if rf, ok := ret.Get(0).(func() dialects.DialectName); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(dialects.DialectName)
	}

	return r0
}

// GlobalBalanceMonitorEnabled provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalBalanceMonitorEnabled() (bool, bool) {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GlobalBlockEmissionIdleWarningThreshold provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalBlockEmissionIdleWarningThreshold() (time.Duration, bool) {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GlobalBlockHistoryEstimatorBatchSize provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalBlockHistoryEstimatorBatchSize() (uint32, bool) {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GlobalBlockHistoryEstimatorBlockDelay provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalBlockHistoryEstimatorBlockDelay() (uint16, bool) {
	ret := _m.Called()

	var r0 uint16
	if rf, ok := ret.Get(0).(func() uint16); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint16)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GlobalBlockHistoryEstimatorBlockHistorySize provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalBlockHistoryEstimatorBlockHistorySize() (uint16, bool) {
	ret := _m.Called()

	var r0 uint16
	if rf, ok := ret.Get(0).(func() uint16); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint16)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GlobalBlockHistoryEstimatorTransactionPercentile provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalBlockHistoryEstimatorTransactionPercentile() (uint16, bool) {
	ret := _m.Called()

	var r0 uint16
	if rf, ok := ret.Get(0).(func() uint16); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint16)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GlobalChainType provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalChainType() (string, bool) {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GlobalEthTxReaperInterval provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalEthTxReaperInterval() (time.Duration, bool) {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GlobalEthTxReaperThreshold provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalEthTxReaperThreshold() (time.Duration, bool) {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GlobalEthTxResendAfterThreshold provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalEthTxResendAfterThreshold() (time.Duration, bool) {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GlobalEvmDefaultBatchSize provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalEvmDefaultBatchSize() (uint32, bool) {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GlobalEvmEIP1559DynamicFees provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalEvmEIP1559DynamicFees() (bool, bool) {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GlobalEvmFinalityDepth provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalEvmFinalityDepth() (uint32, bool) {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GlobalEvmGasBumpPercent provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalEvmGasBumpPercent() (uint16, bool) {
	ret := _m.Called()

	var r0 uint16
	if rf, ok := ret.Get(0).(func() uint16); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint16)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GlobalEvmGasBumpThreshold provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalEvmGasBumpThreshold() (uint64, bool) {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GlobalEvmGasBumpTxDepth provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalEvmGasBumpTxDepth() (uint16, bool) {
	ret := _m.Called()

	var r0 uint16
	if rf, ok := ret.Get(0).(func() uint16); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint16)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GlobalEvmGasBumpWei provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalEvmGasBumpWei() (*big.Int, bool) {
	ret := _m.Called()

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func() *big.Int); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GlobalEvmGasLimitDefault provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalEvmGasLimitDefault() (uint64, bool) {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GlobalEvmGasLimitMultiplier provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalEvmGasLimitMultiplier() (float32, bool) {
	ret := _m.Called()

	var r0 float32
	if rf, ok := ret.Get(0).(func() float32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(float32)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GlobalEvmGasLimitTransfer provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalEvmGasLimitTransfer() (uint64, bool) {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GlobalEvmGasPriceDefault provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalEvmGasPriceDefault() (*big.Int, bool) {
	ret := _m.Called()

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func() *big.Int); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GlobalEvmGasTipCapDefault provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalEvmGasTipCapDefault() (*big.Int, bool) {
	ret := _m.Called()

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func() *big.Int); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GlobalEvmGasTipCapMinimum provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalEvmGasTipCapMinimum() (*big.Int, bool) {
	ret := _m.Called()

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func() *big.Int); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GlobalEvmHeadTrackerHistoryDepth provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalEvmHeadTrackerHistoryDepth() (uint32, bool) {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GlobalEvmHeadTrackerMaxBufferSize provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalEvmHeadTrackerMaxBufferSize() (uint32, bool) {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GlobalEvmHeadTrackerSamplingInterval provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalEvmHeadTrackerSamplingInterval() (time.Duration, bool) {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GlobalEvmLogBackfillBatchSize provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalEvmLogBackfillBatchSize() (uint32, bool) {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GlobalEvmMaxGasPriceWei provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalEvmMaxGasPriceWei() (*big.Int, bool) {
	ret := _m.Called()

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func() *big.Int); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GlobalEvmMaxInFlightTransactions provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalEvmMaxInFlightTransactions() (uint32, bool) {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GlobalEvmMaxQueuedTransactions provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalEvmMaxQueuedTransactions() (uint64, bool) {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GlobalEvmMinGasPriceWei provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalEvmMinGasPriceWei() (*big.Int, bool) {
	ret := _m.Called()

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func() *big.Int); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GlobalEvmNonceAutoSync provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalEvmNonceAutoSync() (bool, bool) {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GlobalEvmRPCDefaultBatchSize provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalEvmRPCDefaultBatchSize() (uint32, bool) {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GlobalFlagsContractAddress provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalFlagsContractAddress() (string, bool) {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GlobalGasEstimatorMode provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalGasEstimatorMode() (string, bool) {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GlobalLinkContractAddress provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalLinkContractAddress() (string, bool) {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GlobalLockRetryInterval provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalLockRetryInterval() models.Duration {
	ret := _m.Called()

	var r0 models.Duration
	if rf, ok := ret.Get(0).(func() models.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(models.Duration)
	}

	return r0
}

// GlobalMinIncomingConfirmations provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalMinIncomingConfirmations() (uint32, bool) {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GlobalMinRequiredOutgoingConfirmations provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalMinRequiredOutgoingConfirmations() (uint64, bool) {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GlobalMinimumContractPayment provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalMinimumContractPayment() (*assets.Link, bool) {
	ret := _m.Called()

	var r0 *assets.Link
	if rf, ok := ret.Get(0).(func() *assets.Link); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*assets.Link)
		}
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GlobalOCRContractConfirmations provides a mock function with given fields:
func (_m *ChainScopedConfig) GlobalOCRContractConfirmations() (uint16, bool) {
	ret := _m.Called()

	var r0 uint16
	if rf, ok := ret.Get(0).(func() uint16); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint16)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func() bool); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// HTTPServerWriteTimeout provides a mock function with given fields:
func (_m *ChainScopedConfig) HTTPServerWriteTimeout() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// InsecureFastScrypt provides a mock function with given fields:
func (_m *ChainScopedConfig) InsecureFastScrypt() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// InsecureSkipVerify provides a mock function with given fields:
func (_m *ChainScopedConfig) InsecureSkipVerify() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// JSONConsole provides a mock function with given fields:
func (_m *ChainScopedConfig) JSONConsole() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// JobPipelineMaxRunDuration provides a mock function with given fields:
func (_m *ChainScopedConfig) JobPipelineMaxRunDuration() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// JobPipelineReaperInterval provides a mock function with given fields:
func (_m *ChainScopedConfig) JobPipelineReaperInterval() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// JobPipelineReaperThreshold provides a mock function with given fields:
func (_m *ChainScopedConfig) JobPipelineReaperThreshold() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// JobPipelineResultWriteQueueDepth provides a mock function with given fields:
func (_m *ChainScopedConfig) JobPipelineResultWriteQueueDepth() uint64 {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// KeeperDefaultTransactionQueueDepth provides a mock function with given fields:
func (_m *ChainScopedConfig) KeeperDefaultTransactionQueueDepth() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// KeeperGasPriceBufferPercent provides a mock function with given fields:
func (_m *ChainScopedConfig) KeeperGasPriceBufferPercent() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// KeeperGasTipCapBufferPercent provides a mock function with given fields:
func (_m *ChainScopedConfig) KeeperGasTipCapBufferPercent() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// KeeperMaximumGracePeriod provides a mock function with given fields:
func (_m *ChainScopedConfig) KeeperMaximumGracePeriod() int64 {
	ret := _m.Called()

	var r0 int64
	if rf, ok := ret.Get(0).(func() int64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int64)
	}

	return r0
}

// KeeperMinimumRequiredConfirmations provides a mock function with given fields:
func (_m *ChainScopedConfig) KeeperMinimumRequiredConfirmations() uint64 {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// KeeperRegistryCheckGasOverhead provides a mock function with given fields:
func (_m *ChainScopedConfig) KeeperRegistryCheckGasOverhead() uint64 {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// KeeperRegistryPerformGasOverhead provides a mock function with given fields:
func (_m *ChainScopedConfig) KeeperRegistryPerformGasOverhead() uint64 {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// KeeperRegistrySyncInterval provides a mock function with given fields:
func (_m *ChainScopedConfig) KeeperRegistrySyncInterval() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// KeyFile provides a mock function with given fields:
func (_m *ChainScopedConfig) KeyFile() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// KeySpecificMaxGasPriceWei provides a mock function with given fields: addr
func (_m *ChainScopedConfig) KeySpecificMaxGasPriceWei(addr common.Address) *big.Int {
	ret := _m.Called(addr)

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func(common.Address) *big.Int); ok {
		r0 = rf(addr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	return r0
}

// LinkContractAddress provides a mock function with given fields:
func (_m *ChainScopedConfig) LinkContractAddress() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// LogLevel provides a mock function with given fields:
func (_m *ChainScopedConfig) LogLevel() storeconfig.LogLevel {
	ret := _m.Called()

	var r0 storeconfig.LogLevel
	if rf, ok := ret.Get(0).(func() storeconfig.LogLevel); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(storeconfig.LogLevel)
	}

	return r0
}

// LogSQLMigrations provides a mock function with given fields:
func (_m *ChainScopedConfig) LogSQLMigrations() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// LogSQLStatements provides a mock function with given fields:
func (_m *ChainScopedConfig) LogSQLStatements() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// LogToDisk provides a mock function with given fields:
func (_m *ChainScopedConfig) LogToDisk() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// MigrateDatabase provides a mock function with given fields:
func (_m *ChainScopedConfig) MigrateDatabase() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// MinIncomingConfirmations provides a mock function with given fields:
func (_m *ChainScopedConfig) MinIncomingConfirmations() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// MinRequiredOutgoingConfirmations provides a mock function with given fields:
func (_m *ChainScopedConfig) MinRequiredOutgoingConfirmations() uint64 {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// MinimumContractPayment provides a mock function with given fields:
func (_m *ChainScopedConfig) MinimumContractPayment() *assets.Link {
	ret := _m.Called()

	var r0 *assets.Link
	if rf, ok := ret.Get(0).(func() *assets.Link); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*assets.Link)
		}
	}

	return r0
}

// OCRBlockchainTimeout provides a mock function with given fields:
func (_m *ChainScopedConfig) OCRBlockchainTimeout() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// OCRBootstrapCheckInterval provides a mock function with given fields:
func (_m *ChainScopedConfig) OCRBootstrapCheckInterval() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// OCRContractConfirmations provides a mock function with given fields:
func (_m *ChainScopedConfig) OCRContractConfirmations() uint16 {
	ret := _m.Called()

	var r0 uint16
	if rf, ok := ret.Get(0).(func() uint16); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint16)
	}

	return r0
}

// OCRContractPollInterval provides a mock function with given fields:
func (_m *ChainScopedConfig) OCRContractPollInterval() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// OCRContractSubscribeInterval provides a mock function with given fields:
func (_m *ChainScopedConfig) OCRContractSubscribeInterval() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// OCRContractTransmitterTransmitTimeout provides a mock function with given fields:
func (_m *ChainScopedConfig) OCRContractTransmitterTransmitTimeout() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// OCRDHTLookupInterval provides a mock function with given fields:
func (_m *ChainScopedConfig) OCRDHTLookupInterval() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// OCRDatabaseTimeout provides a mock function with given fields:
func (_m *ChainScopedConfig) OCRDatabaseTimeout() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// OCRDefaultTransactionQueueDepth provides a mock function with given fields:
func (_m *ChainScopedConfig) OCRDefaultTransactionQueueDepth() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// OCRIncomingMessageBufferSize provides a mock function with given fields:
func (_m *ChainScopedConfig) OCRIncomingMessageBufferSize() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// OCRKeyBundleID provides a mock function with given fields:
func (_m *ChainScopedConfig) OCRKeyBundleID() (string, error) {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OCRMonitoringEndpoint provides a mock function with given fields:
func (_m *ChainScopedConfig) OCRMonitoringEndpoint() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// OCRNewStreamTimeout provides a mock function with given fields:
func (_m *ChainScopedConfig) OCRNewStreamTimeout() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// OCRObservationGracePeriod provides a mock function with given fields:
func (_m *ChainScopedConfig) OCRObservationGracePeriod() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// OCRObservationTimeout provides a mock function with given fields:
func (_m *ChainScopedConfig) OCRObservationTimeout() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// OCROutgoingMessageBufferSize provides a mock function with given fields:
func (_m *ChainScopedConfig) OCROutgoingMessageBufferSize() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// OCRSimulateTransactions provides a mock function with given fields:
func (_m *ChainScopedConfig) OCRSimulateTransactions() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// OCRTraceLogging provides a mock function with given fields:
func (_m *ChainScopedConfig) OCRTraceLogging() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// OCRTransmitterAddress provides a mock function with given fields:
func (_m *ChainScopedConfig) OCRTransmitterAddress() (ethkey.EIP55Address, error) {
	ret := _m.Called()

	var r0 ethkey.EIP55Address
	if rf, ok := ret.Get(0).(func() ethkey.EIP55Address); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(ethkey.EIP55Address)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ORMMaxIdleConns provides a mock function with given fields:
func (_m *ChainScopedConfig) ORMMaxIdleConns() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// ORMMaxOpenConns provides a mock function with given fields:
func (_m *ChainScopedConfig) ORMMaxOpenConns() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// P2PAnnounceIP provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PAnnounceIP() net.IP {
	ret := _m.Called()

	var r0 net.IP
	if rf, ok := ret.Get(0).(func() net.IP); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(net.IP)
		}
	}

	return r0
}

// P2PAnnouncePort provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PAnnouncePort() uint16 {
	ret := _m.Called()

	var r0 uint16
	if rf, ok := ret.Get(0).(func() uint16); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint16)
	}

	return r0
}

// P2PBootstrapPeers provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PBootstrapPeers() ([]string, error) {
	ret := _m.Called()

	var r0 []string
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// P2PDHTAnnouncementCounterUserPrefix provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PDHTAnnouncementCounterUserPrefix() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// P2PListenIP provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PListenIP() net.IP {
	ret := _m.Called()

	var r0 net.IP
	if rf, ok := ret.Get(0).(func() net.IP); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(net.IP)
		}
	}

	return r0
}

// P2PListenPort provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PListenPort() uint16 {
	ret := _m.Called()

	var r0 uint16
	if rf, ok := ret.Get(0).(func() uint16); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint16)
	}

	return r0
}

// P2PListenPortRaw provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PListenPortRaw() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// P2PNetworkingStack provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PNetworkingStack() networking.NetworkingStack {
	ret := _m.Called()

	var r0 networking.NetworkingStack
	if rf, ok := ret.Get(0).(func() networking.NetworkingStack); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(networking.NetworkingStack)
	}

	return r0
}

// P2PNetworkingStackRaw provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PNetworkingStackRaw() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// P2PPeerID provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PPeerID() p2pkey.PeerID {
	ret := _m.Called()

	var r0 p2pkey.PeerID
	if rf, ok := ret.Get(0).(func() p2pkey.PeerID); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(p2pkey.PeerID)
	}

	return r0
}

// P2PPeerIDRaw provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PPeerIDRaw() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// P2PPeerstoreWriteInterval provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PPeerstoreWriteInterval() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// P2PV2AnnounceAddresses provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PV2AnnounceAddresses() []string {
	ret := _m.Called()

	var r0 []string
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// P2PV2AnnounceAddressesRaw provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PV2AnnounceAddressesRaw() []string {
	ret := _m.Called()

	var r0 []string
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// P2PV2Bootstrappers provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PV2Bootstrappers() []offchainreportingtypes.BootstrapperLocator {
	ret := _m.Called()

	var r0 []offchainreportingtypes.BootstrapperLocator
	if rf, ok := ret.Get(0).(func() []offchainreportingtypes.BootstrapperLocator); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]offchainreportingtypes.BootstrapperLocator)
		}
	}

	return r0
}

// P2PV2BootstrappersRaw provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PV2BootstrappersRaw() []string {
	ret := _m.Called()

	var r0 []string
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// P2PV2DeltaDial provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PV2DeltaDial() models.Duration {
	ret := _m.Called()

	var r0 models.Duration
	if rf, ok := ret.Get(0).(func() models.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(models.Duration)
	}

	return r0
}

// P2PV2DeltaReconcile provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PV2DeltaReconcile() models.Duration {
	ret := _m.Called()

	var r0 models.Duration
	if rf, ok := ret.Get(0).(func() models.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(models.Duration)
	}

	return r0
}

// P2PV2ListenAddresses provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PV2ListenAddresses() []string {
	ret := _m.Called()

	var r0 []string
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// Port provides a mock function with given fields:
func (_m *ChainScopedConfig) Port() uint16 {
	ret := _m.Called()

	var r0 uint16
	if rf, ok := ret.Get(0).(func() uint16); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint16)
	}

	return r0
}

// RPID provides a mock function with given fields:
func (_m *ChainScopedConfig) RPID() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// RPOrigin provides a mock function with given fields:
func (_m *ChainScopedConfig) RPOrigin() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// ReaperExpiration provides a mock function with given fields:
func (_m *ChainScopedConfig) ReaperExpiration() models.Duration {
	ret := _m.Called()

	var r0 models.Duration
	if rf, ok := ret.Get(0).(func() models.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(models.Duration)
	}

	return r0
}

// ReplayFromBlock provides a mock function with given fields:
func (_m *ChainScopedConfig) ReplayFromBlock() int64 {
	ret := _m.Called()

	var r0 int64
	if rf, ok := ret.Get(0).(func() int64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int64)
	}

	return r0
}

// RootDir provides a mock function with given fields:
func (_m *ChainScopedConfig) RootDir() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// SecureCookies provides a mock function with given fields:
func (_m *ChainScopedConfig) SecureCookies() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// SessionOptions provides a mock function with given fields:
func (_m *ChainScopedConfig) SessionOptions() sessions.Options {
	ret := _m.Called()

	var r0 sessions.Options
	if rf, ok := ret.Get(0).(func() sessions.Options); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(sessions.Options)
	}

	return r0
}

// SessionSecret provides a mock function with given fields:
func (_m *ChainScopedConfig) SessionSecret() ([]byte, error) {
	ret := _m.Called()

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SessionTimeout provides a mock function with given fields:
func (_m *ChainScopedConfig) SessionTimeout() models.Duration {
	ret := _m.Called()

	var r0 models.Duration
	if rf, ok := ret.Get(0).(func() models.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(models.Duration)
	}

	return r0
}

// SetDB provides a mock function with given fields: _a0
func (_m *ChainScopedConfig) SetDB(_a0 *gorm.DB) {
	_m.Called(_a0)
}

// SetDialect provides a mock function with given fields: _a0
func (_m *ChainScopedConfig) SetDialect(_a0 dialects.DialectName) {
	_m.Called(_a0)
}

// SetEvmGasPriceDefault provides a mock function with given fields: value
func (_m *ChainScopedConfig) SetEvmGasPriceDefault(value *big.Int) error {
	ret := _m.Called(value)

	var r0 error
	if rf, ok := ret.Get(0).(func(*big.Int) error); ok {
		r0 = rf(value)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetLogLevel provides a mock function with given fields: ctx, value
func (_m *ChainScopedConfig) SetLogLevel(ctx context.Context, value string) error {
	ret := _m.Called(ctx, value)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, value)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetLogSQLStatements provides a mock function with given fields: ctx, sqlEnabled
func (_m *ChainScopedConfig) SetLogSQLStatements(ctx context.Context, sqlEnabled bool) error {
	ret := _m.Called(ctx, sqlEnabled)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, bool) error); ok {
		r0 = rf(ctx, sqlEnabled)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StatsPusherLogging provides a mock function with given fields:
func (_m *ChainScopedConfig) StatsPusherLogging() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// TLSCertPath provides a mock function with given fields:
func (_m *ChainScopedConfig) TLSCertPath() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// TLSDir provides a mock function with given fields:
func (_m *ChainScopedConfig) TLSDir() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// TLSHost provides a mock function with given fields:
func (_m *ChainScopedConfig) TLSHost() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// TLSKeyPath provides a mock function with given fields:
func (_m *ChainScopedConfig) TLSKeyPath() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// TLSPort provides a mock function with given fields:
func (_m *ChainScopedConfig) TLSPort() uint16 {
	ret := _m.Called()

	var r0 uint16
	if rf, ok := ret.Get(0).(func() uint16); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint16)
	}

	return r0
}

// TLSRedirect provides a mock function with given fields:
func (_m *ChainScopedConfig) TLSRedirect() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// TelemetryIngressLogging provides a mock function with given fields:
func (_m *ChainScopedConfig) TelemetryIngressLogging() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// TelemetryIngressServerPubKey provides a mock function with given fields:
func (_m *ChainScopedConfig) TelemetryIngressServerPubKey() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// TelemetryIngressURL provides a mock function with given fields:
func (_m *ChainScopedConfig) TelemetryIngressURL() *url.URL {
	ret := _m.Called()

	var r0 *url.URL
	if rf, ok := ret.Get(0).(func() *url.URL); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*url.URL)
		}
	}

	return r0
}

// TriggerFallbackDBPollInterval provides a mock function with given fields:
func (_m *ChainScopedConfig) TriggerFallbackDBPollInterval() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// UnAuthenticatedRateLimit provides a mock function with given fields:
func (_m *ChainScopedConfig) UnAuthenticatedRateLimit() int64 {
	ret := _m.Called()

	var r0 int64
	if rf, ok := ret.Get(0).(func() int64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int64)
	}

	return r0
}

// UnAuthenticatedRateLimitPeriod provides a mock function with given fields:
func (_m *ChainScopedConfig) UnAuthenticatedRateLimitPeriod() models.Duration {
	ret := _m.Called()

	var r0 models.Duration
	if rf, ok := ret.Get(0).(func() models.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(models.Duration)
	}

	return r0
}

// Validate provides a mock function with given fields:
func (_m *ChainScopedConfig) Validate() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
