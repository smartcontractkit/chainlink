// Code generated by mockery v2.28.1. DO NOT EDIT.

package mocks

import (
	big "math/big"

	assets "github.com/smartcontractkit/chainlink/v2/core/assets"

	common "github.com/ethereum/go-ethereum/common"

	commontypes "github.com/smartcontractkit/libocr/commontypes"

	coreconfig "github.com/smartcontractkit/chainlink/v2/core/config"

	ethkey "github.com/smartcontractkit/chainlink/v2/core/services/keystore/keys/ethkey"

	mock "github.com/stretchr/testify/mock"

	models "github.com/smartcontractkit/chainlink/v2/core/store/models"

	net "net"

	networking "github.com/smartcontractkit/libocr/networking"

	ocr2models "github.com/smartcontractkit/chainlink/v2/core/services/ocr2/models"

	p2pkey "github.com/smartcontractkit/chainlink/v2/core/services/keystore/keys/p2pkey"

	time "time"

	url "net/url"

	utils "github.com/smartcontractkit/chainlink/v2/core/utils"

	uuid "github.com/google/uuid"

	zapcore "go.uber.org/zap/zapcore"
)

// ChainScopedConfig is an autogenerated mock type for the ChainScopedConfig type
type ChainScopedConfig struct {
	mock.Mock
}

// AppID provides a mock function with given fields:
func (_m *ChainScopedConfig) AppID() uuid.UUID {
	ret := _m.Called()

	var r0 uuid.UUID
	if rf, ok := ret.Get(0).(func() uuid.UUID); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(uuid.UUID)
		}
	}

	return r0
}

// AuditLogger provides a mock function with given fields:
func (_m *ChainScopedConfig) AuditLogger() coreconfig.AuditLogger {
	ret := _m.Called()

	var r0 coreconfig.AuditLogger
	if rf, ok := ret.Get(0).(func() coreconfig.AuditLogger); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(coreconfig.AuditLogger)
		}
	}

	return r0
}

// AutoCreateKey provides a mock function with given fields:
func (_m *ChainScopedConfig) AutoCreateKey() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// AutoPprofBlockProfileRate provides a mock function with given fields:
func (_m *ChainScopedConfig) AutoPprofBlockProfileRate() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// AutoPprofCPUProfileRate provides a mock function with given fields:
func (_m *ChainScopedConfig) AutoPprofCPUProfileRate() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// AutoPprofEnabled provides a mock function with given fields:
func (_m *ChainScopedConfig) AutoPprofEnabled() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// AutoPprofGatherDuration provides a mock function with given fields:
func (_m *ChainScopedConfig) AutoPprofGatherDuration() models.Duration {
	ret := _m.Called()

	var r0 models.Duration
	if rf, ok := ret.Get(0).(func() models.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(models.Duration)
	}

	return r0
}

// AutoPprofGatherTraceDuration provides a mock function with given fields:
func (_m *ChainScopedConfig) AutoPprofGatherTraceDuration() models.Duration {
	ret := _m.Called()

	var r0 models.Duration
	if rf, ok := ret.Get(0).(func() models.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(models.Duration)
	}

	return r0
}

// AutoPprofGoroutineThreshold provides a mock function with given fields:
func (_m *ChainScopedConfig) AutoPprofGoroutineThreshold() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// AutoPprofMaxProfileSize provides a mock function with given fields:
func (_m *ChainScopedConfig) AutoPprofMaxProfileSize() utils.FileSize {
	ret := _m.Called()

	var r0 utils.FileSize
	if rf, ok := ret.Get(0).(func() utils.FileSize); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(utils.FileSize)
	}

	return r0
}

// AutoPprofMemProfileRate provides a mock function with given fields:
func (_m *ChainScopedConfig) AutoPprofMemProfileRate() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// AutoPprofMemThreshold provides a mock function with given fields:
func (_m *ChainScopedConfig) AutoPprofMemThreshold() utils.FileSize {
	ret := _m.Called()

	var r0 utils.FileSize
	if rf, ok := ret.Get(0).(func() utils.FileSize); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(utils.FileSize)
	}

	return r0
}

// AutoPprofMutexProfileFraction provides a mock function with given fields:
func (_m *ChainScopedConfig) AutoPprofMutexProfileFraction() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// AutoPprofPollInterval provides a mock function with given fields:
func (_m *ChainScopedConfig) AutoPprofPollInterval() models.Duration {
	ret := _m.Called()

	var r0 models.Duration
	if rf, ok := ret.Get(0).(func() models.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(models.Duration)
	}

	return r0
}

// AutoPprofProfileRoot provides a mock function with given fields:
func (_m *ChainScopedConfig) AutoPprofProfileRoot() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// BalanceMonitorEnabled provides a mock function with given fields:
func (_m *ChainScopedConfig) BalanceMonitorEnabled() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// BlockBackfillDepth provides a mock function with given fields:
func (_m *ChainScopedConfig) BlockBackfillDepth() uint64 {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// BlockBackfillSkip provides a mock function with given fields:
func (_m *ChainScopedConfig) BlockBackfillSkip() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// BlockEmissionIdleWarningThreshold provides a mock function with given fields:
func (_m *ChainScopedConfig) BlockEmissionIdleWarningThreshold() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// BlockHistoryEstimatorBatchSize provides a mock function with given fields:
func (_m *ChainScopedConfig) BlockHistoryEstimatorBatchSize() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// BlockHistoryEstimatorBlockDelay provides a mock function with given fields:
func (_m *ChainScopedConfig) BlockHistoryEstimatorBlockDelay() uint16 {
	ret := _m.Called()

	var r0 uint16
	if rf, ok := ret.Get(0).(func() uint16); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint16)
	}

	return r0
}

// BlockHistoryEstimatorBlockHistorySize provides a mock function with given fields:
func (_m *ChainScopedConfig) BlockHistoryEstimatorBlockHistorySize() uint16 {
	ret := _m.Called()

	var r0 uint16
	if rf, ok := ret.Get(0).(func() uint16); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint16)
	}

	return r0
}

// BlockHistoryEstimatorCheckInclusionBlocks provides a mock function with given fields:
func (_m *ChainScopedConfig) BlockHistoryEstimatorCheckInclusionBlocks() uint16 {
	ret := _m.Called()

	var r0 uint16
	if rf, ok := ret.Get(0).(func() uint16); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint16)
	}

	return r0
}

// BlockHistoryEstimatorCheckInclusionPercentile provides a mock function with given fields:
func (_m *ChainScopedConfig) BlockHistoryEstimatorCheckInclusionPercentile() uint16 {
	ret := _m.Called()

	var r0 uint16
	if rf, ok := ret.Get(0).(func() uint16); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint16)
	}

	return r0
}

// BlockHistoryEstimatorEIP1559FeeCapBufferBlocks provides a mock function with given fields:
func (_m *ChainScopedConfig) BlockHistoryEstimatorEIP1559FeeCapBufferBlocks() uint16 {
	ret := _m.Called()

	var r0 uint16
	if rf, ok := ret.Get(0).(func() uint16); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint16)
	}

	return r0
}

// BlockHistoryEstimatorTransactionPercentile provides a mock function with given fields:
func (_m *ChainScopedConfig) BlockHistoryEstimatorTransactionPercentile() uint16 {
	ret := _m.Called()

	var r0 uint16
	if rf, ok := ret.Get(0).(func() uint16); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint16)
	}

	return r0
}

// ChainID provides a mock function with given fields:
func (_m *ChainScopedConfig) ChainID() *big.Int {
	ret := _m.Called()

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func() *big.Int); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	return r0
}

// ChainType provides a mock function with given fields:
func (_m *ChainScopedConfig) ChainType() coreconfig.ChainType {
	ret := _m.Called()

	var r0 coreconfig.ChainType
	if rf, ok := ret.Get(0).(func() coreconfig.ChainType); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(coreconfig.ChainType)
	}

	return r0
}

// CosmosEnabled provides a mock function with given fields:
func (_m *ChainScopedConfig) CosmosEnabled() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Database provides a mock function with given fields:
func (_m *ChainScopedConfig) Database() coreconfig.Database {
	ret := _m.Called()

	var r0 coreconfig.Database
	if rf, ok := ret.Get(0).(func() coreconfig.Database); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(coreconfig.Database)
		}
	}

	return r0
}

// DefaultChainID provides a mock function with given fields:
func (_m *ChainScopedConfig) DefaultChainID() *big.Int {
	ret := _m.Called()

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func() *big.Int); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	return r0
}

// DevWebServer provides a mock function with given fields:
func (_m *ChainScopedConfig) DevWebServer() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// DisableRateLimiting provides a mock function with given fields:
func (_m *ChainScopedConfig) DisableRateLimiting() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// EVMEnabled provides a mock function with given fields:
func (_m *ChainScopedConfig) EVMEnabled() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// EVMRPCEnabled provides a mock function with given fields:
func (_m *ChainScopedConfig) EVMRPCEnabled() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// EthTxReaperInterval provides a mock function with given fields:
func (_m *ChainScopedConfig) EthTxReaperInterval() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// EthTxReaperThreshold provides a mock function with given fields:
func (_m *ChainScopedConfig) EthTxReaperThreshold() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// EthTxResendAfterThreshold provides a mock function with given fields:
func (_m *ChainScopedConfig) EthTxResendAfterThreshold() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// EthereumHTTPURL provides a mock function with given fields:
func (_m *ChainScopedConfig) EthereumHTTPURL() *url.URL {
	ret := _m.Called()

	var r0 *url.URL
	if rf, ok := ret.Get(0).(func() *url.URL); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*url.URL)
		}
	}

	return r0
}

// EthereumSecondaryURLs provides a mock function with given fields:
func (_m *ChainScopedConfig) EthereumSecondaryURLs() []url.URL {
	ret := _m.Called()

	var r0 []url.URL
	if rf, ok := ret.Get(0).(func() []url.URL); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]url.URL)
		}
	}

	return r0
}

// EthereumURL provides a mock function with given fields:
func (_m *ChainScopedConfig) EthereumURL() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// EvmEIP1559DynamicFees provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmEIP1559DynamicFees() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// EvmFinalityDepth provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmFinalityDepth() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// EvmGasBumpPercent provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmGasBumpPercent() uint16 {
	ret := _m.Called()

	var r0 uint16
	if rf, ok := ret.Get(0).(func() uint16); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint16)
	}

	return r0
}

// EvmGasBumpThreshold provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmGasBumpThreshold() uint64 {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// EvmGasBumpTxDepth provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmGasBumpTxDepth() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// EvmGasBumpWei provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmGasBumpWei() *assets.Wei {
	ret := _m.Called()

	var r0 *assets.Wei
	if rf, ok := ret.Get(0).(func() *assets.Wei); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*assets.Wei)
		}
	}

	return r0
}

// EvmGasFeeCapDefault provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmGasFeeCapDefault() *assets.Wei {
	ret := _m.Called()

	var r0 *assets.Wei
	if rf, ok := ret.Get(0).(func() *assets.Wei); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*assets.Wei)
		}
	}

	return r0
}

// EvmGasLimitDRJobType provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmGasLimitDRJobType() *uint32 {
	ret := _m.Called()

	var r0 *uint32
	if rf, ok := ret.Get(0).(func() *uint32); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*uint32)
		}
	}

	return r0
}

// EvmGasLimitDefault provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmGasLimitDefault() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// EvmGasLimitFMJobType provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmGasLimitFMJobType() *uint32 {
	ret := _m.Called()

	var r0 *uint32
	if rf, ok := ret.Get(0).(func() *uint32); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*uint32)
		}
	}

	return r0
}

// EvmGasLimitKeeperJobType provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmGasLimitKeeperJobType() *uint32 {
	ret := _m.Called()

	var r0 *uint32
	if rf, ok := ret.Get(0).(func() *uint32); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*uint32)
		}
	}

	return r0
}

// EvmGasLimitMax provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmGasLimitMax() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// EvmGasLimitMultiplier provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmGasLimitMultiplier() float32 {
	ret := _m.Called()

	var r0 float32
	if rf, ok := ret.Get(0).(func() float32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(float32)
	}

	return r0
}

// EvmGasLimitOCR2JobType provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmGasLimitOCR2JobType() *uint32 {
	ret := _m.Called()

	var r0 *uint32
	if rf, ok := ret.Get(0).(func() *uint32); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*uint32)
		}
	}

	return r0
}

// EvmGasLimitOCRJobType provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmGasLimitOCRJobType() *uint32 {
	ret := _m.Called()

	var r0 *uint32
	if rf, ok := ret.Get(0).(func() *uint32); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*uint32)
		}
	}

	return r0
}

// EvmGasLimitTransfer provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmGasLimitTransfer() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// EvmGasLimitVRFJobType provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmGasLimitVRFJobType() *uint32 {
	ret := _m.Called()

	var r0 *uint32
	if rf, ok := ret.Get(0).(func() *uint32); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*uint32)
		}
	}

	return r0
}

// EvmGasPriceDefault provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmGasPriceDefault() *assets.Wei {
	ret := _m.Called()

	var r0 *assets.Wei
	if rf, ok := ret.Get(0).(func() *assets.Wei); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*assets.Wei)
		}
	}

	return r0
}

// EvmGasTipCapDefault provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmGasTipCapDefault() *assets.Wei {
	ret := _m.Called()

	var r0 *assets.Wei
	if rf, ok := ret.Get(0).(func() *assets.Wei); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*assets.Wei)
		}
	}

	return r0
}

// EvmGasTipCapMinimum provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmGasTipCapMinimum() *assets.Wei {
	ret := _m.Called()

	var r0 *assets.Wei
	if rf, ok := ret.Get(0).(func() *assets.Wei); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*assets.Wei)
		}
	}

	return r0
}

// EvmHeadTrackerHistoryDepth provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmHeadTrackerHistoryDepth() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// EvmHeadTrackerMaxBufferSize provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmHeadTrackerMaxBufferSize() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// EvmHeadTrackerSamplingInterval provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmHeadTrackerSamplingInterval() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// EvmLogBackfillBatchSize provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmLogBackfillBatchSize() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// EvmLogKeepBlocksDepth provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmLogKeepBlocksDepth() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// EvmLogPollInterval provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmLogPollInterval() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// EvmMaxGasPriceWei provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmMaxGasPriceWei() *assets.Wei {
	ret := _m.Called()

	var r0 *assets.Wei
	if rf, ok := ret.Get(0).(func() *assets.Wei); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*assets.Wei)
		}
	}

	return r0
}

// EvmMaxInFlightTransactions provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmMaxInFlightTransactions() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// EvmMaxQueuedTransactions provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmMaxQueuedTransactions() uint64 {
	ret := _m.Called()

	var r0 uint64
	if rf, ok := ret.Get(0).(func() uint64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// EvmMinGasPriceWei provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmMinGasPriceWei() *assets.Wei {
	ret := _m.Called()

	var r0 *assets.Wei
	if rf, ok := ret.Get(0).(func() *assets.Wei); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*assets.Wei)
		}
	}

	return r0
}

// EvmNonceAutoSync provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmNonceAutoSync() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// EvmRPCDefaultBatchSize provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmRPCDefaultBatchSize() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// EvmUseForwarders provides a mock function with given fields:
func (_m *ChainScopedConfig) EvmUseForwarders() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// ExplorerAccessKey provides a mock function with given fields:
func (_m *ChainScopedConfig) ExplorerAccessKey() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// ExplorerSecret provides a mock function with given fields:
func (_m *ChainScopedConfig) ExplorerSecret() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// ExplorerURL provides a mock function with given fields:
func (_m *ChainScopedConfig) ExplorerURL() *url.URL {
	ret := _m.Called()

	var r0 *url.URL
	if rf, ok := ret.Get(0).(func() *url.URL); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*url.URL)
		}
	}

	return r0
}

// FeatureExternalInitiators provides a mock function with given fields:
func (_m *ChainScopedConfig) FeatureExternalInitiators() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// FeatureFeedsManager provides a mock function with given fields:
func (_m *ChainScopedConfig) FeatureFeedsManager() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// FeatureLogPoller provides a mock function with given fields:
func (_m *ChainScopedConfig) FeatureLogPoller() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// FeatureOffchainReporting provides a mock function with given fields:
func (_m *ChainScopedConfig) FeatureOffchainReporting() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// FeatureOffchainReporting2 provides a mock function with given fields:
func (_m *ChainScopedConfig) FeatureOffchainReporting2() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// FeatureUICSAKeys provides a mock function with given fields:
func (_m *ChainScopedConfig) FeatureUICSAKeys() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// FlagsContractAddress provides a mock function with given fields:
func (_m *ChainScopedConfig) FlagsContractAddress() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// FluxMonitor provides a mock function with given fields:
func (_m *ChainScopedConfig) FluxMonitor() coreconfig.FluxMonitor {
	ret := _m.Called()

	var r0 coreconfig.FluxMonitor
	if rf, ok := ret.Get(0).(func() coreconfig.FluxMonitor); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(coreconfig.FluxMonitor)
		}
	}

	return r0
}

// GasEstimatorMode provides a mock function with given fields:
func (_m *ChainScopedConfig) GasEstimatorMode() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// InfiniteDepthQueries provides a mock function with given fields:
func (_m *ChainScopedConfig) InfiniteDepthQueries() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// InsecureFastScrypt provides a mock function with given fields:
func (_m *ChainScopedConfig) InsecureFastScrypt() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// JobPipeline provides a mock function with given fields:
func (_m *ChainScopedConfig) JobPipeline() coreconfig.JobPipeline {
	ret := _m.Called()

	var r0 coreconfig.JobPipeline
	if rf, ok := ret.Get(0).(func() coreconfig.JobPipeline); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(coreconfig.JobPipeline)
		}
	}

	return r0
}

// Keeper provides a mock function with given fields:
func (_m *ChainScopedConfig) Keeper() coreconfig.Keeper {
	ret := _m.Called()

	var r0 coreconfig.Keeper
	if rf, ok := ret.Get(0).(func() coreconfig.Keeper); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(coreconfig.Keeper)
		}
	}

	return r0
}

// KeySpecificMaxGasPriceWei provides a mock function with given fields: addr
func (_m *ChainScopedConfig) KeySpecificMaxGasPriceWei(addr common.Address) *assets.Wei {
	ret := _m.Called(addr)

	var r0 *assets.Wei
	if rf, ok := ret.Get(0).(func(common.Address) *assets.Wei); ok {
		r0 = rf(addr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*assets.Wei)
		}
	}

	return r0
}

// KeystorePassword provides a mock function with given fields:
func (_m *ChainScopedConfig) KeystorePassword() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// LinkContractAddress provides a mock function with given fields:
func (_m *ChainScopedConfig) LinkContractAddress() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Log provides a mock function with given fields:
func (_m *ChainScopedConfig) Log() coreconfig.Log {
	ret := _m.Called()

	var r0 coreconfig.Log
	if rf, ok := ret.Get(0).(func() coreconfig.Log); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(coreconfig.Log)
		}
	}

	return r0
}

// LogConfiguration provides a mock function with given fields: log
func (_m *ChainScopedConfig) LogConfiguration(log coreconfig.LogfFn) {
	_m.Called(log)
}

// MercuryCredentials provides a mock function with given fields: credName
func (_m *ChainScopedConfig) MercuryCredentials(credName string) *ocr2models.MercuryCredentials {
	ret := _m.Called(credName)

	var r0 *ocr2models.MercuryCredentials
	if rf, ok := ret.Get(0).(func(string) *ocr2models.MercuryCredentials); ok {
		r0 = rf(credName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ocr2models.MercuryCredentials)
		}
	}

	return r0
}

// MinIncomingConfirmations provides a mock function with given fields:
func (_m *ChainScopedConfig) MinIncomingConfirmations() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// MinimumContractPayment provides a mock function with given fields:
func (_m *ChainScopedConfig) MinimumContractPayment() *assets.Link {
	ret := _m.Called()

	var r0 *assets.Link
	if rf, ok := ret.Get(0).(func() *assets.Link); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*assets.Link)
		}
	}

	return r0
}

// NodeNoNewHeadsThreshold provides a mock function with given fields:
func (_m *ChainScopedConfig) NodeNoNewHeadsThreshold() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// NodePollFailureThreshold provides a mock function with given fields:
func (_m *ChainScopedConfig) NodePollFailureThreshold() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// NodePollInterval provides a mock function with given fields:
func (_m *ChainScopedConfig) NodePollInterval() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// NodeSelectionMode provides a mock function with given fields:
func (_m *ChainScopedConfig) NodeSelectionMode() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// NodeSyncThreshold provides a mock function with given fields:
func (_m *ChainScopedConfig) NodeSyncThreshold() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// OCR2AutomationGasLimit provides a mock function with given fields:
func (_m *ChainScopedConfig) OCR2AutomationGasLimit() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// OCR2BlockchainTimeout provides a mock function with given fields:
func (_m *ChainScopedConfig) OCR2BlockchainTimeout() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// OCR2CaptureEATelemetry provides a mock function with given fields:
func (_m *ChainScopedConfig) OCR2CaptureEATelemetry() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// OCR2ContractConfirmations provides a mock function with given fields:
func (_m *ChainScopedConfig) OCR2ContractConfirmations() uint16 {
	ret := _m.Called()

	var r0 uint16
	if rf, ok := ret.Get(0).(func() uint16); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint16)
	}

	return r0
}

// OCR2ContractPollInterval provides a mock function with given fields:
func (_m *ChainScopedConfig) OCR2ContractPollInterval() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// OCR2ContractSubscribeInterval provides a mock function with given fields:
func (_m *ChainScopedConfig) OCR2ContractSubscribeInterval() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// OCR2ContractTransmitterTransmitTimeout provides a mock function with given fields:
func (_m *ChainScopedConfig) OCR2ContractTransmitterTransmitTimeout() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// OCR2DatabaseTimeout provides a mock function with given fields:
func (_m *ChainScopedConfig) OCR2DatabaseTimeout() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// OCR2DefaultTransactionQueueDepth provides a mock function with given fields:
func (_m *ChainScopedConfig) OCR2DefaultTransactionQueueDepth() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// OCR2KeyBundleID provides a mock function with given fields:
func (_m *ChainScopedConfig) OCR2KeyBundleID() (string, error) {
	ret := _m.Called()

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func() (string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OCR2SimulateTransactions provides a mock function with given fields:
func (_m *ChainScopedConfig) OCR2SimulateTransactions() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// OCR2TraceLogging provides a mock function with given fields:
func (_m *ChainScopedConfig) OCR2TraceLogging() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// OCRBlockchainTimeout provides a mock function with given fields:
func (_m *ChainScopedConfig) OCRBlockchainTimeout() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// OCRCaptureEATelemetry provides a mock function with given fields:
func (_m *ChainScopedConfig) OCRCaptureEATelemetry() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// OCRContractConfirmations provides a mock function with given fields:
func (_m *ChainScopedConfig) OCRContractConfirmations() uint16 {
	ret := _m.Called()

	var r0 uint16
	if rf, ok := ret.Get(0).(func() uint16); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint16)
	}

	return r0
}

// OCRContractPollInterval provides a mock function with given fields:
func (_m *ChainScopedConfig) OCRContractPollInterval() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// OCRContractSubscribeInterval provides a mock function with given fields:
func (_m *ChainScopedConfig) OCRContractSubscribeInterval() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// OCRContractTransmitterTransmitTimeout provides a mock function with given fields:
func (_m *ChainScopedConfig) OCRContractTransmitterTransmitTimeout() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// OCRDatabaseTimeout provides a mock function with given fields:
func (_m *ChainScopedConfig) OCRDatabaseTimeout() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// OCRDefaultTransactionQueueDepth provides a mock function with given fields:
func (_m *ChainScopedConfig) OCRDefaultTransactionQueueDepth() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// OCRDevelopmentMode provides a mock function with given fields:
func (_m *ChainScopedConfig) OCRDevelopmentMode() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// OCRKeyBundleID provides a mock function with given fields:
func (_m *ChainScopedConfig) OCRKeyBundleID() (string, error) {
	ret := _m.Called()

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func() (string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OCRObservationGracePeriod provides a mock function with given fields:
func (_m *ChainScopedConfig) OCRObservationGracePeriod() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// OCRObservationTimeout provides a mock function with given fields:
func (_m *ChainScopedConfig) OCRObservationTimeout() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// OCRSimulateTransactions provides a mock function with given fields:
func (_m *ChainScopedConfig) OCRSimulateTransactions() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// OCRTraceLogging provides a mock function with given fields:
func (_m *ChainScopedConfig) OCRTraceLogging() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// OCRTransmitterAddress provides a mock function with given fields:
func (_m *ChainScopedConfig) OCRTransmitterAddress() (ethkey.EIP55Address, error) {
	ret := _m.Called()

	var r0 ethkey.EIP55Address
	var r1 error
	if rf, ok := ret.Get(0).(func() (ethkey.EIP55Address, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() ethkey.EIP55Address); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(ethkey.EIP55Address)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OperatorFactoryAddress provides a mock function with given fields:
func (_m *ChainScopedConfig) OperatorFactoryAddress() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// P2PAnnounceIP provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PAnnounceIP() net.IP {
	ret := _m.Called()

	var r0 net.IP
	if rf, ok := ret.Get(0).(func() net.IP); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(net.IP)
		}
	}

	return r0
}

// P2PAnnouncePort provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PAnnouncePort() uint16 {
	ret := _m.Called()

	var r0 uint16
	if rf, ok := ret.Get(0).(func() uint16); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint16)
	}

	return r0
}

// P2PBootstrapCheckInterval provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PBootstrapCheckInterval() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// P2PBootstrapPeers provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PBootstrapPeers() ([]string, error) {
	ret := _m.Called()

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func() ([]string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// P2PDHTAnnouncementCounterUserPrefix provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PDHTAnnouncementCounterUserPrefix() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// P2PDHTLookupInterval provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PDHTLookupInterval() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// P2PEnabled provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PEnabled() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// P2PIncomingMessageBufferSize provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PIncomingMessageBufferSize() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// P2PListenIP provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PListenIP() net.IP {
	ret := _m.Called()

	var r0 net.IP
	if rf, ok := ret.Get(0).(func() net.IP); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(net.IP)
		}
	}

	return r0
}

// P2PListenPort provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PListenPort() uint16 {
	ret := _m.Called()

	var r0 uint16
	if rf, ok := ret.Get(0).(func() uint16); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint16)
	}

	return r0
}

// P2PListenPortRaw provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PListenPortRaw() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// P2PNetworkingStack provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PNetworkingStack() networking.NetworkingStack {
	ret := _m.Called()

	var r0 networking.NetworkingStack
	if rf, ok := ret.Get(0).(func() networking.NetworkingStack); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(networking.NetworkingStack)
	}

	return r0
}

// P2PNetworkingStackRaw provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PNetworkingStackRaw() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// P2PNewStreamTimeout provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PNewStreamTimeout() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// P2POutgoingMessageBufferSize provides a mock function with given fields:
func (_m *ChainScopedConfig) P2POutgoingMessageBufferSize() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// P2PPeerID provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PPeerID() p2pkey.PeerID {
	ret := _m.Called()

	var r0 p2pkey.PeerID
	if rf, ok := ret.Get(0).(func() p2pkey.PeerID); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(p2pkey.PeerID)
	}

	return r0
}

// P2PPeerIDRaw provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PPeerIDRaw() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// P2PPeerstoreWriteInterval provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PPeerstoreWriteInterval() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// P2PV2AnnounceAddresses provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PV2AnnounceAddresses() []string {
	ret := _m.Called()

	var r0 []string
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// P2PV2Bootstrappers provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PV2Bootstrappers() []commontypes.BootstrapperLocator {
	ret := _m.Called()

	var r0 []commontypes.BootstrapperLocator
	if rf, ok := ret.Get(0).(func() []commontypes.BootstrapperLocator); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]commontypes.BootstrapperLocator)
		}
	}

	return r0
}

// P2PV2BootstrappersRaw provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PV2BootstrappersRaw() []string {
	ret := _m.Called()

	var r0 []string
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// P2PV2DeltaDial provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PV2DeltaDial() models.Duration {
	ret := _m.Called()

	var r0 models.Duration
	if rf, ok := ret.Get(0).(func() models.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(models.Duration)
	}

	return r0
}

// P2PV2DeltaReconcile provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PV2DeltaReconcile() models.Duration {
	ret := _m.Called()

	var r0 models.Duration
	if rf, ok := ret.Get(0).(func() models.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(models.Duration)
	}

	return r0
}

// P2PV2ListenAddresses provides a mock function with given fields:
func (_m *ChainScopedConfig) P2PV2ListenAddresses() []string {
	ret := _m.Called()

	var r0 []string
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// PrometheusAuthToken provides a mock function with given fields:
func (_m *ChainScopedConfig) PrometheusAuthToken() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// PyroscopeAuthToken provides a mock function with given fields:
func (_m *ChainScopedConfig) PyroscopeAuthToken() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// PyroscopeEnvironment provides a mock function with given fields:
func (_m *ChainScopedConfig) PyroscopeEnvironment() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// PyroscopeServerAddress provides a mock function with given fields:
func (_m *ChainScopedConfig) PyroscopeServerAddress() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// RootDir provides a mock function with given fields:
func (_m *ChainScopedConfig) RootDir() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Sentry provides a mock function with given fields:
func (_m *ChainScopedConfig) Sentry() coreconfig.Sentry {
	ret := _m.Called()

	var r0 coreconfig.Sentry
	if rf, ok := ret.Get(0).(func() coreconfig.Sentry); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(coreconfig.Sentry)
		}
	}

	return r0
}

// SetLogLevel provides a mock function with given fields: lvl
func (_m *ChainScopedConfig) SetLogLevel(lvl zapcore.Level) error {
	ret := _m.Called(lvl)

	var r0 error
	if rf, ok := ret.Get(0).(func(zapcore.Level) error); ok {
		r0 = rf(lvl)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetLogSQL provides a mock function with given fields: logSQL
func (_m *ChainScopedConfig) SetLogSQL(logSQL bool) {
	_m.Called(logSQL)
}

// SetPasswords provides a mock function with given fields: keystore, vrf
func (_m *ChainScopedConfig) SetPasswords(keystore *string, vrf *string) {
	_m.Called(keystore, vrf)
}

// ShutdownGracePeriod provides a mock function with given fields:
func (_m *ChainScopedConfig) ShutdownGracePeriod() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// SolanaEnabled provides a mock function with given fields:
func (_m *ChainScopedConfig) SolanaEnabled() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// StarkNetEnabled provides a mock function with given fields:
func (_m *ChainScopedConfig) StarkNetEnabled() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// TelemetryIngress provides a mock function with given fields:
func (_m *ChainScopedConfig) TelemetryIngress() coreconfig.TelemetryIngress {
	ret := _m.Called()

	var r0 coreconfig.TelemetryIngress
	if rf, ok := ret.Get(0).(func() coreconfig.TelemetryIngress); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(coreconfig.TelemetryIngress)
		}
	}

	return r0
}

// ThresholdKeyShare provides a mock function with given fields:
func (_m *ChainScopedConfig) ThresholdKeyShare() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// VRFPassword provides a mock function with given fields:
func (_m *ChainScopedConfig) VRFPassword() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Validate provides a mock function with given fields:
func (_m *ChainScopedConfig) Validate() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ValidateDB provides a mock function with given fields:
func (_m *ChainScopedConfig) ValidateDB() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WebServer provides a mock function with given fields:
func (_m *ChainScopedConfig) WebServer() coreconfig.WebServer {
	ret := _m.Called()

	var r0 coreconfig.WebServer
	if rf, ok := ret.Get(0).(func() coreconfig.WebServer); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(coreconfig.WebServer)
		}
	}

	return r0
}

type mockConstructorTestingTNewChainScopedConfig interface {
	mock.TestingT
	Cleanup(func())
}

// NewChainScopedConfig creates a new instance of ChainScopedConfig. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewChainScopedConfig(t mockConstructorTestingTNewChainScopedConfig) *ChainScopedConfig {
	mock := &ChainScopedConfig{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
