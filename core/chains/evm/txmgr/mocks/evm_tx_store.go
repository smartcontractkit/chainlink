// Code generated by mockery v2.28.1. DO NOT EDIT.

package mocks

import (
	context "context"
	big "math/big"

	common "github.com/ethereum/go-ethereum/common"

	evmtypes "github.com/smartcontractkit/chainlink/v2/core/chains/evm/types"

	gas "github.com/smartcontractkit/chainlink/v2/core/chains/evm/gas"

	mock "github.com/stretchr/testify/mock"

	pg "github.com/smartcontractkit/chainlink/v2/core/services/pg"

	time "time"

	types "github.com/smartcontractkit/chainlink/v2/common/txmgr/types"

	uuid "github.com/google/uuid"
)

// EvmTxStore is an autogenerated mock type for the EvmTxStore type
type EvmTxStore struct {
	mock.Mock
}

// Abandon provides a mock function with given fields: id, addr
func (_m *EvmTxStore) Abandon(id *big.Int, addr common.Address) error {
	ret := _m.Called(id, addr)

	var r0 error
	if rf, ok := ret.Get(0).(func(*big.Int, common.Address) error); ok {
		r0 = rf(id, addr)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CheckTxQueueCapacity provides a mock function with given fields: fromAddress, maxQueuedTransactions, chainID, qopts
func (_m *EvmTxStore) CheckTxQueueCapacity(fromAddress common.Address, maxQueuedTransactions uint64, chainID *big.Int, qopts ...pg.QOpt) error {
	_va := make([]interface{}, len(qopts))
	for _i := range qopts {
		_va[_i] = qopts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, fromAddress, maxQueuedTransactions, chainID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(common.Address, uint64, *big.Int, ...pg.QOpt) error); ok {
		r0 = rf(fromAddress, maxQueuedTransactions, chainID, qopts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Close provides a mock function with given fields:
func (_m *EvmTxStore) Close() {
	_m.Called()
}

// CountUnconfirmedTransactions provides a mock function with given fields: fromAddress, chainID, qopts
func (_m *EvmTxStore) CountUnconfirmedTransactions(fromAddress common.Address, chainID *big.Int, qopts ...pg.QOpt) (uint32, error) {
	_va := make([]interface{}, len(qopts))
	for _i := range qopts {
		_va[_i] = qopts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, fromAddress, chainID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 uint32
	var r1 error
	if rf, ok := ret.Get(0).(func(common.Address, *big.Int, ...pg.QOpt) (uint32, error)); ok {
		return rf(fromAddress, chainID, qopts...)
	}
	if rf, ok := ret.Get(0).(func(common.Address, *big.Int, ...pg.QOpt) uint32); ok {
		r0 = rf(fromAddress, chainID, qopts...)
	} else {
		r0 = ret.Get(0).(uint32)
	}

	if rf, ok := ret.Get(1).(func(common.Address, *big.Int, ...pg.QOpt) error); ok {
		r1 = rf(fromAddress, chainID, qopts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CountUnstartedTransactions provides a mock function with given fields: fromAddress, chainID, qopts
func (_m *EvmTxStore) CountUnstartedTransactions(fromAddress common.Address, chainID *big.Int, qopts ...pg.QOpt) (uint32, error) {
	_va := make([]interface{}, len(qopts))
	for _i := range qopts {
		_va[_i] = qopts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, fromAddress, chainID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 uint32
	var r1 error
	if rf, ok := ret.Get(0).(func(common.Address, *big.Int, ...pg.QOpt) (uint32, error)); ok {
		return rf(fromAddress, chainID, qopts...)
	}
	if rf, ok := ret.Get(0).(func(common.Address, *big.Int, ...pg.QOpt) uint32); ok {
		r0 = rf(fromAddress, chainID, qopts...)
	} else {
		r0 = ret.Get(0).(uint32)
	}

	if rf, ok := ret.Get(1).(func(common.Address, *big.Int, ...pg.QOpt) error); ok {
		r1 = rf(fromAddress, chainID, qopts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateTransaction provides a mock function with given fields: txRequest, chainID, qopts
func (_m *EvmTxStore) CreateTransaction(txRequest types.TxRequest[common.Address, common.Hash], chainID *big.Int, qopts ...pg.QOpt) (types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], error) {
	_va := make([]interface{}, len(qopts))
	for _i := range qopts {
		_va[_i] = qopts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, txRequest, chainID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee]
	var r1 error
	if rf, ok := ret.Get(0).(func(types.TxRequest[common.Address, common.Hash], *big.Int, ...pg.QOpt) (types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], error)); ok {
		return rf(txRequest, chainID, qopts...)
	}
	if rf, ok := ret.Get(0).(func(types.TxRequest[common.Address, common.Hash], *big.Int, ...pg.QOpt) types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee]); ok {
		r0 = rf(txRequest, chainID, qopts...)
	} else {
		r0 = ret.Get(0).(types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee])
	}

	if rf, ok := ret.Get(1).(func(types.TxRequest[common.Address, common.Hash], *big.Int, ...pg.QOpt) error); ok {
		r1 = rf(txRequest, chainID, qopts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteInProgressAttempt provides a mock function with given fields: ctx, attempt
func (_m *EvmTxStore) DeleteInProgressAttempt(ctx context.Context, attempt types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee]) error {
	ret := _m.Called(ctx, attempt)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee]) error); ok {
		r0 = rf(ctx, attempt)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FindNextUnstartedTransactionFromAddress provides a mock function with given fields: etx, fromAddress, chainID, qopts
func (_m *EvmTxStore) FindNextUnstartedTransactionFromAddress(etx *types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], fromAddress common.Address, chainID *big.Int, qopts ...pg.QOpt) error {
	_va := make([]interface{}, len(qopts))
	for _i := range qopts {
		_va[_i] = qopts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, etx, fromAddress, chainID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], common.Address, *big.Int, ...pg.QOpt) error); ok {
		r0 = rf(etx, fromAddress, chainID, qopts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FindReceiptsPendingConfirmation provides a mock function with given fields: ctx, blockNum, chainID
func (_m *EvmTxStore) FindReceiptsPendingConfirmation(ctx context.Context, blockNum int64, chainID *big.Int) ([]types.ReceiptPlus[*evmtypes.Receipt], error) {
	ret := _m.Called(ctx, blockNum, chainID)

	var r0 []types.ReceiptPlus[*evmtypes.Receipt]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, *big.Int) ([]types.ReceiptPlus[*evmtypes.Receipt], error)); ok {
		return rf(ctx, blockNum, chainID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, *big.Int) []types.ReceiptPlus[*evmtypes.Receipt]); ok {
		r0 = rf(ctx, blockNum, chainID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.ReceiptPlus[*evmtypes.Receipt])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, *big.Int) error); ok {
		r1 = rf(ctx, blockNum, chainID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindTransactionsConfirmedInBlockRange provides a mock function with given fields: highBlockNumber, lowBlockNumber, chainID
func (_m *EvmTxStore) FindTransactionsConfirmedInBlockRange(highBlockNumber int64, lowBlockNumber int64, chainID *big.Int) ([]*types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], error) {
	ret := _m.Called(highBlockNumber, lowBlockNumber, chainID)

	var r0 []*types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee]
	var r1 error
	if rf, ok := ret.Get(0).(func(int64, int64, *big.Int) ([]*types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], error)); ok {
		return rf(highBlockNumber, lowBlockNumber, chainID)
	}
	if rf, ok := ret.Get(0).(func(int64, int64, *big.Int) []*types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee]); ok {
		r0 = rf(highBlockNumber, lowBlockNumber, chainID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee])
		}
	}

	if rf, ok := ret.Get(1).(func(int64, int64, *big.Int) error); ok {
		r1 = rf(highBlockNumber, lowBlockNumber, chainID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindTxAttempt provides a mock function with given fields: hash
func (_m *EvmTxStore) FindTxAttempt(hash common.Hash) (*types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], error) {
	ret := _m.Called(hash)

	var r0 *types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee]
	var r1 error
	if rf, ok := ret.Get(0).(func(common.Hash) (*types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], error)); ok {
		return rf(hash)
	}
	if rf, ok := ret.Get(0).(func(common.Hash) *types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee]); ok {
		r0 = rf(hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee])
		}
	}

	if rf, ok := ret.Get(1).(func(common.Hash) error); ok {
		r1 = rf(hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindTxAttemptConfirmedByTxIDs provides a mock function with given fields: ids
func (_m *EvmTxStore) FindTxAttemptConfirmedByTxIDs(ids []int64) ([]types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], error) {
	ret := _m.Called(ids)

	var r0 []types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee]
	var r1 error
	if rf, ok := ret.Get(0).(func([]int64) ([]types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], error)); ok {
		return rf(ids)
	}
	if rf, ok := ret.Get(0).(func([]int64) []types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee]); ok {
		r0 = rf(ids)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee])
		}
	}

	if rf, ok := ret.Get(1).(func([]int64) error); ok {
		r1 = rf(ids)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindTxAttemptsConfirmedMissingReceipt provides a mock function with given fields: chainID
func (_m *EvmTxStore) FindTxAttemptsConfirmedMissingReceipt(chainID *big.Int) ([]types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], error) {
	ret := _m.Called(chainID)

	var r0 []types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee]
	var r1 error
	if rf, ok := ret.Get(0).(func(*big.Int) ([]types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], error)); ok {
		return rf(chainID)
	}
	if rf, ok := ret.Get(0).(func(*big.Int) []types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee]); ok {
		r0 = rf(chainID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee])
		}
	}

	if rf, ok := ret.Get(1).(func(*big.Int) error); ok {
		r1 = rf(chainID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindTxAttemptsRequiringReceiptFetch provides a mock function with given fields: chainID
func (_m *EvmTxStore) FindTxAttemptsRequiringReceiptFetch(chainID *big.Int) ([]types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], error) {
	ret := _m.Called(chainID)

	var r0 []types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee]
	var r1 error
	if rf, ok := ret.Get(0).(func(*big.Int) ([]types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], error)); ok {
		return rf(chainID)
	}
	if rf, ok := ret.Get(0).(func(*big.Int) []types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee]); ok {
		r0 = rf(chainID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee])
		}
	}

	if rf, ok := ret.Get(1).(func(*big.Int) error); ok {
		r1 = rf(chainID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindTxAttemptsRequiringResend provides a mock function with given fields: olderThan, maxInFlightTransactions, chainID, address
func (_m *EvmTxStore) FindTxAttemptsRequiringResend(olderThan time.Time, maxInFlightTransactions uint32, chainID *big.Int, address common.Address) ([]types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], error) {
	ret := _m.Called(olderThan, maxInFlightTransactions, chainID, address)

	var r0 []types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee]
	var r1 error
	if rf, ok := ret.Get(0).(func(time.Time, uint32, *big.Int, common.Address) ([]types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], error)); ok {
		return rf(olderThan, maxInFlightTransactions, chainID, address)
	}
	if rf, ok := ret.Get(0).(func(time.Time, uint32, *big.Int, common.Address) []types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee]); ok {
		r0 = rf(olderThan, maxInFlightTransactions, chainID, address)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee])
		}
	}

	if rf, ok := ret.Get(1).(func(time.Time, uint32, *big.Int, common.Address) error); ok {
		r1 = rf(olderThan, maxInFlightTransactions, chainID, address)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindTxByHash provides a mock function with given fields: hash
func (_m *EvmTxStore) FindTxByHash(hash common.Hash) (*types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], error) {
	ret := _m.Called(hash)

	var r0 *types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee]
	var r1 error
	if rf, ok := ret.Get(0).(func(common.Hash) (*types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], error)); ok {
		return rf(hash)
	}
	if rf, ok := ret.Get(0).(func(common.Hash) *types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee]); ok {
		r0 = rf(hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee])
		}
	}

	if rf, ok := ret.Get(1).(func(common.Hash) error); ok {
		r1 = rf(hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindTxWithSequence provides a mock function with given fields: fromAddress, seq
func (_m *EvmTxStore) FindTxWithSequence(fromAddress common.Address, seq evmtypes.Nonce) (*types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], error) {
	ret := _m.Called(fromAddress, seq)

	var r0 *types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee]
	var r1 error
	if rf, ok := ret.Get(0).(func(common.Address, evmtypes.Nonce) (*types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], error)); ok {
		return rf(fromAddress, seq)
	}
	if rf, ok := ret.Get(0).(func(common.Address, evmtypes.Nonce) *types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee]); ok {
		r0 = rf(fromAddress, seq)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee])
		}
	}

	if rf, ok := ret.Get(1).(func(common.Address, evmtypes.Nonce) error); ok {
		r1 = rf(fromAddress, seq)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindTxsRequiringGasBump provides a mock function with given fields: ctx, address, blockNum, gasBumpThreshold, depth, chainID
func (_m *EvmTxStore) FindTxsRequiringGasBump(ctx context.Context, address common.Address, blockNum int64, gasBumpThreshold int64, depth int64, chainID *big.Int) ([]*types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], error) {
	ret := _m.Called(ctx, address, blockNum, gasBumpThreshold, depth, chainID)

	var r0 []*types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address, int64, int64, int64, *big.Int) ([]*types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], error)); ok {
		return rf(ctx, address, blockNum, gasBumpThreshold, depth, chainID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address, int64, int64, int64, *big.Int) []*types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee]); ok {
		r0 = rf(ctx, address, blockNum, gasBumpThreshold, depth, chainID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address, int64, int64, int64, *big.Int) error); ok {
		r1 = rf(ctx, address, blockNum, gasBumpThreshold, depth, chainID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindTxsRequiringResubmissionDueToInsufficientFunds provides a mock function with given fields: address, chainID, qopts
func (_m *EvmTxStore) FindTxsRequiringResubmissionDueToInsufficientFunds(address common.Address, chainID *big.Int, qopts ...pg.QOpt) ([]*types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], error) {
	_va := make([]interface{}, len(qopts))
	for _i := range qopts {
		_va[_i] = qopts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, address, chainID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []*types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee]
	var r1 error
	if rf, ok := ret.Get(0).(func(common.Address, *big.Int, ...pg.QOpt) ([]*types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], error)); ok {
		return rf(address, chainID, qopts...)
	}
	if rf, ok := ret.Get(0).(func(common.Address, *big.Int, ...pg.QOpt) []*types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee]); ok {
		r0 = rf(address, chainID, qopts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee])
		}
	}

	if rf, ok := ret.Get(1).(func(common.Address, *big.Int, ...pg.QOpt) error); ok {
		r1 = rf(address, chainID, qopts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetInProgressTxAttempts provides a mock function with given fields: ctx, address, chainID
func (_m *EvmTxStore) GetInProgressTxAttempts(ctx context.Context, address common.Address, chainID *big.Int) ([]types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], error) {
	ret := _m.Called(ctx, address, chainID)

	var r0 []types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Address, *big.Int) ([]types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], error)); ok {
		return rf(ctx, address, chainID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Address, *big.Int) []types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee]); ok {
		r0 = rf(ctx, address, chainID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Address, *big.Int) error); ok {
		r1 = rf(ctx, address, chainID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTxInProgress provides a mock function with given fields: fromAddress, qopts
func (_m *EvmTxStore) GetTxInProgress(fromAddress common.Address, qopts ...pg.QOpt) (*types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], error) {
	_va := make([]interface{}, len(qopts))
	for _i := range qopts {
		_va[_i] = qopts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, fromAddress)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee]
	var r1 error
	if rf, ok := ret.Get(0).(func(common.Address, ...pg.QOpt) (*types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], error)); ok {
		return rf(fromAddress, qopts...)
	}
	if rf, ok := ret.Get(0).(func(common.Address, ...pg.QOpt) *types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee]); ok {
		r0 = rf(fromAddress, qopts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee])
		}
	}

	if rf, ok := ret.Get(1).(func(common.Address, ...pg.QOpt) error); ok {
		r1 = rf(fromAddress, qopts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HasInProgressTransaction provides a mock function with given fields: account, chainID, qopts
func (_m *EvmTxStore) HasInProgressTransaction(account common.Address, chainID *big.Int, qopts ...pg.QOpt) (bool, error) {
	_va := make([]interface{}, len(qopts))
	for _i := range qopts {
		_va[_i] = qopts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, account, chainID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(common.Address, *big.Int, ...pg.QOpt) (bool, error)); ok {
		return rf(account, chainID, qopts...)
	}
	if rf, ok := ret.Get(0).(func(common.Address, *big.Int, ...pg.QOpt) bool); ok {
		r0 = rf(account, chainID, qopts...)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(common.Address, *big.Int, ...pg.QOpt) error); ok {
		r1 = rf(account, chainID, qopts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LoadTxAttempts provides a mock function with given fields: etx, qopts
func (_m *EvmTxStore) LoadTxAttempts(etx *types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], qopts ...pg.QOpt) error {
	_va := make([]interface{}, len(qopts))
	for _i := range qopts {
		_va[_i] = qopts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, etx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], ...pg.QOpt) error); ok {
		r0 = rf(etx, qopts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MarkAllConfirmedMissingReceipt provides a mock function with given fields: chainID
func (_m *EvmTxStore) MarkAllConfirmedMissingReceipt(chainID *big.Int) error {
	ret := _m.Called(chainID)

	var r0 error
	if rf, ok := ret.Get(0).(func(*big.Int) error); ok {
		r0 = rf(chainID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MarkOldTxesMissingReceiptAsErrored provides a mock function with given fields: blockNum, finalityDepth, chainID, qopts
func (_m *EvmTxStore) MarkOldTxesMissingReceiptAsErrored(blockNum int64, finalityDepth uint32, chainID *big.Int, qopts ...pg.QOpt) error {
	_va := make([]interface{}, len(qopts))
	for _i := range qopts {
		_va[_i] = qopts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, blockNum, finalityDepth, chainID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(int64, uint32, *big.Int, ...pg.QOpt) error); ok {
		r0 = rf(blockNum, finalityDepth, chainID, qopts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PreloadTxes provides a mock function with given fields: attempts, qopts
func (_m *EvmTxStore) PreloadTxes(attempts []types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], qopts ...pg.QOpt) error {
	_va := make([]interface{}, len(qopts))
	for _i := range qopts {
		_va[_i] = qopts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, attempts)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func([]types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], ...pg.QOpt) error); ok {
		r0 = rf(attempts, qopts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PruneUnstartedTxQueue provides a mock function with given fields: queueSize, subject, qopts
func (_m *EvmTxStore) PruneUnstartedTxQueue(queueSize uint32, subject uuid.UUID, qopts ...pg.QOpt) (int64, error) {
	_va := make([]interface{}, len(qopts))
	for _i := range qopts {
		_va[_i] = qopts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, queueSize, subject)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func(uint32, uuid.UUID, ...pg.QOpt) (int64, error)); ok {
		return rf(queueSize, subject, qopts...)
	}
	if rf, ok := ret.Get(0).(func(uint32, uuid.UUID, ...pg.QOpt) int64); ok {
		r0 = rf(queueSize, subject, qopts...)
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func(uint32, uuid.UUID, ...pg.QOpt) error); ok {
		r1 = rf(queueSize, subject, qopts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReapTxHistory provides a mock function with given fields: minBlockNumberToKeep, timeThreshold, chainID
func (_m *EvmTxStore) ReapTxHistory(minBlockNumberToKeep int64, timeThreshold time.Time, chainID *big.Int) error {
	ret := _m.Called(minBlockNumberToKeep, timeThreshold, chainID)

	var r0 error
	if rf, ok := ret.Get(0).(func(int64, time.Time, *big.Int) error); ok {
		r0 = rf(minBlockNumberToKeep, timeThreshold, chainID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SaveConfirmedMissingReceiptAttempt provides a mock function with given fields: ctx, timeout, attempt, broadcastAt
func (_m *EvmTxStore) SaveConfirmedMissingReceiptAttempt(ctx context.Context, timeout time.Duration, attempt *types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], broadcastAt time.Time) error {
	ret := _m.Called(ctx, timeout, attempt, broadcastAt)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, time.Duration, *types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], time.Time) error); ok {
		r0 = rf(ctx, timeout, attempt, broadcastAt)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SaveFetchedReceipts provides a mock function with given fields: receipts, chainID
func (_m *EvmTxStore) SaveFetchedReceipts(receipts []*evmtypes.Receipt, chainID *big.Int) error {
	ret := _m.Called(receipts, chainID)

	var r0 error
	if rf, ok := ret.Get(0).(func([]*evmtypes.Receipt, *big.Int) error); ok {
		r0 = rf(receipts, chainID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SaveInProgressAttempt provides a mock function with given fields: attempt
func (_m *EvmTxStore) SaveInProgressAttempt(attempt *types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee]) error {
	ret := _m.Called(attempt)

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee]) error); ok {
		r0 = rf(attempt)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SaveInsufficientFundsAttempt provides a mock function with given fields: timeout, attempt, broadcastAt
func (_m *EvmTxStore) SaveInsufficientFundsAttempt(timeout time.Duration, attempt *types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], broadcastAt time.Time) error {
	ret := _m.Called(timeout, attempt, broadcastAt)

	var r0 error
	if rf, ok := ret.Get(0).(func(time.Duration, *types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], time.Time) error); ok {
		r0 = rf(timeout, attempt, broadcastAt)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SaveReplacementInProgressAttempt provides a mock function with given fields: oldAttempt, replacementAttempt, qopts
func (_m *EvmTxStore) SaveReplacementInProgressAttempt(oldAttempt types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], replacementAttempt *types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], qopts ...pg.QOpt) error {
	_va := make([]interface{}, len(qopts))
	for _i := range qopts {
		_va[_i] = qopts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, oldAttempt, replacementAttempt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], *types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], ...pg.QOpt) error); ok {
		r0 = rf(oldAttempt, replacementAttempt, qopts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SaveSentAttempt provides a mock function with given fields: timeout, attempt, broadcastAt
func (_m *EvmTxStore) SaveSentAttempt(timeout time.Duration, attempt *types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], broadcastAt time.Time) error {
	ret := _m.Called(timeout, attempt, broadcastAt)

	var r0 error
	if rf, ok := ret.Get(0).(func(time.Duration, *types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], time.Time) error); ok {
		r0 = rf(timeout, attempt, broadcastAt)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetBroadcastBeforeBlockNum provides a mock function with given fields: blockNum, chainID
func (_m *EvmTxStore) SetBroadcastBeforeBlockNum(blockNum int64, chainID *big.Int) error {
	ret := _m.Called(blockNum, chainID)

	var r0 error
	if rf, ok := ret.Get(0).(func(int64, *big.Int) error); ok {
		r0 = rf(blockNum, chainID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Transactions provides a mock function with given fields: offset, limit
func (_m *EvmTxStore) Transactions(offset int, limit int) ([]types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], int, error) {
	ret := _m.Called(offset, limit)

	var r0 []types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee]
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(int, int) ([]types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], int, error)); ok {
		return rf(offset, limit)
	}
	if rf, ok := ret.Get(0).(func(int, int) []types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee]); ok {
		r0 = rf(offset, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee])
		}
	}

	if rf, ok := ret.Get(1).(func(int, int) int); ok {
		r1 = rf(offset, limit)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(int, int) error); ok {
		r2 = rf(offset, limit)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// TransactionsWithAttempts provides a mock function with given fields: offset, limit
func (_m *EvmTxStore) TransactionsWithAttempts(offset int, limit int) ([]types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], int, error) {
	ret := _m.Called(offset, limit)

	var r0 []types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee]
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(int, int) ([]types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], int, error)); ok {
		return rf(offset, limit)
	}
	if rf, ok := ret.Get(0).(func(int, int) []types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee]); ok {
		r0 = rf(offset, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee])
		}
	}

	if rf, ok := ret.Get(1).(func(int, int) int); ok {
		r1 = rf(offset, limit)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(int, int) error); ok {
		r2 = rf(offset, limit)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// TxAttempts provides a mock function with given fields: offset, limit
func (_m *EvmTxStore) TxAttempts(offset int, limit int) ([]types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], int, error) {
	ret := _m.Called(offset, limit)

	var r0 []types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee]
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(int, int) ([]types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], int, error)); ok {
		return rf(offset, limit)
	}
	if rf, ok := ret.Get(0).(func(int, int) []types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee]); ok {
		r0 = rf(offset, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee])
		}
	}

	if rf, ok := ret.Get(1).(func(int, int) int); ok {
		r1 = rf(offset, limit)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(int, int) error); ok {
		r2 = rf(offset, limit)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UpdateBroadcastAts provides a mock function with given fields: now, etxIDs
func (_m *EvmTxStore) UpdateBroadcastAts(now time.Time, etxIDs []int64) error {
	ret := _m.Called(now, etxIDs)

	var r0 error
	if rf, ok := ret.Get(0).(func(time.Time, []int64) error); ok {
		r0 = rf(now, etxIDs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateKeyNextSequence provides a mock function with given fields: newNextSequence, currentNextSequence, address, chainID, qopts
func (_m *EvmTxStore) UpdateKeyNextSequence(newNextSequence evmtypes.Nonce, currentNextSequence evmtypes.Nonce, address common.Address, chainID *big.Int, qopts ...pg.QOpt) error {
	_va := make([]interface{}, len(qopts))
	for _i := range qopts {
		_va[_i] = qopts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, newNextSequence, currentNextSequence, address, chainID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(evmtypes.Nonce, evmtypes.Nonce, common.Address, *big.Int, ...pg.QOpt) error); ok {
		r0 = rf(newNextSequence, currentNextSequence, address, chainID, qopts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateTxAttemptInProgressToBroadcast provides a mock function with given fields: etx, attempt, NewAttemptState, incrNextSequenceCallback, qopts
func (_m *EvmTxStore) UpdateTxAttemptInProgressToBroadcast(etx *types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], attempt types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], NewAttemptState types.TxAttemptState, incrNextSequenceCallback func(pg.Queryer) error, qopts ...pg.QOpt) error {
	_va := make([]interface{}, len(qopts))
	for _i := range qopts {
		_va[_i] = qopts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, etx, attempt, NewAttemptState, incrNextSequenceCallback)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], types.TxAttemptState, func(pg.Queryer) error, ...pg.QOpt) error); ok {
		r0 = rf(etx, attempt, NewAttemptState, incrNextSequenceCallback, qopts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateTxFatalError provides a mock function with given fields: etx, qopts
func (_m *EvmTxStore) UpdateTxFatalError(etx *types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], qopts ...pg.QOpt) error {
	_va := make([]interface{}, len(qopts))
	for _i := range qopts {
		_va[_i] = qopts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, etx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], ...pg.QOpt) error); ok {
		r0 = rf(etx, qopts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateTxForRebroadcast provides a mock function with given fields: etx, etxAttempt
func (_m *EvmTxStore) UpdateTxForRebroadcast(etx types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], etxAttempt types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee]) error {
	ret := _m.Called(etx, etxAttempt)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee]) error); ok {
		r0 = rf(etx, etxAttempt)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateTxUnstartedToInProgress provides a mock function with given fields: etx, attempt, qopts
func (_m *EvmTxStore) UpdateTxUnstartedToInProgress(etx *types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], attempt *types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], qopts ...pg.QOpt) error {
	_va := make([]interface{}, len(qopts))
	for _i := range qopts {
		_va[_i] = qopts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, etx, attempt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.Tx[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], *types.TxAttempt[*big.Int, common.Address, common.Hash, common.Hash, evmtypes.Nonce, gas.EvmFee], ...pg.QOpt) error); ok {
		r0 = rf(etx, attempt, qopts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateTxsUnconfirmed provides a mock function with given fields: ids
func (_m *EvmTxStore) UpdateTxsUnconfirmed(ids []int64) error {
	ret := _m.Called(ids)

	var r0 error
	if rf, ok := ret.Get(0).(func([]int64) error); ok {
		r0 = rf(ids)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type mockConstructorTestingTNewEvmTxStore interface {
	mock.TestingT
	Cleanup(func())
}

// NewEvmTxStore creates a new instance of EvmTxStore. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewEvmTxStore(t mockConstructorTestingTNewEvmTxStore) *EvmTxStore {
	mock := &EvmTxStore{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
