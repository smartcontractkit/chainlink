// Code generated by github.com/smartcontractkit/chainlink-common/pkg/capabilities/cli, DO NOT EDIT.

package logeventcap

import (
	"encoding/json"
	"fmt"
)

type Config struct {
	// ContractAddress corresponds to the JSON schema field "contractAddress".
	ContractAddress string `json:"contractAddress" yaml:"contractAddress" mapstructure:"contractAddress"`

	// ContractEventName corresponds to the JSON schema field "contractEventName".
	ContractEventName string `json:"contractEventName" yaml:"contractEventName" mapstructure:"contractEventName"`

	// ContractName corresponds to the JSON schema field "contractName".
	ContractName string `json:"contractName" yaml:"contractName" mapstructure:"contractName"`

	// ContractReaderConfig corresponds to the JSON schema field
	// "contractReaderConfig".
	ContractReaderConfig ConfigContractReaderConfig `json:"contractReaderConfig" yaml:"contractReaderConfig" mapstructure:"contractReaderConfig"`
}

type ConfigContractReaderConfig struct {
	// Contracts corresponds to the JSON schema field "contracts".
	Contracts ConfigContractReaderConfigContracts `json:"contracts" yaml:"contracts" mapstructure:"contracts"`
}

type ConfigContractReaderConfigContracts map[string]interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConfigContractReaderConfig) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["contracts"]; raw != nil && !ok {
		return fmt.Errorf("field contracts in ConfigContractReaderConfig: required")
	}
	type Plain ConfigContractReaderConfig
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ConfigContractReaderConfig(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Config) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["contractAddress"]; raw != nil && !ok {
		return fmt.Errorf("field contractAddress in Config: required")
	}
	if _, ok := raw["contractEventName"]; raw != nil && !ok {
		return fmt.Errorf("field contractEventName in Config: required")
	}
	if _, ok := raw["contractName"]; raw != nil && !ok {
		return fmt.Errorf("field contractName in Config: required")
	}
	if _, ok := raw["contractReaderConfig"]; raw != nil && !ok {
		return fmt.Errorf("field contractReaderConfig in Config: required")
	}
	type Plain Config
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.ContractAddress) < 42 {
		return fmt.Errorf("field %s length: must be >= %d", "contractAddress", 42)
	}
	if len(plain.ContractEventName) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "contractEventName", 1)
	}
	if len(plain.ContractName) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "contractName", 1)
	}
	*j = Config(plain)
	return nil
}

type Head struct {
	// Hash corresponds to the JSON schema field "Hash".
	Hash *string `json:"Hash,omitempty" yaml:"Hash,omitempty" mapstructure:"Hash,omitempty"`

	// Height corresponds to the JSON schema field "Height".
	Height *string `json:"Height,omitempty" yaml:"Height,omitempty" mapstructure:"Height,omitempty"`

	// Timestamp corresponds to the JSON schema field "Timestamp".
	Timestamp *uint64 `json:"Timestamp,omitempty" yaml:"Timestamp,omitempty" mapstructure:"Timestamp,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Head) UnmarshalJSON(b []byte) error {
	type Plain Head
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Hash != nil && len(*plain.Hash) < 42 {
		return fmt.Errorf("field %s length: must be >= %d", "Hash", 42)
	}
	if plain.Height != nil && len(*plain.Height) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "Height", 1)
	}
	if plain.Timestamp != nil && 10000 > *plain.Timestamp {
		return fmt.Errorf("field %s: must be >= %v", "Timestamp", 10000)
	}
	*j = Head(plain)
	return nil
}

type Output struct {
	// Cursor corresponds to the JSON schema field "Cursor".
	Cursor string `json:"Cursor" yaml:"Cursor" mapstructure:"Cursor"`

	// Data corresponds to the JSON schema field "Data".
	Data OutputData `json:"Data" yaml:"Data" mapstructure:"Data"`

	// Head corresponds to the JSON schema field "Head".
	Head Head `json:"Head" yaml:"Head" mapstructure:"Head"`
}

type OutputData map[string]interface{}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Output) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["Cursor"]; raw != nil && !ok {
		return fmt.Errorf("field Cursor in Output: required")
	}
	if _, ok := raw["Data"]; raw != nil && !ok {
		return fmt.Errorf("field Data in Output: required")
	}
	if _, ok := raw["Head"]; raw != nil && !ok {
		return fmt.Errorf("field Head in Output: required")
	}
	type Plain Output
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.Cursor) < 60 {
		return fmt.Errorf("field %s length: must be >= %d", "Cursor", 60)
	}
	*j = Output(plain)
	return nil
}

type Trigger struct {
	// Config corresponds to the JSON schema field "Config".
	Config *Config `json:"Config,omitempty" yaml:"Config,omitempty" mapstructure:"Config,omitempty"`

	// Outputs corresponds to the JSON schema field "Outputs".
	Outputs *Output `json:"Outputs,omitempty" yaml:"Outputs,omitempty" mapstructure:"Outputs,omitempty"`
}
