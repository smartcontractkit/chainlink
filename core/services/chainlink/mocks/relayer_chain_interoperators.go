// Code generated by mockery v2.28.1. DO NOT EDIT.

package mocks

import (
	context "context"

	chainlink "github.com/smartcontractkit/chainlink/v2/core/services/chainlink"

	cosmos "github.com/smartcontractkit/chainlink/v2/core/chains/cosmos"

	evm "github.com/smartcontractkit/chainlink/v2/core/chains/evm"

	// Manually edited. mockery generates the wrong dependency.  edited to use `loop` rather than `loop/internal`
	// seems to caused by incorrect alias resolution of the relayer dep
	internal "github.com/smartcontractkit/chainlink-relay/pkg/loop"

	mock "github.com/stretchr/testify/mock"

	relay "github.com/smartcontractkit/chainlink/v2/core/services/relay"

	services "github.com/smartcontractkit/chainlink/v2/core/services"

	types "github.com/smartcontractkit/chainlink-relay/pkg/types"
)

// RelayerChainInteroperators is an autogenerated mock type for the RelayerChainInteroperators type
type RelayerChainInteroperators struct {
	mock.Mock
}

// ChainStatus provides a mock function with given fields: ctx, id
func (_m *RelayerChainInteroperators) ChainStatus(ctx context.Context, id relay.ID) (types.ChainStatus, error) {
	ret := _m.Called(ctx, id)

	var r0 types.ChainStatus
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, relay.ID) (types.ChainStatus, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, relay.ID) types.ChainStatus); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Get(0).(types.ChainStatus)
	}

	if rf, ok := ret.Get(1).(func(context.Context, relay.ID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChainStatuses provides a mock function with given fields: ctx, offset, limit
func (_m *RelayerChainInteroperators) ChainStatuses(ctx context.Context, offset int, limit int) ([]types.ChainStatus, int, error) {
	ret := _m.Called(ctx, offset, limit)

	var r0 []types.ChainStatus
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int) ([]types.ChainStatus, int, error)); ok {
		return rf(ctx, offset, limit)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, int) []types.ChainStatus); ok {
		r0 = rf(ctx, offset, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.ChainStatus)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, int) int); ok {
		r1 = rf(ctx, offset, limit)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, int, int) error); ok {
		r2 = rf(ctx, offset, limit)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Get provides a mock function with given fields: id
func (_m *RelayerChainInteroperators) Get(id relay.ID) (internal.Relayer, error) {
	ret := _m.Called(id)

	var r0 internal.Relayer
	var r1 error
	if rf, ok := ret.Get(0).(func(relay.ID) (internal.Relayer, error)); ok {
		return rf(id)
	}
	if rf, ok := ret.Get(0).(func(relay.ID) internal.Relayer); ok {
		r0 = rf(id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(internal.Relayer)
		}
	}

	if rf, ok := ret.Get(1).(func(relay.ID) error); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LegacyCosmosChains provides a mock function with given fields:
func (_m *RelayerChainInteroperators) LegacyCosmosChains() cosmos.LegacyChainContainer {
	ret := _m.Called()

	var r0 cosmos.LegacyChainContainer
	if rf, ok := ret.Get(0).(func() cosmos.LegacyChainContainer); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(cosmos.LegacyChainContainer)
		}
	}

	return r0
}

// LegacyEVMChains provides a mock function with given fields:
func (_m *RelayerChainInteroperators) LegacyEVMChains() evm.LegacyChainContainer {
	ret := _m.Called()

	var r0 evm.LegacyChainContainer
	if rf, ok := ret.Get(0).(func() evm.LegacyChainContainer); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(evm.LegacyChainContainer)
		}
	}

	return r0
}

// List provides a mock function with given fields: filter
func (_m *RelayerChainInteroperators) List(filter chainlink.FilterFn) chainlink.RelayerChainInteroperators {
	ret := _m.Called(filter)

	var r0 chainlink.RelayerChainInteroperators
	if rf, ok := ret.Get(0).(func(chainlink.FilterFn) chainlink.RelayerChainInteroperators); ok {
		r0 = rf(filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(chainlink.RelayerChainInteroperators)
		}
	}

	return r0
}

// NodeStatuses provides a mock function with given fields: ctx, offset, limit, relayIDs
func (_m *RelayerChainInteroperators) NodeStatuses(ctx context.Context, offset int, limit int, relayIDs ...relay.ID) ([]types.NodeStatus, int, error) {
	_va := make([]interface{}, len(relayIDs))
	for _i := range relayIDs {
		_va[_i] = relayIDs[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, offset, limit)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []types.NodeStatus
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int, ...relay.ID) ([]types.NodeStatus, int, error)); ok {
		return rf(ctx, offset, limit, relayIDs...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, int, ...relay.ID) []types.NodeStatus); ok {
		r0 = rf(ctx, offset, limit, relayIDs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]types.NodeStatus)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, int, ...relay.ID) int); ok {
		r1 = rf(ctx, offset, limit, relayIDs...)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, int, int, ...relay.ID) error); ok {
		r2 = rf(ctx, offset, limit, relayIDs...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Services provides a mock function with given fields:
func (_m *RelayerChainInteroperators) Services() []services.ServiceCtx {
	ret := _m.Called()

	var r0 []services.ServiceCtx
	if rf, ok := ret.Get(0).(func() []services.ServiceCtx); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]services.ServiceCtx)
		}
	}

	return r0
}

// Slice provides a mock function with given fields:
func (_m *RelayerChainInteroperators) Slice() []internal.Relayer {
	ret := _m.Called()

	var r0 []internal.Relayer
	if rf, ok := ret.Get(0).(func() []internal.Relayer); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]internal.Relayer)
		}
	}

	return r0
}

type mockConstructorTestingTNewRelayerChainInteroperators interface {
	mock.TestingT
	Cleanup(func())
}

// NewRelayerChainInteroperators creates a new instance of RelayerChainInteroperators. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewRelayerChainInteroperators(t mockConstructorTestingTNewRelayerChainInteroperators) *RelayerChainInteroperators {
	mock := &RelayerChainInteroperators{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
