// Code generated by mockery v2.42.2. DO NOT EDIT.

package mocks

import (
	big "math/big"

	bind "github.com/ethereum/go-ethereum/accounts/abi/bind"
	common "github.com/ethereum/go-ethereum/common"

	event "github.com/ethereum/go-ethereum/event"

	flux_aggregator_wrapper "github.com/smartcontractkit/chainlink/v2/core/gethwrappers/generated/flux_aggregator_wrapper"

	generated "github.com/smartcontractkit/chainlink/v2/core/gethwrappers/generated"

	mock "github.com/stretchr/testify/mock"

	types "github.com/ethereum/go-ethereum/core/types"
)

// FluxAggregator is an autogenerated mock type for the FluxAggregatorInterface type
type FluxAggregator struct {
	mock.Mock
}

// AcceptAdmin provides a mock function with given fields: opts, _oracle
func (_m *FluxAggregator) AcceptAdmin(opts *bind.TransactOpts, _oracle common.Address) (*types.Transaction, error) {
	ret := _m.Called(opts, _oracle)

	if len(ret) == 0 {
		panic("no return value specified for AcceptAdmin")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address) (*types.Transaction, error)); ok {
		return rf(opts, _oracle)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address) *types.Transaction); ok {
		r0 = rf(opts, _oracle)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, common.Address) error); ok {
		r1 = rf(opts, _oracle)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AcceptOwnership provides a mock function with given fields: opts
func (_m *FluxAggregator) AcceptOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for AcceptOwnership")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts) (*types.Transaction, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts) *types.Transaction); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Address provides a mock function with given fields:
func (_m *FluxAggregator) Address() common.Address {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Address")
	}

	var r0 common.Address
	if rf, ok := ret.Get(0).(func() common.Address); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	return r0
}

// AllocatedFunds provides a mock function with given fields: opts
func (_m *FluxAggregator) AllocatedFunds(opts *bind.CallOpts) (*big.Int, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for AllocatedFunds")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (*big.Int, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) *big.Int); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AvailableFunds provides a mock function with given fields: opts
func (_m *FluxAggregator) AvailableFunds(opts *bind.CallOpts) (*big.Int, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for AvailableFunds")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (*big.Int, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) *big.Int); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChangeOracles provides a mock function with given fields: opts, _removed, _added, _addedAdmins, _minSubmissions, _maxSubmissions, _restartDelay
func (_m *FluxAggregator) ChangeOracles(opts *bind.TransactOpts, _removed []common.Address, _added []common.Address, _addedAdmins []common.Address, _minSubmissions uint32, _maxSubmissions uint32, _restartDelay uint32) (*types.Transaction, error) {
	ret := _m.Called(opts, _removed, _added, _addedAdmins, _minSubmissions, _maxSubmissions, _restartDelay)

	if len(ret) == 0 {
		panic("no return value specified for ChangeOracles")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []common.Address, []common.Address, []common.Address, uint32, uint32, uint32) (*types.Transaction, error)); ok {
		return rf(opts, _removed, _added, _addedAdmins, _minSubmissions, _maxSubmissions, _restartDelay)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, []common.Address, []common.Address, []common.Address, uint32, uint32, uint32) *types.Transaction); ok {
		r0 = rf(opts, _removed, _added, _addedAdmins, _minSubmissions, _maxSubmissions, _restartDelay)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, []common.Address, []common.Address, []common.Address, uint32, uint32, uint32) error); ok {
		r1 = rf(opts, _removed, _added, _addedAdmins, _minSubmissions, _maxSubmissions, _restartDelay)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Decimals provides a mock function with given fields: opts
func (_m *FluxAggregator) Decimals(opts *bind.CallOpts) (uint8, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for Decimals")
	}

	var r0 uint8
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (uint8, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) uint8); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(uint8)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Description provides a mock function with given fields: opts
func (_m *FluxAggregator) Description(opts *bind.CallOpts) (string, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for Description")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (string, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) string); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterAnswerUpdated provides a mock function with given fields: opts, current, roundId
func (_m *FluxAggregator) FilterAnswerUpdated(opts *bind.FilterOpts, current []*big.Int, roundId []*big.Int) (*flux_aggregator_wrapper.FluxAggregatorAnswerUpdatedIterator, error) {
	ret := _m.Called(opts, current, roundId)

	if len(ret) == 0 {
		panic("no return value specified for FilterAnswerUpdated")
	}

	var r0 *flux_aggregator_wrapper.FluxAggregatorAnswerUpdatedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []*big.Int, []*big.Int) (*flux_aggregator_wrapper.FluxAggregatorAnswerUpdatedIterator, error)); ok {
		return rf(opts, current, roundId)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []*big.Int, []*big.Int) *flux_aggregator_wrapper.FluxAggregatorAnswerUpdatedIterator); ok {
		r0 = rf(opts, current, roundId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flux_aggregator_wrapper.FluxAggregatorAnswerUpdatedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []*big.Int, []*big.Int) error); ok {
		r1 = rf(opts, current, roundId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterAvailableFundsUpdated provides a mock function with given fields: opts, amount
func (_m *FluxAggregator) FilterAvailableFundsUpdated(opts *bind.FilterOpts, amount []*big.Int) (*flux_aggregator_wrapper.FluxAggregatorAvailableFundsUpdatedIterator, error) {
	ret := _m.Called(opts, amount)

	if len(ret) == 0 {
		panic("no return value specified for FilterAvailableFundsUpdated")
	}

	var r0 *flux_aggregator_wrapper.FluxAggregatorAvailableFundsUpdatedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []*big.Int) (*flux_aggregator_wrapper.FluxAggregatorAvailableFundsUpdatedIterator, error)); ok {
		return rf(opts, amount)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []*big.Int) *flux_aggregator_wrapper.FluxAggregatorAvailableFundsUpdatedIterator); ok {
		r0 = rf(opts, amount)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flux_aggregator_wrapper.FluxAggregatorAvailableFundsUpdatedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []*big.Int) error); ok {
		r1 = rf(opts, amount)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterNewRound provides a mock function with given fields: opts, roundId, startedBy
func (_m *FluxAggregator) FilterNewRound(opts *bind.FilterOpts, roundId []*big.Int, startedBy []common.Address) (*flux_aggregator_wrapper.FluxAggregatorNewRoundIterator, error) {
	ret := _m.Called(opts, roundId, startedBy)

	if len(ret) == 0 {
		panic("no return value specified for FilterNewRound")
	}

	var r0 *flux_aggregator_wrapper.FluxAggregatorNewRoundIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []*big.Int, []common.Address) (*flux_aggregator_wrapper.FluxAggregatorNewRoundIterator, error)); ok {
		return rf(opts, roundId, startedBy)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []*big.Int, []common.Address) *flux_aggregator_wrapper.FluxAggregatorNewRoundIterator); ok {
		r0 = rf(opts, roundId, startedBy)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flux_aggregator_wrapper.FluxAggregatorNewRoundIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []*big.Int, []common.Address) error); ok {
		r1 = rf(opts, roundId, startedBy)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterOracleAdminUpdateRequested provides a mock function with given fields: opts, oracle
func (_m *FluxAggregator) FilterOracleAdminUpdateRequested(opts *bind.FilterOpts, oracle []common.Address) (*flux_aggregator_wrapper.FluxAggregatorOracleAdminUpdateRequestedIterator, error) {
	ret := _m.Called(opts, oracle)

	if len(ret) == 0 {
		panic("no return value specified for FilterOracleAdminUpdateRequested")
	}

	var r0 *flux_aggregator_wrapper.FluxAggregatorOracleAdminUpdateRequestedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address) (*flux_aggregator_wrapper.FluxAggregatorOracleAdminUpdateRequestedIterator, error)); ok {
		return rf(opts, oracle)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address) *flux_aggregator_wrapper.FluxAggregatorOracleAdminUpdateRequestedIterator); ok {
		r0 = rf(opts, oracle)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flux_aggregator_wrapper.FluxAggregatorOracleAdminUpdateRequestedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []common.Address) error); ok {
		r1 = rf(opts, oracle)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterOracleAdminUpdated provides a mock function with given fields: opts, oracle, newAdmin
func (_m *FluxAggregator) FilterOracleAdminUpdated(opts *bind.FilterOpts, oracle []common.Address, newAdmin []common.Address) (*flux_aggregator_wrapper.FluxAggregatorOracleAdminUpdatedIterator, error) {
	ret := _m.Called(opts, oracle, newAdmin)

	if len(ret) == 0 {
		panic("no return value specified for FilterOracleAdminUpdated")
	}

	var r0 *flux_aggregator_wrapper.FluxAggregatorOracleAdminUpdatedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address, []common.Address) (*flux_aggregator_wrapper.FluxAggregatorOracleAdminUpdatedIterator, error)); ok {
		return rf(opts, oracle, newAdmin)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address, []common.Address) *flux_aggregator_wrapper.FluxAggregatorOracleAdminUpdatedIterator); ok {
		r0 = rf(opts, oracle, newAdmin)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flux_aggregator_wrapper.FluxAggregatorOracleAdminUpdatedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, oracle, newAdmin)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterOraclePermissionsUpdated provides a mock function with given fields: opts, oracle, whitelisted
func (_m *FluxAggregator) FilterOraclePermissionsUpdated(opts *bind.FilterOpts, oracle []common.Address, whitelisted []bool) (*flux_aggregator_wrapper.FluxAggregatorOraclePermissionsUpdatedIterator, error) {
	ret := _m.Called(opts, oracle, whitelisted)

	if len(ret) == 0 {
		panic("no return value specified for FilterOraclePermissionsUpdated")
	}

	var r0 *flux_aggregator_wrapper.FluxAggregatorOraclePermissionsUpdatedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address, []bool) (*flux_aggregator_wrapper.FluxAggregatorOraclePermissionsUpdatedIterator, error)); ok {
		return rf(opts, oracle, whitelisted)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address, []bool) *flux_aggregator_wrapper.FluxAggregatorOraclePermissionsUpdatedIterator); ok {
		r0 = rf(opts, oracle, whitelisted)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flux_aggregator_wrapper.FluxAggregatorOraclePermissionsUpdatedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []common.Address, []bool) error); ok {
		r1 = rf(opts, oracle, whitelisted)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterOwnershipTransferRequested provides a mock function with given fields: opts, from, to
func (_m *FluxAggregator) FilterOwnershipTransferRequested(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*flux_aggregator_wrapper.FluxAggregatorOwnershipTransferRequestedIterator, error) {
	ret := _m.Called(opts, from, to)

	if len(ret) == 0 {
		panic("no return value specified for FilterOwnershipTransferRequested")
	}

	var r0 *flux_aggregator_wrapper.FluxAggregatorOwnershipTransferRequestedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address, []common.Address) (*flux_aggregator_wrapper.FluxAggregatorOwnershipTransferRequestedIterator, error)); ok {
		return rf(opts, from, to)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address, []common.Address) *flux_aggregator_wrapper.FluxAggregatorOwnershipTransferRequestedIterator); ok {
		r0 = rf(opts, from, to)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flux_aggregator_wrapper.FluxAggregatorOwnershipTransferRequestedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, from, to)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterOwnershipTransferred provides a mock function with given fields: opts, from, to
func (_m *FluxAggregator) FilterOwnershipTransferred(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*flux_aggregator_wrapper.FluxAggregatorOwnershipTransferredIterator, error) {
	ret := _m.Called(opts, from, to)

	if len(ret) == 0 {
		panic("no return value specified for FilterOwnershipTransferred")
	}

	var r0 *flux_aggregator_wrapper.FluxAggregatorOwnershipTransferredIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address, []common.Address) (*flux_aggregator_wrapper.FluxAggregatorOwnershipTransferredIterator, error)); ok {
		return rf(opts, from, to)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address, []common.Address) *flux_aggregator_wrapper.FluxAggregatorOwnershipTransferredIterator); ok {
		r0 = rf(opts, from, to)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flux_aggregator_wrapper.FluxAggregatorOwnershipTransferredIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, from, to)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterRequesterPermissionsSet provides a mock function with given fields: opts, requester
func (_m *FluxAggregator) FilterRequesterPermissionsSet(opts *bind.FilterOpts, requester []common.Address) (*flux_aggregator_wrapper.FluxAggregatorRequesterPermissionsSetIterator, error) {
	ret := _m.Called(opts, requester)

	if len(ret) == 0 {
		panic("no return value specified for FilterRequesterPermissionsSet")
	}

	var r0 *flux_aggregator_wrapper.FluxAggregatorRequesterPermissionsSetIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address) (*flux_aggregator_wrapper.FluxAggregatorRequesterPermissionsSetIterator, error)); ok {
		return rf(opts, requester)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address) *flux_aggregator_wrapper.FluxAggregatorRequesterPermissionsSetIterator); ok {
		r0 = rf(opts, requester)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flux_aggregator_wrapper.FluxAggregatorRequesterPermissionsSetIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []common.Address) error); ok {
		r1 = rf(opts, requester)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterRoundDetailsUpdated provides a mock function with given fields: opts, paymentAmount, minSubmissionCount, maxSubmissionCount
func (_m *FluxAggregator) FilterRoundDetailsUpdated(opts *bind.FilterOpts, paymentAmount []*big.Int, minSubmissionCount []uint32, maxSubmissionCount []uint32) (*flux_aggregator_wrapper.FluxAggregatorRoundDetailsUpdatedIterator, error) {
	ret := _m.Called(opts, paymentAmount, minSubmissionCount, maxSubmissionCount)

	if len(ret) == 0 {
		panic("no return value specified for FilterRoundDetailsUpdated")
	}

	var r0 *flux_aggregator_wrapper.FluxAggregatorRoundDetailsUpdatedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []*big.Int, []uint32, []uint32) (*flux_aggregator_wrapper.FluxAggregatorRoundDetailsUpdatedIterator, error)); ok {
		return rf(opts, paymentAmount, minSubmissionCount, maxSubmissionCount)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []*big.Int, []uint32, []uint32) *flux_aggregator_wrapper.FluxAggregatorRoundDetailsUpdatedIterator); ok {
		r0 = rf(opts, paymentAmount, minSubmissionCount, maxSubmissionCount)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flux_aggregator_wrapper.FluxAggregatorRoundDetailsUpdatedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []*big.Int, []uint32, []uint32) error); ok {
		r1 = rf(opts, paymentAmount, minSubmissionCount, maxSubmissionCount)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterSubmissionReceived provides a mock function with given fields: opts, submission, round, oracle
func (_m *FluxAggregator) FilterSubmissionReceived(opts *bind.FilterOpts, submission []*big.Int, round []uint32, oracle []common.Address) (*flux_aggregator_wrapper.FluxAggregatorSubmissionReceivedIterator, error) {
	ret := _m.Called(opts, submission, round, oracle)

	if len(ret) == 0 {
		panic("no return value specified for FilterSubmissionReceived")
	}

	var r0 *flux_aggregator_wrapper.FluxAggregatorSubmissionReceivedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []*big.Int, []uint32, []common.Address) (*flux_aggregator_wrapper.FluxAggregatorSubmissionReceivedIterator, error)); ok {
		return rf(opts, submission, round, oracle)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []*big.Int, []uint32, []common.Address) *flux_aggregator_wrapper.FluxAggregatorSubmissionReceivedIterator); ok {
		r0 = rf(opts, submission, round, oracle)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flux_aggregator_wrapper.FluxAggregatorSubmissionReceivedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []*big.Int, []uint32, []common.Address) error); ok {
		r1 = rf(opts, submission, round, oracle)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterValidatorUpdated provides a mock function with given fields: opts, previous, current
func (_m *FluxAggregator) FilterValidatorUpdated(opts *bind.FilterOpts, previous []common.Address, current []common.Address) (*flux_aggregator_wrapper.FluxAggregatorValidatorUpdatedIterator, error) {
	ret := _m.Called(opts, previous, current)

	if len(ret) == 0 {
		panic("no return value specified for FilterValidatorUpdated")
	}

	var r0 *flux_aggregator_wrapper.FluxAggregatorValidatorUpdatedIterator
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address, []common.Address) (*flux_aggregator_wrapper.FluxAggregatorValidatorUpdatedIterator, error)); ok {
		return rf(opts, previous, current)
	}
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address, []common.Address) *flux_aggregator_wrapper.FluxAggregatorValidatorUpdatedIterator); ok {
		r0 = rf(opts, previous, current)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flux_aggregator_wrapper.FluxAggregatorValidatorUpdatedIterator)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, previous, current)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAdmin provides a mock function with given fields: opts, _oracle
func (_m *FluxAggregator) GetAdmin(opts *bind.CallOpts, _oracle common.Address) (common.Address, error) {
	ret := _m.Called(opts, _oracle)

	if len(ret) == 0 {
		panic("no return value specified for GetAdmin")
	}

	var r0 common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, common.Address) (common.Address, error)); ok {
		return rf(opts, _oracle)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, common.Address) common.Address); ok {
		r0 = rf(opts, _oracle)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, common.Address) error); ok {
		r1 = rf(opts, _oracle)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAnswer provides a mock function with given fields: opts, _roundId
func (_m *FluxAggregator) GetAnswer(opts *bind.CallOpts, _roundId *big.Int) (*big.Int, error) {
	ret := _m.Called(opts, _roundId)

	if len(ret) == 0 {
		panic("no return value specified for GetAnswer")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, *big.Int) (*big.Int, error)); ok {
		return rf(opts, _roundId)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, *big.Int) *big.Int); ok {
		r0 = rf(opts, _roundId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, *big.Int) error); ok {
		r1 = rf(opts, _roundId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetOracles provides a mock function with given fields: opts
func (_m *FluxAggregator) GetOracles(opts *bind.CallOpts) ([]common.Address, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for GetOracles")
	}

	var r0 []common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) ([]common.Address, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) []common.Address); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRoundData provides a mock function with given fields: opts, _roundId
func (_m *FluxAggregator) GetRoundData(opts *bind.CallOpts, _roundId *big.Int) (flux_aggregator_wrapper.GetRoundData, error) {
	ret := _m.Called(opts, _roundId)

	if len(ret) == 0 {
		panic("no return value specified for GetRoundData")
	}

	var r0 flux_aggregator_wrapper.GetRoundData
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, *big.Int) (flux_aggregator_wrapper.GetRoundData, error)); ok {
		return rf(opts, _roundId)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, *big.Int) flux_aggregator_wrapper.GetRoundData); ok {
		r0 = rf(opts, _roundId)
	} else {
		r0 = ret.Get(0).(flux_aggregator_wrapper.GetRoundData)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, *big.Int) error); ok {
		r1 = rf(opts, _roundId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTimestamp provides a mock function with given fields: opts, _roundId
func (_m *FluxAggregator) GetTimestamp(opts *bind.CallOpts, _roundId *big.Int) (*big.Int, error) {
	ret := _m.Called(opts, _roundId)

	if len(ret) == 0 {
		panic("no return value specified for GetTimestamp")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, *big.Int) (*big.Int, error)); ok {
		return rf(opts, _roundId)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, *big.Int) *big.Int); ok {
		r0 = rf(opts, _roundId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, *big.Int) error); ok {
		r1 = rf(opts, _roundId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LatestAnswer provides a mock function with given fields: opts
func (_m *FluxAggregator) LatestAnswer(opts *bind.CallOpts) (*big.Int, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for LatestAnswer")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (*big.Int, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) *big.Int); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LatestRound provides a mock function with given fields: opts
func (_m *FluxAggregator) LatestRound(opts *bind.CallOpts) (*big.Int, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for LatestRound")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (*big.Int, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) *big.Int); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LatestRoundData provides a mock function with given fields: opts
func (_m *FluxAggregator) LatestRoundData(opts *bind.CallOpts) (flux_aggregator_wrapper.LatestRoundData, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for LatestRoundData")
	}

	var r0 flux_aggregator_wrapper.LatestRoundData
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (flux_aggregator_wrapper.LatestRoundData, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) flux_aggregator_wrapper.LatestRoundData); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(flux_aggregator_wrapper.LatestRoundData)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LatestTimestamp provides a mock function with given fields: opts
func (_m *FluxAggregator) LatestTimestamp(opts *bind.CallOpts) (*big.Int, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for LatestTimestamp")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (*big.Int, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) *big.Int); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LinkToken provides a mock function with given fields: opts
func (_m *FluxAggregator) LinkToken(opts *bind.CallOpts) (common.Address, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for LinkToken")
	}

	var r0 common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (common.Address, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) common.Address); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MaxSubmissionCount provides a mock function with given fields: opts
func (_m *FluxAggregator) MaxSubmissionCount(opts *bind.CallOpts) (uint32, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for MaxSubmissionCount")
	}

	var r0 uint32
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (uint32, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) uint32); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(uint32)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MaxSubmissionValue provides a mock function with given fields: opts
func (_m *FluxAggregator) MaxSubmissionValue(opts *bind.CallOpts) (*big.Int, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for MaxSubmissionValue")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (*big.Int, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) *big.Int); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MinSubmissionCount provides a mock function with given fields: opts
func (_m *FluxAggregator) MinSubmissionCount(opts *bind.CallOpts) (uint32, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for MinSubmissionCount")
	}

	var r0 uint32
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (uint32, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) uint32); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(uint32)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MinSubmissionValue provides a mock function with given fields: opts
func (_m *FluxAggregator) MinSubmissionValue(opts *bind.CallOpts) (*big.Int, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for MinSubmissionValue")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (*big.Int, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) *big.Int); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OnTokenTransfer provides a mock function with given fields: opts, arg0, arg1, _data
func (_m *FluxAggregator) OnTokenTransfer(opts *bind.TransactOpts, arg0 common.Address, arg1 *big.Int, _data []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, arg0, arg1, _data)

	if len(ret) == 0 {
		panic("no return value specified for OnTokenTransfer")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address, *big.Int, []byte) (*types.Transaction, error)); ok {
		return rf(opts, arg0, arg1, _data)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address, *big.Int, []byte) *types.Transaction); ok {
		r0 = rf(opts, arg0, arg1, _data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, common.Address, *big.Int, []byte) error); ok {
		r1 = rf(opts, arg0, arg1, _data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OracleCount provides a mock function with given fields: opts
func (_m *FluxAggregator) OracleCount(opts *bind.CallOpts) (uint8, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for OracleCount")
	}

	var r0 uint8
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (uint8, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) uint8); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(uint8)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OracleRoundState provides a mock function with given fields: opts, _oracle, _queriedRoundId
func (_m *FluxAggregator) OracleRoundState(opts *bind.CallOpts, _oracle common.Address, _queriedRoundId uint32) (flux_aggregator_wrapper.OracleRoundState, error) {
	ret := _m.Called(opts, _oracle, _queriedRoundId)

	if len(ret) == 0 {
		panic("no return value specified for OracleRoundState")
	}

	var r0 flux_aggregator_wrapper.OracleRoundState
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, common.Address, uint32) (flux_aggregator_wrapper.OracleRoundState, error)); ok {
		return rf(opts, _oracle, _queriedRoundId)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, common.Address, uint32) flux_aggregator_wrapper.OracleRoundState); ok {
		r0 = rf(opts, _oracle, _queriedRoundId)
	} else {
		r0 = ret.Get(0).(flux_aggregator_wrapper.OracleRoundState)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, common.Address, uint32) error); ok {
		r1 = rf(opts, _oracle, _queriedRoundId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Owner provides a mock function with given fields: opts
func (_m *FluxAggregator) Owner(opts *bind.CallOpts) (common.Address, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for Owner")
	}

	var r0 common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (common.Address, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) common.Address); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseAnswerUpdated provides a mock function with given fields: log
func (_m *FluxAggregator) ParseAnswerUpdated(log types.Log) (*flux_aggregator_wrapper.FluxAggregatorAnswerUpdated, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseAnswerUpdated")
	}

	var r0 *flux_aggregator_wrapper.FluxAggregatorAnswerUpdated
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*flux_aggregator_wrapper.FluxAggregatorAnswerUpdated, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *flux_aggregator_wrapper.FluxAggregatorAnswerUpdated); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flux_aggregator_wrapper.FluxAggregatorAnswerUpdated)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseAvailableFundsUpdated provides a mock function with given fields: log
func (_m *FluxAggregator) ParseAvailableFundsUpdated(log types.Log) (*flux_aggregator_wrapper.FluxAggregatorAvailableFundsUpdated, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseAvailableFundsUpdated")
	}

	var r0 *flux_aggregator_wrapper.FluxAggregatorAvailableFundsUpdated
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*flux_aggregator_wrapper.FluxAggregatorAvailableFundsUpdated, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *flux_aggregator_wrapper.FluxAggregatorAvailableFundsUpdated); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flux_aggregator_wrapper.FluxAggregatorAvailableFundsUpdated)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseLog provides a mock function with given fields: log
func (_m *FluxAggregator) ParseLog(log types.Log) (generated.AbigenLog, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseLog")
	}

	var r0 generated.AbigenLog
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (generated.AbigenLog, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) generated.AbigenLog); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(generated.AbigenLog)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseNewRound provides a mock function with given fields: log
func (_m *FluxAggregator) ParseNewRound(log types.Log) (*flux_aggregator_wrapper.FluxAggregatorNewRound, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseNewRound")
	}

	var r0 *flux_aggregator_wrapper.FluxAggregatorNewRound
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*flux_aggregator_wrapper.FluxAggregatorNewRound, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *flux_aggregator_wrapper.FluxAggregatorNewRound); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flux_aggregator_wrapper.FluxAggregatorNewRound)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseOracleAdminUpdateRequested provides a mock function with given fields: log
func (_m *FluxAggregator) ParseOracleAdminUpdateRequested(log types.Log) (*flux_aggregator_wrapper.FluxAggregatorOracleAdminUpdateRequested, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseOracleAdminUpdateRequested")
	}

	var r0 *flux_aggregator_wrapper.FluxAggregatorOracleAdminUpdateRequested
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*flux_aggregator_wrapper.FluxAggregatorOracleAdminUpdateRequested, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *flux_aggregator_wrapper.FluxAggregatorOracleAdminUpdateRequested); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flux_aggregator_wrapper.FluxAggregatorOracleAdminUpdateRequested)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseOracleAdminUpdated provides a mock function with given fields: log
func (_m *FluxAggregator) ParseOracleAdminUpdated(log types.Log) (*flux_aggregator_wrapper.FluxAggregatorOracleAdminUpdated, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseOracleAdminUpdated")
	}

	var r0 *flux_aggregator_wrapper.FluxAggregatorOracleAdminUpdated
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*flux_aggregator_wrapper.FluxAggregatorOracleAdminUpdated, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *flux_aggregator_wrapper.FluxAggregatorOracleAdminUpdated); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flux_aggregator_wrapper.FluxAggregatorOracleAdminUpdated)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseOraclePermissionsUpdated provides a mock function with given fields: log
func (_m *FluxAggregator) ParseOraclePermissionsUpdated(log types.Log) (*flux_aggregator_wrapper.FluxAggregatorOraclePermissionsUpdated, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseOraclePermissionsUpdated")
	}

	var r0 *flux_aggregator_wrapper.FluxAggregatorOraclePermissionsUpdated
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*flux_aggregator_wrapper.FluxAggregatorOraclePermissionsUpdated, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *flux_aggregator_wrapper.FluxAggregatorOraclePermissionsUpdated); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flux_aggregator_wrapper.FluxAggregatorOraclePermissionsUpdated)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseOwnershipTransferRequested provides a mock function with given fields: log
func (_m *FluxAggregator) ParseOwnershipTransferRequested(log types.Log) (*flux_aggregator_wrapper.FluxAggregatorOwnershipTransferRequested, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseOwnershipTransferRequested")
	}

	var r0 *flux_aggregator_wrapper.FluxAggregatorOwnershipTransferRequested
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*flux_aggregator_wrapper.FluxAggregatorOwnershipTransferRequested, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *flux_aggregator_wrapper.FluxAggregatorOwnershipTransferRequested); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flux_aggregator_wrapper.FluxAggregatorOwnershipTransferRequested)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseOwnershipTransferred provides a mock function with given fields: log
func (_m *FluxAggregator) ParseOwnershipTransferred(log types.Log) (*flux_aggregator_wrapper.FluxAggregatorOwnershipTransferred, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseOwnershipTransferred")
	}

	var r0 *flux_aggregator_wrapper.FluxAggregatorOwnershipTransferred
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*flux_aggregator_wrapper.FluxAggregatorOwnershipTransferred, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *flux_aggregator_wrapper.FluxAggregatorOwnershipTransferred); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flux_aggregator_wrapper.FluxAggregatorOwnershipTransferred)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseRequesterPermissionsSet provides a mock function with given fields: log
func (_m *FluxAggregator) ParseRequesterPermissionsSet(log types.Log) (*flux_aggregator_wrapper.FluxAggregatorRequesterPermissionsSet, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseRequesterPermissionsSet")
	}

	var r0 *flux_aggregator_wrapper.FluxAggregatorRequesterPermissionsSet
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*flux_aggregator_wrapper.FluxAggregatorRequesterPermissionsSet, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *flux_aggregator_wrapper.FluxAggregatorRequesterPermissionsSet); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flux_aggregator_wrapper.FluxAggregatorRequesterPermissionsSet)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseRoundDetailsUpdated provides a mock function with given fields: log
func (_m *FluxAggregator) ParseRoundDetailsUpdated(log types.Log) (*flux_aggregator_wrapper.FluxAggregatorRoundDetailsUpdated, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseRoundDetailsUpdated")
	}

	var r0 *flux_aggregator_wrapper.FluxAggregatorRoundDetailsUpdated
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*flux_aggregator_wrapper.FluxAggregatorRoundDetailsUpdated, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *flux_aggregator_wrapper.FluxAggregatorRoundDetailsUpdated); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flux_aggregator_wrapper.FluxAggregatorRoundDetailsUpdated)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseSubmissionReceived provides a mock function with given fields: log
func (_m *FluxAggregator) ParseSubmissionReceived(log types.Log) (*flux_aggregator_wrapper.FluxAggregatorSubmissionReceived, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseSubmissionReceived")
	}

	var r0 *flux_aggregator_wrapper.FluxAggregatorSubmissionReceived
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*flux_aggregator_wrapper.FluxAggregatorSubmissionReceived, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *flux_aggregator_wrapper.FluxAggregatorSubmissionReceived); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flux_aggregator_wrapper.FluxAggregatorSubmissionReceived)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseValidatorUpdated provides a mock function with given fields: log
func (_m *FluxAggregator) ParseValidatorUpdated(log types.Log) (*flux_aggregator_wrapper.FluxAggregatorValidatorUpdated, error) {
	ret := _m.Called(log)

	if len(ret) == 0 {
		panic("no return value specified for ParseValidatorUpdated")
	}

	var r0 *flux_aggregator_wrapper.FluxAggregatorValidatorUpdated
	var r1 error
	if rf, ok := ret.Get(0).(func(types.Log) (*flux_aggregator_wrapper.FluxAggregatorValidatorUpdated, error)); ok {
		return rf(log)
	}
	if rf, ok := ret.Get(0).(func(types.Log) *flux_aggregator_wrapper.FluxAggregatorValidatorUpdated); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*flux_aggregator_wrapper.FluxAggregatorValidatorUpdated)
		}
	}

	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaymentAmount provides a mock function with given fields: opts
func (_m *FluxAggregator) PaymentAmount(opts *bind.CallOpts) (*big.Int, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for PaymentAmount")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (*big.Int, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) *big.Int); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RequestNewRound provides a mock function with given fields: opts
func (_m *FluxAggregator) RequestNewRound(opts *bind.TransactOpts) (*types.Transaction, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for RequestNewRound")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts) (*types.Transaction, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts) *types.Transaction); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RestartDelay provides a mock function with given fields: opts
func (_m *FluxAggregator) RestartDelay(opts *bind.CallOpts) (uint32, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for RestartDelay")
	}

	var r0 uint32
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (uint32, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) uint32); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(uint32)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetRequesterPermissions provides a mock function with given fields: opts, _requester, _authorized, _delay
func (_m *FluxAggregator) SetRequesterPermissions(opts *bind.TransactOpts, _requester common.Address, _authorized bool, _delay uint32) (*types.Transaction, error) {
	ret := _m.Called(opts, _requester, _authorized, _delay)

	if len(ret) == 0 {
		panic("no return value specified for SetRequesterPermissions")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address, bool, uint32) (*types.Transaction, error)); ok {
		return rf(opts, _requester, _authorized, _delay)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address, bool, uint32) *types.Transaction); ok {
		r0 = rf(opts, _requester, _authorized, _delay)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, common.Address, bool, uint32) error); ok {
		r1 = rf(opts, _requester, _authorized, _delay)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetValidator provides a mock function with given fields: opts, _newValidator
func (_m *FluxAggregator) SetValidator(opts *bind.TransactOpts, _newValidator common.Address) (*types.Transaction, error) {
	ret := _m.Called(opts, _newValidator)

	if len(ret) == 0 {
		panic("no return value specified for SetValidator")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address) (*types.Transaction, error)); ok {
		return rf(opts, _newValidator)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address) *types.Transaction); ok {
		r0 = rf(opts, _newValidator)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, common.Address) error); ok {
		r1 = rf(opts, _newValidator)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Submit provides a mock function with given fields: opts, _roundId, _submission
func (_m *FluxAggregator) Submit(opts *bind.TransactOpts, _roundId *big.Int, _submission *big.Int) (*types.Transaction, error) {
	ret := _m.Called(opts, _roundId, _submission)

	if len(ret) == 0 {
		panic("no return value specified for Submit")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, *big.Int, *big.Int) (*types.Transaction, error)); ok {
		return rf(opts, _roundId, _submission)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, *big.Int, *big.Int) *types.Transaction); ok {
		r0 = rf(opts, _roundId, _submission)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, *big.Int, *big.Int) error); ok {
		r1 = rf(opts, _roundId, _submission)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Timeout provides a mock function with given fields: opts
func (_m *FluxAggregator) Timeout(opts *bind.CallOpts) (uint32, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for Timeout")
	}

	var r0 uint32
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (uint32, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) uint32); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(uint32)
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TransferAdmin provides a mock function with given fields: opts, _oracle, _newAdmin
func (_m *FluxAggregator) TransferAdmin(opts *bind.TransactOpts, _oracle common.Address, _newAdmin common.Address) (*types.Transaction, error) {
	ret := _m.Called(opts, _oracle, _newAdmin)

	if len(ret) == 0 {
		panic("no return value specified for TransferAdmin")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address, common.Address) (*types.Transaction, error)); ok {
		return rf(opts, _oracle, _newAdmin)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address, common.Address) *types.Transaction); ok {
		r0 = rf(opts, _oracle, _newAdmin)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, common.Address, common.Address) error); ok {
		r1 = rf(opts, _oracle, _newAdmin)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TransferOwnership provides a mock function with given fields: opts, _to
func (_m *FluxAggregator) TransferOwnership(opts *bind.TransactOpts, _to common.Address) (*types.Transaction, error) {
	ret := _m.Called(opts, _to)

	if len(ret) == 0 {
		panic("no return value specified for TransferOwnership")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address) (*types.Transaction, error)); ok {
		return rf(opts, _to)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address) *types.Transaction); ok {
		r0 = rf(opts, _to)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, common.Address) error); ok {
		r1 = rf(opts, _to)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAvailableFunds provides a mock function with given fields: opts
func (_m *FluxAggregator) UpdateAvailableFunds(opts *bind.TransactOpts) (*types.Transaction, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAvailableFunds")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts) (*types.Transaction, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts) *types.Transaction); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateFutureRounds provides a mock function with given fields: opts, _paymentAmount, _minSubmissions, _maxSubmissions, _restartDelay, _timeout
func (_m *FluxAggregator) UpdateFutureRounds(opts *bind.TransactOpts, _paymentAmount *big.Int, _minSubmissions uint32, _maxSubmissions uint32, _restartDelay uint32, _timeout uint32) (*types.Transaction, error) {
	ret := _m.Called(opts, _paymentAmount, _minSubmissions, _maxSubmissions, _restartDelay, _timeout)

	if len(ret) == 0 {
		panic("no return value specified for UpdateFutureRounds")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, *big.Int, uint32, uint32, uint32, uint32) (*types.Transaction, error)); ok {
		return rf(opts, _paymentAmount, _minSubmissions, _maxSubmissions, _restartDelay, _timeout)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, *big.Int, uint32, uint32, uint32, uint32) *types.Transaction); ok {
		r0 = rf(opts, _paymentAmount, _minSubmissions, _maxSubmissions, _restartDelay, _timeout)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, *big.Int, uint32, uint32, uint32, uint32) error); ok {
		r1 = rf(opts, _paymentAmount, _minSubmissions, _maxSubmissions, _restartDelay, _timeout)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Validator provides a mock function with given fields: opts
func (_m *FluxAggregator) Validator(opts *bind.CallOpts) (common.Address, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for Validator")
	}

	var r0 common.Address
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (common.Address, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) common.Address); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Version provides a mock function with given fields: opts
func (_m *FluxAggregator) Version(opts *bind.CallOpts) (*big.Int, error) {
	ret := _m.Called(opts)

	if len(ret) == 0 {
		panic("no return value specified for Version")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) (*big.Int, error)); ok {
		return rf(opts)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) *big.Int); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchAnswerUpdated provides a mock function with given fields: opts, sink, current, roundId
func (_m *FluxAggregator) WatchAnswerUpdated(opts *bind.WatchOpts, sink chan<- *flux_aggregator_wrapper.FluxAggregatorAnswerUpdated, current []*big.Int, roundId []*big.Int) (event.Subscription, error) {
	ret := _m.Called(opts, sink, current, roundId)

	if len(ret) == 0 {
		panic("no return value specified for WatchAnswerUpdated")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *flux_aggregator_wrapper.FluxAggregatorAnswerUpdated, []*big.Int, []*big.Int) (event.Subscription, error)); ok {
		return rf(opts, sink, current, roundId)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *flux_aggregator_wrapper.FluxAggregatorAnswerUpdated, []*big.Int, []*big.Int) event.Subscription); ok {
		r0 = rf(opts, sink, current, roundId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *flux_aggregator_wrapper.FluxAggregatorAnswerUpdated, []*big.Int, []*big.Int) error); ok {
		r1 = rf(opts, sink, current, roundId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchAvailableFundsUpdated provides a mock function with given fields: opts, sink, amount
func (_m *FluxAggregator) WatchAvailableFundsUpdated(opts *bind.WatchOpts, sink chan<- *flux_aggregator_wrapper.FluxAggregatorAvailableFundsUpdated, amount []*big.Int) (event.Subscription, error) {
	ret := _m.Called(opts, sink, amount)

	if len(ret) == 0 {
		panic("no return value specified for WatchAvailableFundsUpdated")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *flux_aggregator_wrapper.FluxAggregatorAvailableFundsUpdated, []*big.Int) (event.Subscription, error)); ok {
		return rf(opts, sink, amount)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *flux_aggregator_wrapper.FluxAggregatorAvailableFundsUpdated, []*big.Int) event.Subscription); ok {
		r0 = rf(opts, sink, amount)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *flux_aggregator_wrapper.FluxAggregatorAvailableFundsUpdated, []*big.Int) error); ok {
		r1 = rf(opts, sink, amount)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchNewRound provides a mock function with given fields: opts, sink, roundId, startedBy
func (_m *FluxAggregator) WatchNewRound(opts *bind.WatchOpts, sink chan<- *flux_aggregator_wrapper.FluxAggregatorNewRound, roundId []*big.Int, startedBy []common.Address) (event.Subscription, error) {
	ret := _m.Called(opts, sink, roundId, startedBy)

	if len(ret) == 0 {
		panic("no return value specified for WatchNewRound")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *flux_aggregator_wrapper.FluxAggregatorNewRound, []*big.Int, []common.Address) (event.Subscription, error)); ok {
		return rf(opts, sink, roundId, startedBy)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *flux_aggregator_wrapper.FluxAggregatorNewRound, []*big.Int, []common.Address) event.Subscription); ok {
		r0 = rf(opts, sink, roundId, startedBy)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *flux_aggregator_wrapper.FluxAggregatorNewRound, []*big.Int, []common.Address) error); ok {
		r1 = rf(opts, sink, roundId, startedBy)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchOracleAdminUpdateRequested provides a mock function with given fields: opts, sink, oracle
func (_m *FluxAggregator) WatchOracleAdminUpdateRequested(opts *bind.WatchOpts, sink chan<- *flux_aggregator_wrapper.FluxAggregatorOracleAdminUpdateRequested, oracle []common.Address) (event.Subscription, error) {
	ret := _m.Called(opts, sink, oracle)

	if len(ret) == 0 {
		panic("no return value specified for WatchOracleAdminUpdateRequested")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *flux_aggregator_wrapper.FluxAggregatorOracleAdminUpdateRequested, []common.Address) (event.Subscription, error)); ok {
		return rf(opts, sink, oracle)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *flux_aggregator_wrapper.FluxAggregatorOracleAdminUpdateRequested, []common.Address) event.Subscription); ok {
		r0 = rf(opts, sink, oracle)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *flux_aggregator_wrapper.FluxAggregatorOracleAdminUpdateRequested, []common.Address) error); ok {
		r1 = rf(opts, sink, oracle)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchOracleAdminUpdated provides a mock function with given fields: opts, sink, oracle, newAdmin
func (_m *FluxAggregator) WatchOracleAdminUpdated(opts *bind.WatchOpts, sink chan<- *flux_aggregator_wrapper.FluxAggregatorOracleAdminUpdated, oracle []common.Address, newAdmin []common.Address) (event.Subscription, error) {
	ret := _m.Called(opts, sink, oracle, newAdmin)

	if len(ret) == 0 {
		panic("no return value specified for WatchOracleAdminUpdated")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *flux_aggregator_wrapper.FluxAggregatorOracleAdminUpdated, []common.Address, []common.Address) (event.Subscription, error)); ok {
		return rf(opts, sink, oracle, newAdmin)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *flux_aggregator_wrapper.FluxAggregatorOracleAdminUpdated, []common.Address, []common.Address) event.Subscription); ok {
		r0 = rf(opts, sink, oracle, newAdmin)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *flux_aggregator_wrapper.FluxAggregatorOracleAdminUpdated, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, sink, oracle, newAdmin)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchOraclePermissionsUpdated provides a mock function with given fields: opts, sink, oracle, whitelisted
func (_m *FluxAggregator) WatchOraclePermissionsUpdated(opts *bind.WatchOpts, sink chan<- *flux_aggregator_wrapper.FluxAggregatorOraclePermissionsUpdated, oracle []common.Address, whitelisted []bool) (event.Subscription, error) {
	ret := _m.Called(opts, sink, oracle, whitelisted)

	if len(ret) == 0 {
		panic("no return value specified for WatchOraclePermissionsUpdated")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *flux_aggregator_wrapper.FluxAggregatorOraclePermissionsUpdated, []common.Address, []bool) (event.Subscription, error)); ok {
		return rf(opts, sink, oracle, whitelisted)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *flux_aggregator_wrapper.FluxAggregatorOraclePermissionsUpdated, []common.Address, []bool) event.Subscription); ok {
		r0 = rf(opts, sink, oracle, whitelisted)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *flux_aggregator_wrapper.FluxAggregatorOraclePermissionsUpdated, []common.Address, []bool) error); ok {
		r1 = rf(opts, sink, oracle, whitelisted)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchOwnershipTransferRequested provides a mock function with given fields: opts, sink, from, to
func (_m *FluxAggregator) WatchOwnershipTransferRequested(opts *bind.WatchOpts, sink chan<- *flux_aggregator_wrapper.FluxAggregatorOwnershipTransferRequested, from []common.Address, to []common.Address) (event.Subscription, error) {
	ret := _m.Called(opts, sink, from, to)

	if len(ret) == 0 {
		panic("no return value specified for WatchOwnershipTransferRequested")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *flux_aggregator_wrapper.FluxAggregatorOwnershipTransferRequested, []common.Address, []common.Address) (event.Subscription, error)); ok {
		return rf(opts, sink, from, to)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *flux_aggregator_wrapper.FluxAggregatorOwnershipTransferRequested, []common.Address, []common.Address) event.Subscription); ok {
		r0 = rf(opts, sink, from, to)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *flux_aggregator_wrapper.FluxAggregatorOwnershipTransferRequested, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, sink, from, to)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchOwnershipTransferred provides a mock function with given fields: opts, sink, from, to
func (_m *FluxAggregator) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *flux_aggregator_wrapper.FluxAggregatorOwnershipTransferred, from []common.Address, to []common.Address) (event.Subscription, error) {
	ret := _m.Called(opts, sink, from, to)

	if len(ret) == 0 {
		panic("no return value specified for WatchOwnershipTransferred")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *flux_aggregator_wrapper.FluxAggregatorOwnershipTransferred, []common.Address, []common.Address) (event.Subscription, error)); ok {
		return rf(opts, sink, from, to)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *flux_aggregator_wrapper.FluxAggregatorOwnershipTransferred, []common.Address, []common.Address) event.Subscription); ok {
		r0 = rf(opts, sink, from, to)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *flux_aggregator_wrapper.FluxAggregatorOwnershipTransferred, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, sink, from, to)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchRequesterPermissionsSet provides a mock function with given fields: opts, sink, requester
func (_m *FluxAggregator) WatchRequesterPermissionsSet(opts *bind.WatchOpts, sink chan<- *flux_aggregator_wrapper.FluxAggregatorRequesterPermissionsSet, requester []common.Address) (event.Subscription, error) {
	ret := _m.Called(opts, sink, requester)

	if len(ret) == 0 {
		panic("no return value specified for WatchRequesterPermissionsSet")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *flux_aggregator_wrapper.FluxAggregatorRequesterPermissionsSet, []common.Address) (event.Subscription, error)); ok {
		return rf(opts, sink, requester)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *flux_aggregator_wrapper.FluxAggregatorRequesterPermissionsSet, []common.Address) event.Subscription); ok {
		r0 = rf(opts, sink, requester)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *flux_aggregator_wrapper.FluxAggregatorRequesterPermissionsSet, []common.Address) error); ok {
		r1 = rf(opts, sink, requester)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchRoundDetailsUpdated provides a mock function with given fields: opts, sink, paymentAmount, minSubmissionCount, maxSubmissionCount
func (_m *FluxAggregator) WatchRoundDetailsUpdated(opts *bind.WatchOpts, sink chan<- *flux_aggregator_wrapper.FluxAggregatorRoundDetailsUpdated, paymentAmount []*big.Int, minSubmissionCount []uint32, maxSubmissionCount []uint32) (event.Subscription, error) {
	ret := _m.Called(opts, sink, paymentAmount, minSubmissionCount, maxSubmissionCount)

	if len(ret) == 0 {
		panic("no return value specified for WatchRoundDetailsUpdated")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *flux_aggregator_wrapper.FluxAggregatorRoundDetailsUpdated, []*big.Int, []uint32, []uint32) (event.Subscription, error)); ok {
		return rf(opts, sink, paymentAmount, minSubmissionCount, maxSubmissionCount)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *flux_aggregator_wrapper.FluxAggregatorRoundDetailsUpdated, []*big.Int, []uint32, []uint32) event.Subscription); ok {
		r0 = rf(opts, sink, paymentAmount, minSubmissionCount, maxSubmissionCount)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *flux_aggregator_wrapper.FluxAggregatorRoundDetailsUpdated, []*big.Int, []uint32, []uint32) error); ok {
		r1 = rf(opts, sink, paymentAmount, minSubmissionCount, maxSubmissionCount)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchSubmissionReceived provides a mock function with given fields: opts, sink, submission, round, oracle
func (_m *FluxAggregator) WatchSubmissionReceived(opts *bind.WatchOpts, sink chan<- *flux_aggregator_wrapper.FluxAggregatorSubmissionReceived, submission []*big.Int, round []uint32, oracle []common.Address) (event.Subscription, error) {
	ret := _m.Called(opts, sink, submission, round, oracle)

	if len(ret) == 0 {
		panic("no return value specified for WatchSubmissionReceived")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *flux_aggregator_wrapper.FluxAggregatorSubmissionReceived, []*big.Int, []uint32, []common.Address) (event.Subscription, error)); ok {
		return rf(opts, sink, submission, round, oracle)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *flux_aggregator_wrapper.FluxAggregatorSubmissionReceived, []*big.Int, []uint32, []common.Address) event.Subscription); ok {
		r0 = rf(opts, sink, submission, round, oracle)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *flux_aggregator_wrapper.FluxAggregatorSubmissionReceived, []*big.Int, []uint32, []common.Address) error); ok {
		r1 = rf(opts, sink, submission, round, oracle)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchValidatorUpdated provides a mock function with given fields: opts, sink, previous, current
func (_m *FluxAggregator) WatchValidatorUpdated(opts *bind.WatchOpts, sink chan<- *flux_aggregator_wrapper.FluxAggregatorValidatorUpdated, previous []common.Address, current []common.Address) (event.Subscription, error) {
	ret := _m.Called(opts, sink, previous, current)

	if len(ret) == 0 {
		panic("no return value specified for WatchValidatorUpdated")
	}

	var r0 event.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *flux_aggregator_wrapper.FluxAggregatorValidatorUpdated, []common.Address, []common.Address) (event.Subscription, error)); ok {
		return rf(opts, sink, previous, current)
	}
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *flux_aggregator_wrapper.FluxAggregatorValidatorUpdated, []common.Address, []common.Address) event.Subscription); ok {
		r0 = rf(opts, sink, previous, current)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *flux_aggregator_wrapper.FluxAggregatorValidatorUpdated, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, sink, previous, current)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WithdrawFunds provides a mock function with given fields: opts, _recipient, _amount
func (_m *FluxAggregator) WithdrawFunds(opts *bind.TransactOpts, _recipient common.Address, _amount *big.Int) (*types.Transaction, error) {
	ret := _m.Called(opts, _recipient, _amount)

	if len(ret) == 0 {
		panic("no return value specified for WithdrawFunds")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address, *big.Int) (*types.Transaction, error)); ok {
		return rf(opts, _recipient, _amount)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address, *big.Int) *types.Transaction); ok {
		r0 = rf(opts, _recipient, _amount)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, common.Address, *big.Int) error); ok {
		r1 = rf(opts, _recipient, _amount)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WithdrawPayment provides a mock function with given fields: opts, _oracle, _recipient, _amount
func (_m *FluxAggregator) WithdrawPayment(opts *bind.TransactOpts, _oracle common.Address, _recipient common.Address, _amount *big.Int) (*types.Transaction, error) {
	ret := _m.Called(opts, _oracle, _recipient, _amount)

	if len(ret) == 0 {
		panic("no return value specified for WithdrawPayment")
	}

	var r0 *types.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address, common.Address, *big.Int) (*types.Transaction, error)); ok {
		return rf(opts, _oracle, _recipient, _amount)
	}
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address, common.Address, *big.Int) *types.Transaction); ok {
		r0 = rf(opts, _oracle, _recipient, _amount)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, common.Address, common.Address, *big.Int) error); ok {
		r1 = rf(opts, _oracle, _recipient, _amount)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WithdrawablePayment provides a mock function with given fields: opts, _oracle
func (_m *FluxAggregator) WithdrawablePayment(opts *bind.CallOpts, _oracle common.Address) (*big.Int, error) {
	ret := _m.Called(opts, _oracle)

	if len(ret) == 0 {
		panic("no return value specified for WithdrawablePayment")
	}

	var r0 *big.Int
	var r1 error
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, common.Address) (*big.Int, error)); ok {
		return rf(opts, _oracle)
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, common.Address) *big.Int); ok {
		r0 = rf(opts, _oracle)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	if rf, ok := ret.Get(1).(func(*bind.CallOpts, common.Address) error); ok {
		r1 = rf(opts, _oracle)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewFluxAggregator creates a new instance of FluxAggregator. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewFluxAggregator(t interface {
	mock.TestingT
	Cleanup(func())
}) *FluxAggregator {
	mock := &FluxAggregator{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
