// Code generated by mockery v1.0.0. DO NOT EDIT.

package mocks

import (
	big "math/big"

	abi "github.com/ethereum/go-ethereum/accounts/abi"

	common "github.com/ethereum/go-ethereum/common"

	contracts "chainlink/core/eth/contracts"

	decimal "github.com/shopspring/decimal"

	eth "chainlink/core/eth"

	mock "github.com/stretchr/testify/mock"
)

// FluxAggregator is an autogenerated mock type for the FluxAggregator type
type FluxAggregator struct {
	mock.Mock
}

// ABI provides a mock function with given fields:
func (_m *FluxAggregator) ABI() *abi.ABI {
	ret := _m.Called()

	var r0 *abi.ABI
	if rf, ok := ret.Get(0).(func() *abi.ABI); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*abi.ABI)
		}
	}

	return r0
}

// Call provides a mock function with given fields: result, methodName, args
func (_m *FluxAggregator) Call(result interface{}, methodName string, args ...interface{}) error {
	var _ca []interface{}
	_ca = append(_ca, result, methodName)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, string, ...interface{}) error); ok {
		r0 = rf(result, methodName, args...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// EncodeMessageCall provides a mock function with given fields: method, args
func (_m *FluxAggregator) EncodeMessageCall(method string, args ...interface{}) ([]byte, error) {
	var _ca []interface{}
	_ca = append(_ca, method)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(string, ...interface{}) []byte); ok {
		r0 = rf(method, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, ...interface{}) error); ok {
		r1 = rf(method, args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMethodID provides a mock function with given fields: method
func (_m *FluxAggregator) GetMethodID(method string) ([]byte, error) {
	ret := _m.Called(method)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(string) []byte); ok {
		r0 = rf(method)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(method)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LatestAnswer provides a mock function with given fields: precision
func (_m *FluxAggregator) LatestAnswer(precision int32) (decimal.Decimal, error) {
	ret := _m.Called(precision)

	var r0 decimal.Decimal
	if rf, ok := ret.Get(0).(func(int32) decimal.Decimal); ok {
		r0 = rf(precision)
	} else {
		r0 = ret.Get(0).(decimal.Decimal)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(int32) error); ok {
		r1 = rf(precision)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LatestRound provides a mock function with given fields:
func (_m *FluxAggregator) LatestRound() (*big.Int, error) {
	ret := _m.Called()

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func() *big.Int); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LatestSubmission provides a mock function with given fields: oracleAddress
func (_m *FluxAggregator) LatestSubmission(oracleAddress common.Address) (*big.Int, *big.Int, error) {
	ret := _m.Called(oracleAddress)

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func(common.Address) *big.Int); ok {
		r0 = rf(oracleAddress)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	var r1 *big.Int
	if rf, ok := ret.Get(1).(func(common.Address) *big.Int); ok {
		r1 = rf(oracleAddress)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*big.Int)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(common.Address) error); ok {
		r2 = rf(oracleAddress)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ReportingRound provides a mock function with given fields:
func (_m *FluxAggregator) ReportingRound() (*big.Int, error) {
	ret := _m.Called()

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func() *big.Int); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RoundState provides a mock function with given fields:
func (_m *FluxAggregator) RoundState() (contracts.FluxAggregatorRoundState, error) {
	ret := _m.Called()

	var r0 contracts.FluxAggregatorRoundState
	if rf, ok := ret.Get(0).(func() contracts.FluxAggregatorRoundState); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(contracts.FluxAggregatorRoundState)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubscribeToLogs provides a mock function with given fields: listener
func (_m *FluxAggregator) SubscribeToLogs(listener eth.LogListener) eth.UnsubscribeFunc {
	ret := _m.Called(listener)

	var r0 eth.UnsubscribeFunc
	if rf, ok := ret.Get(0).(func(eth.LogListener) eth.UnsubscribeFunc); ok {
		r0 = rf(listener)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(eth.UnsubscribeFunc)
		}
	}

	return r0
}

// TimedOutStatus provides a mock function with given fields: round
func (_m *FluxAggregator) TimedOutStatus(round *big.Int) (bool, error) {
	ret := _m.Called(round)

	var r0 bool
	if rf, ok := ret.Get(0).(func(*big.Int) bool); ok {
		r0 = rf(round)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*big.Int) error); ok {
		r1 = rf(round)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnpackLog provides a mock function with given fields: out, event, log
func (_m *FluxAggregator) UnpackLog(out interface{}, event string, log eth.Log) error {
	ret := _m.Called(out, event, log)

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, string, eth.Log) error); ok {
		r0 = rf(out, event, log)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
