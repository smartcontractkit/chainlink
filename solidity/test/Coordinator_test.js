import {
  abiEncode,
  assertActionThrows,
  bigNum,
  calculateSAID,
  consumer,
  checkPublicABI,
  checkServiceAgreementPresent,
  checkServiceAgreementAbsent,
  deploy,
  executeServiceAgreementBytes,
  functionSelector,
  getLatestEvent,
  initiateServiceAgreement,
  initiateServiceAgreementCall,
  newAddress,
  newHash,
  oracleNode,
  pad0xHexTo256Bit,
  padNumTo256Bit,
  personalSign,
  recoverPersonalSignature,
  requestDataBytes,
  requestDataFrom,
  runRequestId,
  stranger,
  strip0x,
  toHex,
  toWei
} from './support/helpers'

contract('Coordinator', () => {
  const sourcePath = 'Coordinator.sol'
  let coordinator, link

  beforeEach(async () => {
    link = await deploy('link_token/contracts/LinkToken.sol')
    coordinator = await deploy(sourcePath, link.address)
  })

  it('has a limited public interface', () => {
    checkPublicABI(artifacts.require(sourcePath), [
      'getPackedArguments',
      'getId',
      'executeServiceAgreement',
      'fulfillData',
      'getId',
      'initiateServiceAgreement',
      'onTokenTransfer',
      'serviceAgreements'
    ])
  })

  const agreedPayment = 1
  const agreedExpiration = 2
  const endAt = Math.round(Date.now() / 1000.0) + 6 * 30 * 24 * 60 * 60 // six months from now
  const agreedOracles = [
    '0x70AEc4B9CFFA7b55C0711b82DD719049d615E21d',
    '0xd26114cd6EE289AccF82350c8d8487fedB8A0C07'
  ]
  const requestDigest = '0x85820c5ec619a1f517ee6cfeff545ec0ca1a90206e1a38c47f016d4137e801dd'

  const args = [ agreedPayment, agreedExpiration, endAt, agreedOracles, requestDigest ]
  const expectedBinaryArgs = [
    '0x',
    ...[agreedPayment, agreedExpiration, endAt].map(padNumTo256Bit),
    ...agreedOracles.map(pad0xHexTo256Bit),
    strip0x(requestDigest)
  ].join('').toLowerCase()

  describe('#getPackedArguments', () => {
    it('returns the following value, given these arguments', async () => {
      const result = await coordinator.getPackedArguments.call(...args)

      assert.equal(result, expectedBinaryArgs)
    })
  })

  describe('#getId', () => {
    it('matches the ID generated by the oracle off-chain', async () => {
      const expectedBinaryArgsSha3 = web3.sha3(expectedBinaryArgs, { encoding: 'hex' })
      const result = await coordinator.getId.call(...args)

      assert.equal(result, expectedBinaryArgsSha3)
    })
  })

  describe('#initiateServiceAgreement', () => {
    const oracle = newAddress(oracleNode)
    const unsignedDefaultServiceAgreement = {
      payment: newHash('1000000000000000000'),
      expiration: newHash('300'),
      endAt: newHash(endAt.toString()),
      oracles: [oracle],
      requestDigest: newHash(
        '0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef')
    }
    const serviceAgreementID = calculateSAID(unsignedDefaultServiceAgreement)
    const oracleSignature = personalSign(oracle, serviceAgreementID)
    const requestDigestAddr =
          recoverPersonalSignature(serviceAgreementID, oracleSignature)
    assert.equal(toHex(oracle), toHex(requestDigestAddr))
    const defaultArgs = Object.assign(
      unsignedDefaultServiceAgreement, { oracleSignature })

    context('with valid oracle signatures', () => {
      it('saves a service agreement struct from the parameters', async () => {
        initiateServiceAgreement(coordinator, defaultArgs)
        checkServiceAgreementPresent(coordinator, serviceAgreementID, defaultArgs)
      })

      it('returns the SAID', async () => {
        const said = await initiateServiceAgreementCall(coordinator, defaultArgs)
        assert.equal(said, toHex(serviceAgreementID))
      })

      it('logs an event', async () => {
        await initiateServiceAgreement(coordinator, defaultArgs)
        const event = await getLatestEvent(coordinator)
        assert.equal(toHex(serviceAgreementID), event.args.said)
      })
    })

    context('with an invalid oracle signatures', () => {
      const badOracleSignature =
            personalSign(newAddress(stranger), serviceAgreementID)
      const badRequestDigestAddr =
            recoverPersonalSignature(serviceAgreementID, badOracleSignature)
      assert.notEqual(toHex(oracle), toHex(badRequestDigestAddr))
      it('saves no service agreement struct, if signatures invalid', async () => {
        assertActionThrows(
          async () =>
            initiateServiceAgreement(
              coordinator,
              Object.assign(defaultArgs, { oracleSignature: badOracleSignature })))
        checkServiceAgreementAbsent(coordinator, serviceAgreementID)
      })
    })

    context('Validation of service agreement deadlines', () => {
      it('Rejects a service agreement with an endAt date in the past', async () => {
        assertActionThrows(
          async () => initiateServiceAgreement(
            coordinator,
            Object.assign(defaultArgs, { endAt: newHash('1000') })))
        checkServiceAgreementAbsent(coordinator, serviceAgreementID)
      })
    })
  })

  describe('#executeServiceAgreement', () => {
    let tx, log
    const fHash = functionSelector('requestedBytes32(bytes32,bytes32)')
    const to = '0x80e29acb842498fe6591f020bd82766dce619d43'
    const payment = 1000000000000000000
    const requestDigest = newHash('0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef')
    const oracle = newAddress(oracleNode)
    const unsignedArgs = {
      payment: newHash(payment.toString()),
      expiration: newHash('300'),
      endAt: newHash(endAt.toString()),
      oracles: [oracle],
      requestDigest }

    const sAID = calculateSAID(unsignedArgs)
    const oracleSignature = personalSign(oracle, sAID)
    const signedArgs = Object.assign(unsignedArgs, { oracleSignature })

    beforeEach(async () => {
      await initiateServiceAgreement(coordinator, signedArgs)
      await link.transfer(consumer, toWei(1000))
    })

    context('when called through the LINK token with enough payment', () => {
      const payload = executeServiceAgreementBytes(toHex(sAID), to, fHash, '1', '')
      beforeEach(async () => {
        tx = await link.transferAndCall(coordinator.address, payment, payload, {
          from: consumer
        })
        log = tx.receipt.logs[2]
      })

      it('logs an event', async () => {
        assert.equal(coordinator.address, log.address)

        // If updating this test, be sure to update services.ServiceAgreementExecutionLogTopic.
        // (Which see for the calculation of this hash.)
        let eventSignature = '0x6d6db1f8fe19d95b1d0fa6a4bce7bb24fbf84597b35a33ff95521fac453c1529'
        assert.equal(eventSignature, log.topics[0])

        assert.equal(toHex(sAID), log.topics[1])
        assert.equal(consumer, web3.toDecimal(log.topics[2]))
        assert.equal(payment, web3.toDecimal(log.topics[3]))
      })
    })

    context('when called through the LINK token with not enough payment', () => {
      it('throws an error', async () => {
        const calldata = executeServiceAgreementBytes(toHex(sAID), to, fHash, '1', '')
        const underPaid = bigNum(payment).sub(1)

        await assertActionThrows(async () => {
          tx = await link.transferAndCall(coordinator.address, underPaid, calldata, {
            from: consumer
          })
        })
      })
    })

    context('when not called through the LINK token', () => {
      it('reverts', async () => {
        await assertActionThrows(async () => {
          await coordinator.executeServiceAgreement(0, 0, 1, toHex(sAID), to, fHash, 'id', '', { from: consumer })
        })
      })
    })
  })

  describe('#fulfillData', () => {
    let mock, internalId

    const oracle = newAddress(oracleNode)
    const payment = 1000000000000000000
    const unsignedDefaultServiceAgreement = {
      payment: newHash(payment.toString()),
      expiration: newHash('300'),
      endAt: newHash(endAt.toString()),
      oracles: [oracle],
      requestDigest: newHash(
        '0xbadc0de5badc0de5badc0de5badc0de5badc0de5badc0de5badc0de5badc0de5')
    }
    const sAID = calculateSAID(unsignedDefaultServiceAgreement)
    const oracleSignature = personalSign(oracle, sAID)
    const requestDigestAddr =
      recoverPersonalSignature(sAID, oracleSignature)
    assert.equal(toHex(oracle), toHex(requestDigestAddr))
    const defaultArgs = Object.assign(
      unsignedDefaultServiceAgreement, { oracleSignature })
    const externalId = '17'

    beforeEach(async () => {
      await initiateServiceAgreement(coordinator, defaultArgs)

      mock = await deploy('examples/GetterSetter.sol')
      const fHash = functionSelector('requestedBytes32(bytes32,bytes32)')

      const payload = executeServiceAgreementBytes(toHex(sAID), mock.address, fHash, externalId, '')
      const tx = await link.transferAndCall(coordinator.address, payment, payload)
      internalId = runRequestId(tx.receipt.logs[2])
    })

    context('cooperative consumer', () => {
      context('when called by a non-owner', () => {
        xit('raises an error', async () => {
          await assertActionThrows(async () => {
            await coordinator.fulfillData(internalId, 'Hello World!', { from: stranger })
          })
        })
      })

      context('when called by an owner', () => {
        it('raises an error if the request ID does not exist', async () => {
          await assertActionThrows(async () => {
            await coordinator.fulfillData(0xdeadbeef, 'Hello World!', { from: oracleNode })
          })
        })

        it('sets the value on the requested contract', async () => {
          await coordinator.fulfillData(internalId, 'Hello World!', { from: oracleNode })

          const mockRequestId = await mock.requestId.call()
          assert.equal(externalId.toString(), web3.toUtf8(mockRequestId))

          const currentValue = await mock.getBytes32.call()
          assert.equal('Hello World!', web3.toUtf8(currentValue))
        })

        it('does not allow a request to be fulfilled twice', async () => {
          await coordinator.fulfillData(internalId, 'First message!', { from: oracleNode })
          await assertActionThrows(async () => {
            await coordinator.fulfillData(internalId, 'Second message!!', { from: oracleNode })
          })
        })
      })
    })

    context('with a malicious requester', () => {
      const paymentAmount = toWei(1)

      it('cannot cancel before the expiration', async () => {
        mock = await deploy('examples/MaliciousRequester.sol', link.address, coordinator.address)
        await link.transfer(mock.address, paymentAmount)

        await assertActionThrows(async () => {
          await mock.maliciousRequestCancel()
        })
      })

      it('cannot call functions on the LINK token through callbacks', async () => {
        const fHash = functionSelector('transfer(address,uint256)')
        const addressAsRequestId = abiEncode(['address'], [stranger])
        const args = requestDataBytes(toHex(sAID), link.address, fHash, addressAsRequestId, '')

        assertActionThrows(async () => {
          await requestDataFrom(coordinator, link, paymentAmount, args)
        })
      })
    })

    context('with a malicious consumer', () => {
      const paymentAmount = toWei(1)

      beforeEach(async () => {
        mock = await deploy('examples/MaliciousServiceAgreementConsumer.sol', link.address, coordinator.address)
        await link.transfer(mock.address, paymentAmount)
      })

      context('fails during fulfillment', () => {
        beforeEach(async () => {
          const req = await mock.requestData('assertFail(bytes32,bytes32)')
          internalId = runRequestId(req.receipt.logs[3])
        })

        // needs coordinator withdrawal functionality to meet parity
        xit('allows the oracle node to receive their payment', async () => {
          await coordinator.fulfillData(internalId, 'hack the planet 101', { from: oracleNode })

          const balance = await link.balanceOf.call(oracleNode)
          assert.isTrue(balance.equals(0))

          await coordinator.withdraw(oracleNode, paymentAmount, { from: oracleNode })
          const newBalance = await link.balanceOf.call(oracleNode)
          assert.isTrue(paymentAmount.equals(newBalance))
        })

        it("can't fulfill the data again", async () => {
          await coordinator.fulfillData(internalId, 'hack the planet 101', { from: oracleNode })
          await assertActionThrows(async () => {
            await coordinator.fulfillData(internalId, 'hack the planet 102', { from: oracleNode })
          })
        })
      })

      context('calls selfdestruct', () => {
        beforeEach(async () => {
          const req = await mock.requestData('doesNothing(bytes32,bytes32)')
          internalId = runRequestId(req.receipt.logs[3])
          await mock.remove()
        })

        // needs coordinator withdrawal functionality to meet parity
        xit('allows the oracle node to receive their payment', async () => {
          await coordinator.fulfillData(internalId, 'hack the planet 101', { from: oracleNode })

          const balance = await link.balanceOf.call(oracleNode)
          assert.isTrue(balance.equals(0))

          await coordinator.withdraw(oracleNode, paymentAmount, { from: oracleNode })
          const newBalance = await link.balanceOf.call(oracleNode)
          assert.isTrue(paymentAmount.equals(newBalance))
        })
      })

      context('request is canceled during fulfillment', () => {
        beforeEach(async () => {
          const req = await mock.requestData('cancelRequestOnFulfill(bytes32,bytes32)')
          internalId = runRequestId(req.receipt.logs[3])

          const mockBalance = await link.balanceOf.call(mock.address)
          assert.isTrue(mockBalance.equals(0))
        })

        // needs coordinator withdrawal functionality to meet parity
        xit('allows the oracle node to receive their payment', async () => {
          await coordinator.fulfillData(internalId, 'hack the planet 101', { from: oracleNode })

          const mockBalance = await link.balanceOf.call(mock.address)
          assert.isTrue(mockBalance.equals(0))

          const balance = await link.balanceOf.call(oracleNode)
          assert.isTrue(balance.equals(0))

          await coordinator.withdraw(oracleNode, paymentAmount, { from: oracleNode })
          const newBalance = await link.balanceOf.call(oracleNode)
          assert.isTrue(paymentAmount.equals(newBalance))
        })

        it("can't fulfill the data again", async () => {
          await coordinator.fulfillData(internalId, 'hack the planet 101', { from: oracleNode })
          await assertActionThrows(async () => {
            await coordinator.fulfillData(internalId, 'hack the planet 102', { from: oracleNode })
          })
        })
      })

      context('requester lies about amount of LINK sent', () => {
        it('the oracle uses the amount of LINK actually paid', async () => {
          const req = await mock.requestData('assertFail(bytes32,bytes32)')
          const log = req.receipt.logs[3]

          assert.equal(web3.toWei(1), web3.toDecimal(log.topics[3]))
        })
      })
    })
  })
})
