// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.25.1
// source: loop/internal/pb/capabilities.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	BaseCapability_Info_FullMethodName = "/loop.BaseCapability/Info"
)

// BaseCapabilityClient is the client API for BaseCapability service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BaseCapabilityClient interface {
	Info(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*CapabilityInfoReply, error)
}

type baseCapabilityClient struct {
	cc grpc.ClientConnInterface
}

func NewBaseCapabilityClient(cc grpc.ClientConnInterface) BaseCapabilityClient {
	return &baseCapabilityClient{cc}
}

func (c *baseCapabilityClient) Info(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*CapabilityInfoReply, error) {
	out := new(CapabilityInfoReply)
	err := c.cc.Invoke(ctx, BaseCapability_Info_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BaseCapabilityServer is the server API for BaseCapability service.
// All implementations must embed UnimplementedBaseCapabilityServer
// for forward compatibility
type BaseCapabilityServer interface {
	Info(context.Context, *emptypb.Empty) (*CapabilityInfoReply, error)
	mustEmbedUnimplementedBaseCapabilityServer()
}

// UnimplementedBaseCapabilityServer must be embedded to have forward compatible implementations.
type UnimplementedBaseCapabilityServer struct {
}

func (UnimplementedBaseCapabilityServer) Info(context.Context, *emptypb.Empty) (*CapabilityInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Info not implemented")
}
func (UnimplementedBaseCapabilityServer) mustEmbedUnimplementedBaseCapabilityServer() {}

// UnsafeBaseCapabilityServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BaseCapabilityServer will
// result in compilation errors.
type UnsafeBaseCapabilityServer interface {
	mustEmbedUnimplementedBaseCapabilityServer()
}

func RegisterBaseCapabilityServer(s grpc.ServiceRegistrar, srv BaseCapabilityServer) {
	s.RegisterService(&BaseCapability_ServiceDesc, srv)
}

func _BaseCapability_Info_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BaseCapabilityServer).Info(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BaseCapability_Info_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BaseCapabilityServer).Info(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// BaseCapability_ServiceDesc is the grpc.ServiceDesc for BaseCapability service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BaseCapability_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "loop.BaseCapability",
	HandlerType: (*BaseCapabilityServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Info",
			Handler:    _BaseCapability_Info_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "loop/internal/pb/capabilities.proto",
}

const (
	TriggerExecutable_RegisterTrigger_FullMethodName   = "/loop.TriggerExecutable/RegisterTrigger"
	TriggerExecutable_UnregisterTrigger_FullMethodName = "/loop.TriggerExecutable/UnregisterTrigger"
)

// TriggerExecutableClient is the client API for TriggerExecutable service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TriggerExecutableClient interface {
	RegisterTrigger(ctx context.Context, in *RegisterTriggerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	UnregisterTrigger(ctx context.Context, in *UnregisterTriggerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type triggerExecutableClient struct {
	cc grpc.ClientConnInterface
}

func NewTriggerExecutableClient(cc grpc.ClientConnInterface) TriggerExecutableClient {
	return &triggerExecutableClient{cc}
}

func (c *triggerExecutableClient) RegisterTrigger(ctx context.Context, in *RegisterTriggerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, TriggerExecutable_RegisterTrigger_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *triggerExecutableClient) UnregisterTrigger(ctx context.Context, in *UnregisterTriggerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, TriggerExecutable_UnregisterTrigger_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TriggerExecutableServer is the server API for TriggerExecutable service.
// All implementations must embed UnimplementedTriggerExecutableServer
// for forward compatibility
type TriggerExecutableServer interface {
	RegisterTrigger(context.Context, *RegisterTriggerRequest) (*emptypb.Empty, error)
	UnregisterTrigger(context.Context, *UnregisterTriggerRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedTriggerExecutableServer()
}

// UnimplementedTriggerExecutableServer must be embedded to have forward compatible implementations.
type UnimplementedTriggerExecutableServer struct {
}

func (UnimplementedTriggerExecutableServer) RegisterTrigger(context.Context, *RegisterTriggerRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterTrigger not implemented")
}
func (UnimplementedTriggerExecutableServer) UnregisterTrigger(context.Context, *UnregisterTriggerRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnregisterTrigger not implemented")
}
func (UnimplementedTriggerExecutableServer) mustEmbedUnimplementedTriggerExecutableServer() {}

// UnsafeTriggerExecutableServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TriggerExecutableServer will
// result in compilation errors.
type UnsafeTriggerExecutableServer interface {
	mustEmbedUnimplementedTriggerExecutableServer()
}

func RegisterTriggerExecutableServer(s grpc.ServiceRegistrar, srv TriggerExecutableServer) {
	s.RegisterService(&TriggerExecutable_ServiceDesc, srv)
}

func _TriggerExecutable_RegisterTrigger_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterTriggerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriggerExecutableServer).RegisterTrigger(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TriggerExecutable_RegisterTrigger_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriggerExecutableServer).RegisterTrigger(ctx, req.(*RegisterTriggerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TriggerExecutable_UnregisterTrigger_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnregisterTriggerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TriggerExecutableServer).UnregisterTrigger(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TriggerExecutable_UnregisterTrigger_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TriggerExecutableServer).UnregisterTrigger(ctx, req.(*UnregisterTriggerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TriggerExecutable_ServiceDesc is the grpc.ServiceDesc for TriggerExecutable service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TriggerExecutable_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "loop.TriggerExecutable",
	HandlerType: (*TriggerExecutableServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterTrigger",
			Handler:    _TriggerExecutable_RegisterTrigger_Handler,
		},
		{
			MethodName: "UnregisterTrigger",
			Handler:    _TriggerExecutable_UnregisterTrigger_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "loop/internal/pb/capabilities.proto",
}

const (
	Callback_SendResponse_FullMethodName  = "/loop.Callback/SendResponse"
	Callback_CloseCallback_FullMethodName = "/loop.Callback/CloseCallback"
)

// CallbackClient is the client API for Callback service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CallbackClient interface {
	SendResponse(ctx context.Context, in *CapabilityResponse, opts ...grpc.CallOption) (*emptypb.Empty, error)
	CloseCallback(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type callbackClient struct {
	cc grpc.ClientConnInterface
}

func NewCallbackClient(cc grpc.ClientConnInterface) CallbackClient {
	return &callbackClient{cc}
}

func (c *callbackClient) SendResponse(ctx context.Context, in *CapabilityResponse, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Callback_SendResponse_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *callbackClient) CloseCallback(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Callback_CloseCallback_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CallbackServer is the server API for Callback service.
// All implementations must embed UnimplementedCallbackServer
// for forward compatibility
type CallbackServer interface {
	SendResponse(context.Context, *CapabilityResponse) (*emptypb.Empty, error)
	CloseCallback(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	mustEmbedUnimplementedCallbackServer()
}

// UnimplementedCallbackServer must be embedded to have forward compatible implementations.
type UnimplementedCallbackServer struct {
}

func (UnimplementedCallbackServer) SendResponse(context.Context, *CapabilityResponse) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendResponse not implemented")
}
func (UnimplementedCallbackServer) CloseCallback(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseCallback not implemented")
}
func (UnimplementedCallbackServer) mustEmbedUnimplementedCallbackServer() {}

// UnsafeCallbackServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CallbackServer will
// result in compilation errors.
type UnsafeCallbackServer interface {
	mustEmbedUnimplementedCallbackServer()
}

func RegisterCallbackServer(s grpc.ServiceRegistrar, srv CallbackServer) {
	s.RegisterService(&Callback_ServiceDesc, srv)
}

func _Callback_SendResponse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CapabilityResponse)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CallbackServer).SendResponse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Callback_SendResponse_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CallbackServer).SendResponse(ctx, req.(*CapabilityResponse))
	}
	return interceptor(ctx, in, info, handler)
}

func _Callback_CloseCallback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CallbackServer).CloseCallback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Callback_CloseCallback_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CallbackServer).CloseCallback(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// Callback_ServiceDesc is the grpc.ServiceDesc for Callback service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Callback_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "loop.Callback",
	HandlerType: (*CallbackServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendResponse",
			Handler:    _Callback_SendResponse_Handler,
		},
		{
			MethodName: "CloseCallback",
			Handler:    _Callback_CloseCallback_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "loop/internal/pb/capabilities.proto",
}

const (
	CallbackExecutable_RegisterToWorkflow_FullMethodName     = "/loop.CallbackExecutable/RegisterToWorkflow"
	CallbackExecutable_UnregisterFromWorkflow_FullMethodName = "/loop.CallbackExecutable/UnregisterFromWorkflow"
	CallbackExecutable_Execute_FullMethodName                = "/loop.CallbackExecutable/Execute"
)

// CallbackExecutableClient is the client API for CallbackExecutable service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CallbackExecutableClient interface {
	RegisterToWorkflow(ctx context.Context, in *RegisterToWorkflowRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	UnregisterFromWorkflow(ctx context.Context, in *UnregisterFromWorkflowRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	Execute(ctx context.Context, in *ExecuteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type callbackExecutableClient struct {
	cc grpc.ClientConnInterface
}

func NewCallbackExecutableClient(cc grpc.ClientConnInterface) CallbackExecutableClient {
	return &callbackExecutableClient{cc}
}

func (c *callbackExecutableClient) RegisterToWorkflow(ctx context.Context, in *RegisterToWorkflowRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CallbackExecutable_RegisterToWorkflow_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *callbackExecutableClient) UnregisterFromWorkflow(ctx context.Context, in *UnregisterFromWorkflowRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CallbackExecutable_UnregisterFromWorkflow_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *callbackExecutableClient) Execute(ctx context.Context, in *ExecuteRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CallbackExecutable_Execute_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CallbackExecutableServer is the server API for CallbackExecutable service.
// All implementations must embed UnimplementedCallbackExecutableServer
// for forward compatibility
type CallbackExecutableServer interface {
	RegisterToWorkflow(context.Context, *RegisterToWorkflowRequest) (*emptypb.Empty, error)
	UnregisterFromWorkflow(context.Context, *UnregisterFromWorkflowRequest) (*emptypb.Empty, error)
	Execute(context.Context, *ExecuteRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedCallbackExecutableServer()
}

// UnimplementedCallbackExecutableServer must be embedded to have forward compatible implementations.
type UnimplementedCallbackExecutableServer struct {
}

func (UnimplementedCallbackExecutableServer) RegisterToWorkflow(context.Context, *RegisterToWorkflowRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterToWorkflow not implemented")
}
func (UnimplementedCallbackExecutableServer) UnregisterFromWorkflow(context.Context, *UnregisterFromWorkflowRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnregisterFromWorkflow not implemented")
}
func (UnimplementedCallbackExecutableServer) Execute(context.Context, *ExecuteRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Execute not implemented")
}
func (UnimplementedCallbackExecutableServer) mustEmbedUnimplementedCallbackExecutableServer() {}

// UnsafeCallbackExecutableServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CallbackExecutableServer will
// result in compilation errors.
type UnsafeCallbackExecutableServer interface {
	mustEmbedUnimplementedCallbackExecutableServer()
}

func RegisterCallbackExecutableServer(s grpc.ServiceRegistrar, srv CallbackExecutableServer) {
	s.RegisterService(&CallbackExecutable_ServiceDesc, srv)
}

func _CallbackExecutable_RegisterToWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterToWorkflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CallbackExecutableServer).RegisterToWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CallbackExecutable_RegisterToWorkflow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CallbackExecutableServer).RegisterToWorkflow(ctx, req.(*RegisterToWorkflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CallbackExecutable_UnregisterFromWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnregisterFromWorkflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CallbackExecutableServer).UnregisterFromWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CallbackExecutable_UnregisterFromWorkflow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CallbackExecutableServer).UnregisterFromWorkflow(ctx, req.(*UnregisterFromWorkflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CallbackExecutable_Execute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CallbackExecutableServer).Execute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CallbackExecutable_Execute_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CallbackExecutableServer).Execute(ctx, req.(*ExecuteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CallbackExecutable_ServiceDesc is the grpc.ServiceDesc for CallbackExecutable service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CallbackExecutable_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "loop.CallbackExecutable",
	HandlerType: (*CallbackExecutableServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterToWorkflow",
			Handler:    _CallbackExecutable_RegisterToWorkflow_Handler,
		},
		{
			MethodName: "UnregisterFromWorkflow",
			Handler:    _CallbackExecutable_UnregisterFromWorkflow_Handler,
		},
		{
			MethodName: "Execute",
			Handler:    _CallbackExecutable_Execute_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "loop/internal/pb/capabilities.proto",
}
