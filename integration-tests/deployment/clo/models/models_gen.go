// Forked from https://github.com/smartcontractkit/feeds-manager/blob/afc24439ee1dffd3781b53c9419ccd1eb44f4163/api/models/models_gen.go#L1
// TODO: KS-455: Refactor this package to use chainlink-common
// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package models

import (
	"fmt"
	"io"
	"strconv"
)

type AggregatorConfig interface {
	IsAggregatorConfig()
}

type AggregatorSpecConfig interface {
	IsAggregatorSpecConfig()
}

type JobConfig interface {
	IsJobConfig()
}

type Action struct {
	Name       string     `json:"name,omitempty"`
	ActionType ActionType `json:"actionType,omitempty"`
	Run        *ActionRun `json:"run,omitempty"`
	Tasks      []*Task    `json:"tasks,omitempty"`
}

type ActionRun struct {
	ID         string          `json:"id,omitempty"`
	Network    *Network        `json:"network,omitempty"`
	ActionType ActionType      `json:"actionType,omitempty"`
	Status     ActionRunStatus `json:"status,omitempty"`
	Tasks      []*Task         `json:"tasks,omitempty"`
	TaskRuns   []*TaskRun      `json:"taskRuns,omitempty"`
	CreatedAt  Time            `json:"createdAt,omitempty"`
}

type ActivateBootstrapNodeInput struct {
	ID           string       `json:"id,omitempty"`
	ContractType ContractType `json:"contractType,omitempty"`
}

type ActivateBootstrapNodePayload struct {
	Node   *Node   `json:"node,omitempty"`
	Errors []Error `json:"errors,omitempty"`
}

type AddAggregatorInput struct {
	Name       string `json:"name,omitempty"`
	Template   string `json:"template,omitempty"`
	CategoryID string `json:"categoryID,omitempty"`
}

type AddChainInput struct {
	NetworkID string `json:"networkID,omitempty"`
	Template  string `json:"template,omitempty"`
	// The Display Name lets a user differentiate multiple CCIP chains on the same network. It is not unique and used for display purposes only.
	DisplayName *string `json:"displayName,omitempty"`
}

type AddChainPayload struct {
	Errors []Error    `json:"errors,omitempty"`
	Chain  *CCIPChain `json:"chain,omitempty"`
}

type AddChainTestContractsInput struct {
	ChainID string `json:"chainID,omitempty"`
}

type AddChainTestContractsPayload struct {
	Chain  *CCIPChain `json:"chain,omitempty"`
	Errors []Error    `json:"errors,omitempty"`
}

type AddFeedAggregatorInput struct {
	FeedID     string              `json:"feedID,omitempty"`
	Aggregator *AddAggregatorInput `json:"aggregator,omitempty"`
}

type AddFeedAggregatorPayload struct {
	Aggregator *Aggregator `json:"aggregator,omitempty"`
	Errors     []Error     `json:"errors,omitempty"`
}

type AddFeedInput struct {
	Name       string              `json:"name,omitempty"`
	NetworkID  string              `json:"networkID,omitempty"`
	Proxy      *AddProxyInput      `json:"proxy,omitempty"`
	Aggregator *AddAggregatorInput `json:"aggregator,omitempty"`
}

type AddFeedPayload struct {
	Feed   *Feed   `json:"feed,omitempty"`
	Errors []Error `json:"errors,omitempty"`
}

type AddLaneInput struct {
	ChainAid string `json:"chainAID,omitempty"`
	ChainBid string `json:"chainBID,omitempty"`
	Template string `json:"template,omitempty"`
	// The Display Name lets a user differentiate multiple CCIP chains on the same network. It is not unique and used for display purposes only.
	DisplayName *string `json:"displayName,omitempty"`
}

type AddLanePayload struct {
	Errors []Error   `json:"errors,omitempty"`
	Lane   *CCIPLane `json:"lane,omitempty"`
}

type AddLaneUpgradeInput struct {
	LaneID   string `json:"laneID,omitempty"`
	Template string `json:"template,omitempty"`
}

type AddLaneUpgradePayload struct {
	Lane   *CCIPLane `json:"lane,omitempty"`
	Errors []Error   `json:"errors,omitempty"`
}

type AddMercuryV03NetworkStackInput struct {
	NetworkID            string                `json:"networkID,omitempty"`
	MercuryServerURL     string                `json:"mercuryServerURL,omitempty"`
	MercuryServerPubKey  string                `json:"mercuryServerPubKey,omitempty"`
	ReadAccessController *ReadAccessController `json:"readAccessController,omitempty"`
	NativeSurcharge      *string               `json:"nativeSurcharge,omitempty"`
	Servers              *string               `json:"servers,omitempty"`
}

type AddMercuryV03NetworkStackPayload struct {
	NetworkStack *MercuryV03NetworkStack `json:"networkStack,omitempty"`
	Errors       []Error                 `json:"errors,omitempty"`
}

type AddProxyInput struct {
	AccessControllerAddress *string `json:"accessControllerAddress,omitempty"`
}

type AddStorageContractInput struct {
	NetworkID   string  `json:"networkID,omitempty"`
	Template    string  `json:"template,omitempty"`
	DisplayName *string `json:"displayName,omitempty"`
}

type AddStorageContractPayload struct {
	StorageContract *StorageContract `json:"storageContract,omitempty"`
	Errors          []Error          `json:"errors,omitempty"`
}

type AddTokenInput struct {
	Template string `json:"template,omitempty"`
}

type AddTokenPayload struct {
	Token  *CCIPToken `json:"token,omitempty"`
	Errors []Error    `json:"errors,omitempty"`
}

type AddTokenPoolInput struct {
	ID       string `json:"id,omitempty"`
	Template string `json:"template,omitempty"`
}

type AddTokenPoolPayload struct {
	Errors []Error    `json:"errors,omitempty"`
	Chain  *CCIPChain `json:"chain,omitempty"`
}

type AddVerificationProviderInput struct {
	FeedID         string `json:"feedID,omitempty"`
	NetworkStackID string `json:"networkStackID,omitempty"`
}

type AddVerificationProviderPayload struct {
	Feed   *MercuryV03Feed `json:"feed,omitempty"`
	Errors []Error         `json:"errors,omitempty"`
}

type Aggregator struct {
	ID                      string                  `json:"id,omitempty"`
	Name                    string                  `json:"name,omitempty"`
	ContractAddress         *string                 `json:"contractAddress,omitempty"`
	ContractType            ContractType            `json:"contractType,omitempty"`
	DeploymentStatus        DeploymentStatus        `json:"deploymentStatus,omitempty"`
	OwnerAddress            *string                 `json:"ownerAddress,omitempty"`
	OwnerAddressType        *ContractOwnerType      `json:"ownerAddressType,omitempty"`
	PendingOwnerAddress     *string                 `json:"pendingOwnerAddress,omitempty"`
	PendingOwnerType        *ContractOwnerType      `json:"pendingOwnerType,omitempty"`
	TransferOwnershipStatus TransferOwnershipStatus `json:"transferOwnershipStatus,omitempty"`
	Don                     *Don                    `json:"don,omitempty"`
	BootstrapMultiaddrs     []string                `json:"bootstrapMultiaddrs,omitempty"`
	SpecConfig              AggregatorSpecConfig    `json:"specConfig,omitempty"`
	Config                  AggregatorConfig        `json:"config,omitempty"`
	Feed                    *Feed                   `json:"feed,omitempty"`
	Network                 *Network                `json:"network,omitempty"`
	Category                *Category               `json:"category,omitempty"`
	CreatedAt               Time                    `json:"createdAt,omitempty"`
}

type AggregatorBilling struct {
	MaximumGasPrice         string `json:"maximumGasPrice,omitempty"`
	ReasonableGasPrice      string `json:"reasonableGasPrice,omitempty"`
	MicroLinkPerEth         string `json:"microLinkPerEth,omitempty"`
	LinkGweiPerObservation  string `json:"linkGweiPerObservation,omitempty"`
	LinkGewiPerTransmission string `json:"linkGewiPerTransmission,omitempty"`
}

type AggregatorConfigOcr1 struct {
	Description             string `json:"description,omitempty"`
	ReasonableGasPrice      string `json:"reasonableGasPrice,omitempty"`
	MaximumGasPrice         string `json:"maximumGasPrice,omitempty"`
	MicroLinkPerEth         string `json:"microLinkPerEth,omitempty"`
	LinkGweiPerObservation  string `json:"linkGweiPerObservation,omitempty"`
	LinkGweiPerTransmission string `json:"linkGweiPerTransmission,omitempty"`
	MinimumAnswer           string `json:"minimumAnswer,omitempty"`
	MaximumAnswer           string `json:"maximumAnswer,omitempty"`
	Decimals                string `json:"decimals,omitempty"`
	DeltaProgress           string `json:"deltaProgress,omitempty"`
	DeltaResend             string `json:"deltaResend,omitempty"`
	DeltaRound              string `json:"deltaRound,omitempty"`
	DeltaGrace              string `json:"deltaGrace,omitempty"`
	DeltaC                  string `json:"deltaC,omitempty"`
	AlphaPpb                string `json:"alphaPPB,omitempty"`
	DeltaStage              string `json:"deltaStage,omitempty"`
	RMax                    string `json:"rMax,omitempty"`
	S                       []int  `json:"s,omitempty"`
	F                       string `json:"f,omitempty"`
}

func (AggregatorConfigOcr1) IsAggregatorConfig() {}

type AggregatorConfigOcr2 struct {
	MinimumAnswer                           string  `json:"minimumAnswer,omitempty"`
	MaximumAnswer                           string  `json:"maximumAnswer,omitempty"`
	Description                             string  `json:"description,omitempty"`
	Decimals                                string  `json:"decimals,omitempty"`
	DeltaGrace                              string  `json:"deltaGrace,omitempty"`
	DeltaProgress                           string  `json:"deltaProgress,omitempty"`
	DeltaResend                             string  `json:"deltaResend,omitempty"`
	DeltaRound                              string  `json:"deltaRound,omitempty"`
	DeltaStage                              string  `json:"deltaStage,omitempty"`
	F                                       string  `json:"f,omitempty"`
	MaxDurationObservation                  string  `json:"maxDurationObservation,omitempty"`
	MaxDurationQuery                        string  `json:"maxDurationQuery,omitempty"`
	MaxDurationReport                       string  `json:"maxDurationReport,omitempty"`
	MaxDurationShouldAcceptFinalizedReport  string  `json:"maxDurationShouldAcceptFinalizedReport,omitempty"`
	MaxDurationShouldTransmitAcceptedReport string  `json:"maxDurationShouldTransmitAcceptedReport,omitempty"`
	RMax                                    string  `json:"rMax,omitempty"`
	S                                       []int   `json:"s,omitempty"`
	AlphaAcceptInfinite                     bool    `json:"alphaAcceptInfinite,omitempty"`
	AlphaAcceptPpb                          string  `json:"alphaAcceptPPB,omitempty"`
	AlphaReportInfinite                     bool    `json:"alphaReportInfinite,omitempty"`
	AlphaReportPpb                          string  `json:"alphaReportPPB,omitempty"`
	DeltaC                                  string  `json:"deltaC,omitempty"`
	ObservationPaymentGjuels                string  `json:"observationPaymentGjuels,omitempty"`
	TransmissionPaymentGjuels               string  `json:"transmissionPaymentGjuels,omitempty"`
	MaximumGasPriceGwei                     *string `json:"maximumGasPriceGwei,omitempty"`
	ReasonableGasPriceGwei                  *string `json:"reasonableGasPriceGwei,omitempty"`
	AccountingGas                           *string `json:"accountingGas,omitempty"`
}

func (AggregatorConfigOcr2) IsAggregatorConfig() {}

type AggregatorOnChainConfig struct {
	ConfigCount  string   `json:"configCount,omitempty"`
	BlockNumber  string   `json:"blockNumber,omitempty"`
	ConfigDigest []string `json:"configDigest,omitempty"`
}

type AggregatorOnChainState struct {
	Billing      *AggregatorBilling       `json:"billing,omitempty"`
	Config       *AggregatorOnChainConfig `json:"config,omitempty"`
	OwnerAddress string                   `json:"ownerAddress,omitempty"`
}

type AggregatorProxy struct {
	ID                      string                  `json:"id,omitempty"`
	ContractAddress         *string                 `json:"contractAddress,omitempty"`
	TransferOwnershipStatus TransferOwnershipStatus `json:"transferOwnershipStatus,omitempty"`
	OwnerAddress            *string                 `json:"ownerAddress,omitempty"`
	OwnerAddressType        *ContractOwnerType      `json:"ownerAddressType,omitempty"`
	PendingOwnerAddress     *string                 `json:"pendingOwnerAddress,omitempty"`
	PendingOwnerType        *ContractOwnerType      `json:"pendingOwnerType,omitempty"`
	Aggregator              *Aggregator             `json:"aggregator,omitempty"`
	AccessControllerAddress *string                 `json:"accessControllerAddress,omitempty"`
	Feed                    *Feed                   `json:"feed,omitempty"`
	Network                 *Network                `json:"network,omitempty"`
	CreatedAt               Time                    `json:"createdAt,omitempty"`
}

type ArchiveChainPayload struct {
	Chain  *CCIPChain `json:"chain,omitempty"`
	Errors []Error    `json:"errors,omitempty"`
}

type ArchiveContractInput struct {
	ChainID    string `json:"chainID,omitempty"`
	ContractID string `json:"contractID,omitempty"`
}

type ArchiveContractPayload struct {
	Contract *Contract `json:"contract,omitempty"`
	Errors   []Error   `json:"errors,omitempty"`
}

type ArchiveFeedPayload struct {
	Feed   *MercuryV03Feed `json:"feed,omitempty"`
	Errors []Error         `json:"errors,omitempty"`
}

type ArchiveLanePayload struct {
	Lane   *CCIPLane `json:"lane,omitempty"`
	Errors []Error   `json:"errors,omitempty"`
}

type ArchiveNetworkInput struct {
	ID string `json:"id,omitempty"`
}

type ArchiveNetworkPayload struct {
	Network *Network `json:"network,omitempty"`
	Errors  []Error  `json:"errors,omitempty"`
}

type ArchiveNetworkStackPayload struct {
	NetworkStack *MercuryV03NetworkStack `json:"networkStack,omitempty"`
	Errors       []Error                 `json:"errors,omitempty"`
}

type AssignNodeToJobInput struct {
	JobID  string `json:"jobID,omitempty"`
	NodeID string `json:"nodeID,omitempty"`
}

type AssignNodeToJobPayload struct {
	Job    *Job    `json:"job,omitempty"`
	Errors []Error `json:"errors,omitempty"`
}

type BuildInfo struct {
	Version string `json:"version,omitempty"`
}

type CCIPChain struct {
	ID                 string             `json:"id,omitempty"`
	Network            *Network           `json:"network,omitempty"`
	Contracts          []*Contract        `json:"contracts,omitempty"`
	WorkflowRuns       []*WorkflowRun     `json:"workflowRuns,omitempty"`
	SupportedTokens    []*EVMBridgedToken `json:"supportedTokens,omitempty"`
	FeeTokens          []string           `json:"feeTokens,omitempty"`
	WrappedNativeToken string             `json:"wrappedNativeToken,omitempty"`
	ArchivedAt         *Time              `json:"archivedAt,omitempty"`
	// The Display Name lets a user differentiate multiple CCIP chains on the same network. It is not unique and used for display purposes only.
	DisplayName      *string                `json:"displayName,omitempty"`
	DeployedTemplate map[string]interface{} `json:"deployedTemplate,omitempty"`
	Labels           map[string]interface{} `json:"labels,omitempty"`
}

type CCIPChainBasic struct {
	ID        string           `json:"id,omitempty"`
	ChainID   string           `json:"chainID,omitempty"`
	Contracts []*ContractBasic `json:"contracts,omitempty"`
}

type CCIPChainFilter struct {
	IsArchived *bool                `json:"isArchived,omitempty"`
	Selectors  []*CCIPChainSelector `json:"selectors,omitempty"`
}

type CCIPChainSelector struct {
	Key   string     `json:"key,omitempty"`
	Op    SelectorOp `json:"op,omitempty"`
	Value *string    `json:"value,omitempty"`
}

type CCIPEndpoint struct {
	Chain     *CCIPChain  `json:"chain,omitempty"`
	Contracts []*Contract `json:"contracts,omitempty"`
}

type CCIPEndpointBasic struct {
	Chain     *CCIPChainBasic  `json:"chain,omitempty"`
	Contracts []*ContractBasic `json:"contracts,omitempty"`
}

type CCIPLane struct {
	ID                          string                 `json:"id,omitempty"`
	ChainA                      *CCIPChain             `json:"chainA,omitempty"`
	ChainB                      *CCIPChain             `json:"chainB,omitempty"`
	LegA                        *CCIPLaneLeg           `json:"legA,omitempty"`
	LegB                        *CCIPLaneLeg           `json:"legB,omitempty"`
	LegAProvisional             *CCIPLaneLeg           `json:"legAProvisional,omitempty"`
	LegBProvisional             *CCIPLaneLeg           `json:"legBProvisional,omitempty"`
	Dons                        []*Don                 `json:"dons,omitempty"`
	WorkflowRuns                []*WorkflowRun         `json:"workflowRuns,omitempty"`
	Status                      CCIPLaneLegStatus      `json:"status,omitempty"`
	ArchivedAt                  *Time                  `json:"archivedAt,omitempty"`
	DisplayName                 *string                `json:"displayName,omitempty"`
	DeployedTemplate            map[string]interface{} `json:"deployedTemplate,omitempty"`
	DeployedProvisionalTemplate map[string]interface{} `json:"deployedProvisionalTemplate,omitempty"`
}

type CCIPLaneChainUpdateInput struct {
	ID string `json:"id,omitempty"`
}

type CCIPLaneLeg struct {
	ID              string            `json:"id,omitempty"`
	Tag             CCIPLaneLegTag    `json:"tag,omitempty"`
	Source          *CCIPEndpoint     `json:"source,omitempty"`
	Destination     *CCIPEndpoint     `json:"destination,omitempty"`
	WorkflowRuns    []*WorkflowRun    `json:"workflowRuns,omitempty"`
	Dons            []*Don            `json:"dons,omitempty"`
	Status          CCIPLaneLegStatus `json:"status,omitempty"`
	ArchivedAt      *Time             `json:"archivedAt,omitempty"`
	SupportedTokens []string          `json:"supportedTokens,omitempty"`
}

type CCIPLaneLegBasic struct {
	ID              string             `json:"id,omitempty"`
	Source          *CCIPEndpointBasic `json:"source,omitempty"`
	Destination     *CCIPEndpointBasic `json:"destination,omitempty"`
	Dons            []*DONBasic        `json:"dons,omitempty"`
	Status          CCIPLaneLegStatus  `json:"status,omitempty"`
	SupportedTokens []string           `json:"supportedTokens,omitempty"`
}

type CCIPLaneLegsFilter struct {
	ContractAddress string `json:"contractAddress,omitempty"`
	NetworkNameKey  string `json:"networkNameKey,omitempty"`
}

type CCIPLanesFilter struct {
	IsArchived *bool `json:"isArchived,omitempty"`
}

type CCIPMutations struct {
	AddChain              *AddChainPayload              `json:"addChain,omitempty"`
	ImportChain           *ImportChainPayload           `json:"importChain,omitempty"`
	AddChainTestContracts *AddChainTestContractsPayload `json:"addChainTestContracts,omitempty"`
	AddTokenPool          *AddTokenPoolPayload          `json:"addTokenPool,omitempty"`
	ImportTokenPool       *ImportTokenPoolPayload       `json:"importTokenPool,omitempty"`
	AddToken              *AddTokenPayload              `json:"addToken,omitempty"`
	DeployContract        *DeployContractPayload        `json:"deployContract,omitempty"`
	DeleteContract        *DeleteContractPayload        `json:"deleteContract,omitempty"`
	ArchiveContract       *ArchiveContractPayload       `json:"archiveContract,omitempty"`
	// Deploys the contracts for a chain
	DeployChain              *CcipDeployChainPayload              `json:"deployChain,omitempty"`
	DeployChainTestContracts *CcipDeployChainTestContractsPayload `json:"deployChainTestContracts,omitempty"`
	DeployToken              *DeployTokenPayload                  `json:"deployToken,omitempty"`
	DeregisterTestToken      *DeregisterTestTokenPayload          `json:"deregisterTestToken,omitempty"`
	AddLane                  *AddLanePayload                      `json:"addLane,omitempty"`
	ImportLane               *ImportLanePayload                   `json:"importLane,omitempty"`
	AddLaneUpgrade           *AddLaneUpgradePayload               `json:"addLaneUpgrade,omitempty"`
	UpdateLane               *UpdateLanePayload                   `json:"updateLane,omitempty"`
	ArchiveLane              *ArchiveLanePayload                  `json:"archiveLane,omitempty"`
	ArchiveChain             *ArchiveChainPayload                 `json:"archiveChain,omitempty"`
	CancelLaneUpgrade        *CancelLaneUpgradePayload            `json:"cancelLaneUpgrade,omitempty"`
	ConfirmLaneUpgrade       *ConfirmLaneUpgradePayload           `json:"confirmLaneUpgrade,omitempty"`
	DeployLaneLeg            *CcipDeployLaneLegPayload            `json:"deployLaneLeg,omitempty"`
	SetAllowListTokenPool    *SetAllowListTokenPoolPayload        `json:"setAllowListTokenPool,omitempty"`
	// SetConfigLaneLeg sets the on chain configuration for the Commit Store and Off Ramp contracts of the lane leg.
	//
	// The configuration values passed as arguments to the contract call are provided by the most recently inserted
	// RDD template.
	SetConfigLaneLeg  *CcipSetConfigLaneLegPayload `json:"setConfigLaneLeg,omitempty"`
	TransferOwnership *TransferOwnershipPayload    `json:"transferOwnership,omitempty"`
	TransferAdminRole *TransferAdminRolePayload    `json:"transferAdminRole,omitempty"`
	UpdateChain       *UpdateCCIPChainPayload      `json:"updateChain,omitempty"`
	RemoveLiquidity   *RemoveLiquidityPayload      `json:"removeLiquidity,omitempty"`
	SyncChain         *SyncChainPayload            `json:"syncChain,omitempty"`
	SyncLane          *SyncLanePayload             `json:"syncLane,omitempty"`
	SyncContracts     *SyncContractsPayload        `json:"syncContracts,omitempty"`
}

type CCIPQueries struct {
	Chains   []*CCIPChain        `json:"chains,omitempty"`
	Lanes    []*CCIPLane         `json:"lanes,omitempty"`
	LaneLegs []*CCIPLaneLegBasic `json:"laneLegs,omitempty"`
	Chain    *CCIPChain          `json:"chain,omitempty"`
	Lane     *CCIPLane           `json:"lane,omitempty"`
	Tokens   []*CCIPToken        `json:"tokens,omitempty"`
	Token    *CCIPToken          `json:"token,omitempty"`
}

type CCIPToken struct {
	ID         string           `json:"id,omitempty"`
	Symbol     string           `json:"symbol,omitempty"`
	TokenPools []*CCIPTokenPool `json:"tokenPools,omitempty"`
}

type CCIPTokenPool struct {
	ID           string         `json:"id,omitempty"`
	Contract     *Contract      `json:"contract,omitempty"`
	Address      *string        `json:"address,omitempty"`
	TokenAddress string         `json:"tokenAddress,omitempty"`
	TokenSymbol  string         `json:"tokenSymbol,omitempty"`
	Chain        *CCIPChain     `json:"chain,omitempty"`
	WorkflowRuns []*WorkflowRun `json:"workflowRuns,omitempty"`
}

type CcipDeployChainInput struct {
	ChainID string `json:"chainID,omitempty"`
}

type CcipDeployChainPayload struct {
	WorkflowRun *WorkflowRun `json:"workflowRun,omitempty"`
	Errors      []Error      `json:"errors,omitempty"`
}

type CcipDeployChainTestContractsInput struct {
	ChainID string `json:"chainID,omitempty"`
}

type CcipDeployChainTestContractsPayload struct {
	WorkflowRun *WorkflowRun `json:"workflowRun,omitempty"`
	Errors      []Error      `json:"errors,omitempty"`
}

type CcipDeployLaneLegInput struct {
	LegID string `json:"legID,omitempty"`
}

type CcipDeployLaneLegPayload struct {
	WorkflowRun *WorkflowRun `json:"workflowRun,omitempty"`
	Errors      []Error      `json:"errors,omitempty"`
}

type CcipSetConfigLaneLegInput struct {
	LegID string `json:"legID,omitempty"`
}

type CcipSetConfigLaneLegPayload struct {
	WorkflowRun *WorkflowRun `json:"workflowRun,omitempty"`
	Errors      []Error      `json:"errors,omitempty"`
}

type CSAKeypair struct {
	ID        string `json:"id,omitempty"`
	PublicKey string `json:"publicKey,omitempty"`
	CreatedAt Time   `json:"createdAt,omitempty"`
}

type CancelLaneUpgradeInput struct {
	LaneID string `json:"laneID,omitempty"`
}

type CancelLaneUpgradePayload struct {
	Errors []Error   `json:"errors,omitempty"`
	Lane   *CCIPLane `json:"lane,omitempty"`
}

type Category struct {
	ID        string `json:"id,omitempty"`
	Name      string `json:"name,omitempty"`
	Color     string `json:"color,omitempty"`
	CreatedAt Time   `json:"createdAt,omitempty"`
}

type ConfirmLaneUpgradeInput struct {
	LaneID string `json:"laneID,omitempty"`
}

type ConfirmLaneUpgradePayload struct {
	Errors []Error   `json:"errors,omitempty"`
	Lane   *CCIPLane `json:"lane,omitempty"`
}

type Contract struct {
	ID                      string                  `json:"id,omitempty"`
	Network                 *Network                `json:"network,omitempty"`
	Name                    string                  `json:"name,omitempty"`
	Version                 int                     `json:"version,omitempty"`
	Semver                  *string                 `json:"semver,omitempty"`
	Tag                     ContractTag             `json:"tag,omitempty"`
	Address                 *string                 `json:"address,omitempty"`
	Metadata                map[string]interface{}  `json:"metadata,omitempty"`
	OwnerAddress            *string                 `json:"ownerAddress,omitempty"`
	OwnerType               ContractOwnerType       `json:"ownerType,omitempty"`
	PendingOwnerAddress     *string                 `json:"pendingOwnerAddress,omitempty"`
	PendingOwnerType        *ContractOwnerType      `json:"pendingOwnerType,omitempty"`
	TransferOwnershipStatus TransferOwnershipStatus `json:"transferOwnershipStatus,omitempty"`
	VerificationStatus      VerificationStatus      `json:"verificationStatus,omitempty"`
	SourceCodeHash          string                  `json:"sourceCodeHash,omitempty"`
	DeployedAt              *Time                   `json:"deployedAt,omitempty"`
	Imported                bool                    `json:"imported,omitempty"`
	ArchivedAt              *Time                   `json:"archivedAt,omitempty"`
}

type ContractBasic struct {
	ID       string                 `json:"id,omitempty"`
	Name     string                 `json:"name,omitempty"`
	Version  int                    `json:"version,omitempty"`
	Semver   *string                `json:"semver,omitempty"`
	Address  *string                `json:"address,omitempty"`
	Metadata map[string]interface{} `json:"metadata,omitempty"`
}

type CreateBootstrapJobInput struct {
	DonID  string `json:"donID,omitempty"`
	NodeID string `json:"nodeID,omitempty"`
}

type CreateBootstrapJobPayload struct {
	Job    *Job    `json:"job,omitempty"`
	Errors []Error `json:"errors,omitempty"`
}

type CreateCSAKeypairPayload struct {
	CsaKeypair *CSAKeypair `json:"csaKeypair,omitempty"`
	Errors     []Error     `json:"errors,omitempty"`
}

type CreateCategoryInput struct {
	Name  string  `json:"name,omitempty"`
	Color *string `json:"color,omitempty"`
}

type CreateCategoryPayload struct {
	Category *Category `json:"category,omitempty"`
	Errors   []Error   `json:"errors,omitempty"`
}

type CreateJobInput struct {
	Type           JobType         `json:"type,omitempty"`
	Ocr2PluginType *OCR2PluginType `json:"ocr2PluginType,omitempty"`
	Config         *JobConfigInput `json:"config,omitempty"`
	DonID          string          `json:"donID,omitempty"`
	NodeOperatorID string          `json:"nodeOperatorID,omitempty"`
}

type CreateJobPayload struct {
	Job    *Job    `json:"job,omitempty"`
	Errors []Error `json:"errors,omitempty"`
}

type CreateMercuryNetworkStackInput struct {
	NetworkID            string  `json:"networkID,omitempty"`
	VerifierAddress      string  `json:"verifierAddress,omitempty"`
	VerifierProxyAddress string  `json:"verifierProxyAddress,omitempty"`
	ServerURL            string  `json:"serverURL,omitempty"`
	ServerPublicKey      string  `json:"serverPublicKey,omitempty"`
	Servers              *string `json:"servers,omitempty"`
}

type CreateMercuryNetworkStackPayload struct {
	NetworkStack *MercuryNetworkStack `json:"networkStack,omitempty"`
	Errors       []Error              `json:"errors,omitempty"`
}

type CreateNetworkInput struct {
	ChainID                               string    `json:"chainID,omitempty"`
	ChainType                             ChainType `json:"chainType,omitempty"`
	Name                                  string    `json:"name,omitempty"`
	NativeToken                           string    `json:"nativeToken,omitempty"`
	NativeTokenContractAddress            *string   `json:"nativeTokenContractAddress,omitempty"`
	ConfigContractAddress                 *string   `json:"configContractAddress,omitempty"`
	LinkUSDProxyAddress                   *string   `json:"linkUSDProxyAddress,omitempty"`
	NativeUSDProxyAddress                 *string   `json:"nativeUSDProxyAddress,omitempty"`
	LinkContractAddress                   *string   `json:"linkContractAddress,omitempty"`
	FlagsContractAddress                  *string   `json:"flagsContractAddress,omitempty"`
	LinkFunding                           *string   `json:"linkFunding,omitempty"`
	BillingAdminAccessControllerAddress   *string   `json:"billingAdminAccessControllerAddress,omitempty"`
	RequesterAdminAccessControllerAddress *string   `json:"requesterAdminAccessControllerAddress,omitempty"`
	ExplorerAPIKey                        *string   `json:"explorerAPIKey,omitempty"`
	ExplorerAPIURL                        *string   `json:"explorerAPIURL,omitempty"`
}

type CreateNetworkPayload struct {
	Network *Network `json:"network,omitempty"`
	Errors  []Error  `json:"errors,omitempty"`
}

type CreateNodeInput struct {
	Name                 string        `json:"name,omitempty"`
	PublicKey            string        `json:"publicKey,omitempty"`
	NodeOperatorID       string        `json:"nodeOperatorID,omitempty"`
	SupportedCategoryIDs []string      `json:"supportedCategoryIDs,omitempty"`
	SupportedProducts    []ProductType `json:"supportedProducts,omitempty"`
}

type CreateNodeOperatorInput struct {
	Keys    []string `json:"keys,omitempty"`
	Name    string   `json:"name,omitempty"`
	Email   *string  `json:"email,omitempty"`
	Website *string  `json:"website,omitempty"`
}

type CreateNodeOperatorPayload struct {
	NodeOperator *NodeOperator `json:"nodeOperator,omitempty"`
	Errors       []Error       `json:"errors,omitempty"`
}

type CreateNodePayload struct {
	Node   *Node   `json:"node,omitempty"`
	Errors []Error `json:"errors,omitempty"`
}

type CreateRelayerAccountInput struct {
	RelayerID string `json:"relayerID,omitempty"`
}

type CreateRelayerAccountPayload struct {
	RelayerAccount *RelayerAccount `json:"relayerAccount,omitempty"`
	Errors         []Error         `json:"errors,omitempty"`
}

type CreateRelayerInput struct {
	Name      string      `json:"name,omitempty"`
	NetworkID string      `json:"networkID,omitempty"`
	Config    string      `json:"config,omitempty"`
	URL       *RelayerURL `json:"url,omitempty"`
}

type CreateRelayerPayload struct {
	Relayer *Relayer `json:"relayer,omitempty"`
	Errors  []Error  `json:"errors,omitempty"`
}

type CreateUserInput struct {
	Email    string   `json:"email,omitempty"`
	Name     string   `json:"name,omitempty"`
	Password string   `json:"password,omitempty"`
	Role     UserRole `json:"role,omitempty"`
}

type CreateUserPayload struct {
	User   *User   `json:"user,omitempty"`
	Errors []Error `json:"errors,omitempty"`
}

type CreateVaultInput struct {
	Name              string        `json:"name,omitempty"`
	Address           string        `json:"address,omitempty"`
	VaultType         VaultType     `json:"vaultType,omitempty"`
	SupportedProducts []ProductType `json:"supportedProducts,omitempty"`
	NetworkID         string        `json:"networkID,omitempty"`
}

type CreateVaultPayload struct {
	Vault  *Vault  `json:"vault,omitempty"`
	Errors []Error `json:"errors,omitempty"`
}

type CreateWebhookInput struct {
	Name        string `json:"name,omitempty"`
	EndpointURL string `json:"endpointURL,omitempty"`
}

type CreateWebhookPayload struct {
	Webhook *Webhook `json:"webhook,omitempty"`
	Errors  []Error  `json:"errors,omitempty"`
}

type Don struct {
	ID            string           `json:"id,omitempty"`
	Network       *Network         `json:"network,omitempty"`
	ExecutionType DONExecutionType `json:"executionType,omitempty"`
	Jobs          []*Job           `json:"jobs,omitempty"`
}

type DONBasic struct {
	ID            string           `json:"id,omitempty"`
	ExecutionType DONExecutionType `json:"executionType,omitempty"`
	Jobs          []*JobBasic      `json:"jobs,omitempty"`
}

type DeactivateBootstrapNodeInput struct {
	ID           string       `json:"id,omitempty"`
	ContractType ContractType `json:"contractType,omitempty"`
}

type DeactivateBootstrapNodePayload struct {
	Node   *Node   `json:"node,omitempty"`
	Errors []Error `json:"errors,omitempty"`
}

type DeleteContractInput struct {
	ChainID    string `json:"chainID,omitempty"`
	ContractID string `json:"contractID,omitempty"`
}

type DeleteContractPayload struct {
	Errors []Error `json:"errors,omitempty"`
}

type DeleteFeedInput struct {
	ID string `json:"id,omitempty"`
}

type DeleteFeedPayload struct {
	Feed   *Feed   `json:"feed,omitempty"`
	Errors []Error `json:"errors,omitempty"`
}

type DeleteJobInput struct {
	ID string `json:"id,omitempty"`
}

type DeleteJobPayload struct {
	Job    *Job    `json:"job,omitempty"`
	Errors []Error `json:"errors,omitempty"`
}

type DeleteNodeInput struct {
	ID string `json:"id,omitempty"`
}

type DeleteNodePayload struct {
	Node   *Node   `json:"node,omitempty"`
	Errors []Error `json:"errors,omitempty"`
}

type DeleteVaultInput struct {
	ID string `json:"id,omitempty"`
}

type DeleteVaultPayload struct {
	Vault  *Vault  `json:"vault,omitempty"`
	Errors []Error `json:"errors,omitempty"`
}

type DeleteWebhookInput struct {
	ID string `json:"id,omitempty"`
}

type DeleteWebhookPayload struct {
	Webhook *Webhook `json:"webhook,omitempty"`
	Errors  []Error  `json:"errors,omitempty"`
}

type DeleteWorkflowRunInput struct {
	WorkflowRunID string `json:"workflowRunID,omitempty"`
}

type DeleteWorkflowRunPayload struct {
	WorkflowRun *WorkflowRun `json:"workflowRun,omitempty"`
	Errors      []Error      `json:"errors,omitempty"`
}

type DeployContractInput struct {
	ChainID    string `json:"chainID,omitempty"`
	ContractID string `json:"contractID,omitempty"`
}

type DeployContractPayload struct {
	Errors      []Error      `json:"errors,omitempty"`
	WorkflowRun *WorkflowRun `json:"workflowRun,omitempty"`
}

type DeployMercuryV03NetworkStackInput struct {
	NetworkStackID string `json:"networkStackID,omitempty"`
}

type DeployMercuryV03NetworkStackPayload struct {
	WorkflowRun *WorkflowRun `json:"workflowRun,omitempty"`
	Errors      []Error      `json:"errors,omitempty"`
}

type DeploySetStorageContractInput struct {
	StorageID string `json:"storageID,omitempty"`
}

type DeploySetStorageContractPayload struct {
	WorkflowRun *WorkflowRun `json:"workflowRun,omitempty"`
	Errors      []Error      `json:"errors,omitempty"`
}

type DeployTokenInput struct {
	Symbol string `json:"symbol,omitempty"`
}

type DeployTokenPayload struct {
	WorkflowRunsAndContracts []*WorkflowRunAndContract `json:"workflowRunsAndContracts,omitempty"`
	Errors                   []Error                   `json:"errors,omitempty"`
}

type DeregisterTestTokenInput struct {
	LaneLegID string `json:"laneLegID,omitempty"`
}

type DeregisterTestTokenPayload struct {
	WorkflowRun *WorkflowRun `json:"workflowRun,omitempty"`
	Errors      []Error      `json:"errors,omitempty"`
}

type DisableNodeInput struct {
	ID string `json:"id,omitempty"`
}

type DisableNodePayload struct {
	Node   *Node   `json:"node,omitempty"`
	Errors []Error `json:"errors,omitempty"`
}

type DisableRelayerInput struct {
	ID string `json:"id,omitempty"`
}

type DisableRelayerPayload struct {
	Relayer *Relayer `json:"relayer,omitempty"`
	Errors  []Error  `json:"errors,omitempty"`
}

type DisableUserInput struct {
	ID string `json:"id,omitempty"`
}

type DisableUserPayload struct {
	User   *User   `json:"user,omitempty"`
	Errors []Error `json:"errors,omitempty"`
}

type EVMBridgedToken struct {
	Token         string         `json:"token,omitempty"`
	Address       string         `json:"address,omitempty"`
	TokenPoolType TokenPoolType  `json:"tokenPoolType,omitempty"`
	PriceType     TokenPriceType `json:"priceType,omitempty"`
	Price         *string        `json:"price,omitempty"`
	PriceFeed     *PriceFeed     `json:"priceFeed,omitempty"`
}

type EnableNodeInput struct {
	ID string `json:"id,omitempty"`
}

type EnableNodePayload struct {
	Node   *Node   `json:"node,omitempty"`
	Errors []Error `json:"errors,omitempty"`
}

type EnableRelayerInput struct {
	ID string `json:"id,omitempty"`
}

type EnableRelayerPayload struct {
	Relayer *Relayer `json:"relayer,omitempty"`
	Errors  []Error  `json:"errors,omitempty"`
}

type Feed struct {
	ID           string           `json:"id,omitempty"`
	Name         string           `json:"name,omitempty"`
	Status       FeedStatus       `json:"status,omitempty"`
	Network      *Network         `json:"network,omitempty"`
	Proxy        *AggregatorProxy `json:"proxy,omitempty"`
	Aggregators  []*Aggregator    `json:"aggregators,omitempty"`
	WorkflowRuns []*WorkflowRun   `json:"workflowRuns,omitempty"`
	CreatedAt    Time             `json:"createdAt,omitempty"`
}

type FeedsFilters struct {
	ChainID      *string    `json:"chainID,omitempty"`
	ChainType    *ChainType `json:"chainType,omitempty"`
	Name         *string    `json:"name,omitempty"`
	NetworkID    *string    `json:"networkID,omitempty"`
	ProxyAddress *string    `json:"proxyAddress,omitempty"`
	Limit        *string    `json:"limit,omitempty"`
	Offset       *string    `json:"offset,omitempty"`
}

type FeedsInput struct {
	Filter *FeedsFilters `json:"filter,omitempty"`
}

type GauntletReport struct {
	ID              string       `json:"id,omitempty"`
	TraceID         string       `json:"traceID,omitempty"`
	WorkflowRun     *WorkflowRun `json:"workflowRun,omitempty"`
	TransactionHash *string      `json:"transactionHash,omitempty"`
	ReportID        string       `json:"reportID,omitempty"`
	Timestamp       Time         `json:"timestamp,omitempty"`
	Op              string       `json:"op,omitempty"`
	Input           string       `json:"input,omitempty"`
	Output          *string      `json:"output,omitempty"`
	Requirements    *string      `json:"requirements,omitempty"`
	Config          string       `json:"config,omitempty"`
	Subops          *string      `json:"subops,omitempty"`
	Events          *string      `json:"events,omitempty"`
	Snapshot        *string      `json:"snapshot,omitempty"`
	Error           *string      `json:"error,omitempty"`
	TraceExtra      *string      `json:"traceExtra,omitempty"`
}

type GauntletReportsInput struct {
	TraceID         *string `json:"traceID,omitempty"`
	WorkflowRunID   *int    `json:"workflowRunID,omitempty"`
	TransactionHash *string `json:"transactionHash,omitempty"`
}

type ImportAggregatorInput struct {
	Name            string `json:"name,omitempty"`
	ContractAddress string `json:"contractAddress,omitempty"`
	Template        string `json:"template,omitempty"`
	CategoryID      string `json:"categoryID,omitempty"`
}

type ImportChainInput struct {
	NetworkID string `json:"networkID,omitempty"`
	Template  string `json:"template,omitempty"`
	// The Display Name lets a user differentiate multiple CCIP chains on the same network. It is not unique and used for display purposes only.
	DisplayName *string `json:"displayName,omitempty"`
}

type ImportChainPayload struct {
	Errors []Error    `json:"errors,omitempty"`
	Chain  *CCIPChain `json:"chain,omitempty"`
}

type ImportFeedAggregatorInput struct {
	FeedID     string                 `json:"feedID,omitempty"`
	Aggregator *ImportAggregatorInput `json:"aggregator,omitempty"`
}

type ImportFeedAggregatorPayload struct {
	Aggregator *Aggregator `json:"aggregator,omitempty"`
	Errors     []Error     `json:"errors,omitempty"`
}

type ImportFeedInput struct {
	Name        string                   `json:"name,omitempty"`
	NetworkID   string                   `json:"networkID,omitempty"`
	Proxy       *ImportProxyInput        `json:"proxy,omitempty"`
	Aggregators []*ImportAggregatorInput `json:"aggregators,omitempty"`
}

type ImportFeedPayload struct {
	Feed   *Feed   `json:"feed,omitempty"`
	Errors []Error `json:"errors,omitempty"`
}

type ImportKeystoneWorkflowInput struct {
	CategoryID string `json:"categoryID,omitempty"`
	NetworkID  string `json:"networkID,omitempty"`
	Template   string `json:"template,omitempty"`
}

type ImportKeystoneWorkflowPayload struct {
	Workflow *KeystoneWorkflow `json:"workflow,omitempty"`
	Errors   []Error           `json:"errors,omitempty"`
}

type ImportLaneInput struct {
	ChainAid string `json:"chainAID,omitempty"`
	ChainBid string `json:"chainBID,omitempty"`
	Template string `json:"template,omitempty"`
	// The Display Name lets a user differentiate multiple CCIP chains on the same network. It is not unique and used for display purposes only.
	DisplayName *string `json:"displayName,omitempty"`
}

type ImportLanePayload struct {
	Errors []Error   `json:"errors,omitempty"`
	Lane   *CCIPLane `json:"lane,omitempty"`
}

type ImportMercuryFeedInput struct {
	Name           string `json:"name,omitempty"`
	ExternalFeedID string `json:"externalFeedID,omitempty"`
	NetworkStackID string `json:"networkStackID,omitempty"`
	FromBlock      string `json:"fromBlock,omitempty"`
	Template       string `json:"template,omitempty"`
}

type ImportMercuryFeedPayload struct {
	Feed   *MercuryFeed `json:"feed,omitempty"`
	Errors []Error      `json:"errors,omitempty"`
}

type ImportMercuryV03FeedInput struct {
	Name           string `json:"name,omitempty"`
	ExternalFeedID string `json:"externalFeedID,omitempty"`
	Template       string `json:"template,omitempty"`
	CategoryID     string `json:"categoryID,omitempty"`
}

type ImportMercuryV03FeedPayload struct {
	Feed   *MercuryV03Feed `json:"feed,omitempty"`
	Errors []Error         `json:"errors,omitempty"`
}

type ImportMercuryV03NetworkStackInput struct {
	NetworkID            string  `json:"networkID,omitempty"`
	VerifierAddress      string  `json:"verifierAddress,omitempty"`
	VerifierProxyAddress string  `json:"verifierProxyAddress,omitempty"`
	RewardBankAddress    string  `json:"rewardBankAddress,omitempty"`
	FeeManagerAddress    string  `json:"feeManagerAddress,omitempty"`
	MercuryServerURL     string  `json:"mercuryServerURL,omitempty"`
	MercuryServerPubKey  string  `json:"mercuryServerPubKey,omitempty"`
	Servers              *string `json:"servers,omitempty"`
}

type ImportMercuryV03NetworkStackPayload struct {
	NetworkStack *MercuryV03NetworkStack `json:"networkStack,omitempty"`
	Errors       []Error                 `json:"errors,omitempty"`
}

type ImportOCR3CapabilityInput struct {
	CategoryID string `json:"categoryID,omitempty"`
	NetworkID  string `json:"networkID,omitempty"`
	Template   string `json:"template,omitempty"`
}

type ImportOCR3CapabilityPayload struct {
	Ocr3Capability *OCR3Capability `json:"ocr3Capability,omitempty"`
	Errors         []Error         `json:"errors,omitempty"`
}

type ImportProxyInput struct {
	ContractAddress         string  `json:"contractAddress,omitempty"`
	AccessControllerAddress *string `json:"accessControllerAddress,omitempty"`
	AggregatorAddress       string  `json:"aggregatorAddress,omitempty"`
}

type ImportTokenPoolInput struct {
	ID       string `json:"id,omitempty"`
	Template string `json:"template,omitempty"`
}

type ImportTokenPoolPayload struct {
	Errors []Error    `json:"errors,omitempty"`
	Chain  *CCIPChain `json:"chain,omitempty"`
}

type Job struct {
	ID              string          `json:"id,omitempty"`
	UUID            string          `json:"uuid,omitempty"`
	Type            JobType         `json:"type,omitempty"`
	Ocr2PluginType  *OCR2PluginType `json:"ocr2PluginType,omitempty"`
	Status          JobStatus       `json:"status,omitempty"`
	NodeOperator    *NodeOperator   `json:"nodeOperator,omitempty"`
	Node            *Node           `json:"node,omitempty"`
	IsBootstrap     bool            `json:"isBootstrap,omitempty"`
	Config          JobConfig       `json:"config,omitempty"`
	Spec            *string         `json:"spec,omitempty"`
	ProposalChanged bool            `json:"proposalChanged,omitempty"`
	AssignableNodes []*Node         `json:"assignableNodes,omitempty"`
	CanPropose      bool            `json:"canPropose,omitempty"`
	CanRevoke       bool            `json:"canRevoke,omitempty"`
	Proposals       []*JobProposal  `json:"proposals,omitempty"`
	CreatedAt       Time            `json:"createdAt,omitempty"`
}

type JobBasic struct {
	ID             string          `json:"id,omitempty"`
	UUID           string          `json:"uuid,omitempty"`
	Type           JobType         `json:"type,omitempty"`
	Ocr2PluginType *OCR2PluginType `json:"ocr2PluginType,omitempty"`
	Status         JobStatus       `json:"status,omitempty"`
	IsBootstrap    bool            `json:"isBootstrap,omitempty"`
}

type JobConfigEmpty struct {
	Empty bool `json:"_empty,omitempty"`
}

func (JobConfigEmpty) IsJobConfig() {}

type JobConfigEmptyInput struct {
	Empty *bool `json:"_empty,omitempty"`
}

type JobConfigInput struct {
	Ocr1               *JobConfigOCR1Input        `json:"ocr1,omitempty"`
	Ocr2Median         *JobConfigOCR2MedianInput  `json:"ocr2Median,omitempty"`
	Ocr2Mercury        *JobConfigOCR2MercuryInput `json:"ocr2Mercury,omitempty"`
	Ocr2CCIPCommit     *JobConfigEmptyInput       `json:"ocr2CCIPCommit,omitempty"`
	Ocr2CCIPExecution  *JobConfigEmptyInput       `json:"ocr2CCIPExecution,omitempty"`
	Ocr2CCIPRebalancer *JobConfigEmptyInput       `json:"ocr2CCIPRebalancer,omitempty"`
}

type JobConfigOcr1 struct {
	Apis []string `json:"apis,omitempty"`
}

func (JobConfigOcr1) IsJobConfig() {}

type JobConfigOCR1Input struct {
	Apis []string `json:"apis,omitempty"`
}

type JobConfigOCR2Median struct {
	Apis []string `json:"apis,omitempty"`
}

func (JobConfigOCR2Median) IsJobConfig() {}

type JobConfigOCR2MedianInput struct {
	Apis []string `json:"apis,omitempty"`
}

type JobConfigOCR2Mercury struct {
	Apis []string `json:"apis,omitempty"`
}

func (JobConfigOCR2Mercury) IsJobConfig() {}

type JobConfigOCR2MercuryInput struct {
	Apis      []string `json:"apis,omitempty"`
	CrossApis []string `json:"crossApis,omitempty"`
}

type JobProposal struct {
	ID                 string            `json:"id,omitempty"`
	Version            string            `json:"version,omitempty"`
	Status             JobProposalStatus `json:"status,omitempty"`
	Spec               string            `json:"spec,omitempty"`
	Job                *Job              `json:"job,omitempty"`
	CreatedAt          Time              `json:"createdAt,omitempty"`
	UpdatedAt          Time              `json:"updatedAt,omitempty"`
	ProposedAt         *Time             `json:"proposedAt,omitempty"`
	ResponseReceivedAt *Time             `json:"responseReceivedAt,omitempty"`
}

type KeystoneWorkflow struct {
	ID                 string    `json:"id,omitempty"`
	WorkflowSpec       string    `json:"workflowSpec,omitempty"`
	WorkflowOwner      string    `json:"workflowOwner,omitempty"`
	ExternalWorkflowID string    `json:"externalWorkflowID,omitempty"`
	Don                *Don      `json:"don,omitempty"`
	Name               string    `json:"name,omitempty"`
	Category           *Category `json:"category,omitempty"`
}

type KeystoneWorkflowMutations struct {
	ImportWorkflow *ImportKeystoneWorkflowPayload `json:"importWorkflow,omitempty"`
	UpdateWorkflow *UpdateKeystoneWorkflowPayload `json:"updateWorkflow,omitempty"`
}

type KeystoneWorkflowQueries struct {
	Workflow  *KeystoneWorkflow   `json:"workflow,omitempty"`
	Workflows []*KeystoneWorkflow `json:"workflows,omitempty"`
}

type ListAggregatorsFilter struct {
	NetworkID       *string `json:"networkID,omitempty"`
	ContractAddress *string `json:"contractAddress,omitempty"`
}

type ListRelayersFilter struct {
	Enabled *bool `json:"enabled,omitempty"`
}

type ListWebhookCallsFilter struct {
	State *WebhookCallState `json:"state,omitempty"`
}

type LoginInput struct {
	Email    string `json:"email,omitempty"`
	Password string `json:"password,omitempty"`
}

type LoginPayload struct {
	Session *Session `json:"session,omitempty"`
	Errors  []Error  `json:"errors,omitempty"`
}

type LogoutPayload struct {
	Session *Session `json:"session,omitempty"`
}

type MarkStaleJobsInput struct {
	Ids []string `json:"ids,omitempty"`
}

type MarkStaleJobsPayload struct {
	Jobs   []*Job  `json:"jobs,omitempty"`
	Errors []Error `json:"errors,omitempty"`
}

type MercuryFeed struct {
	ID             string               `json:"id,omitempty"`
	Name           string               `json:"name,omitempty"`
	ExternalFeedID string               `json:"externalFeedID,omitempty"`
	NetworkStack   *MercuryNetworkStack `json:"networkStack,omitempty"`
	FromBlock      string               `json:"fromBlock,omitempty"`
	Template       string               `json:"template,omitempty"`
	Don            *Don                 `json:"don,omitempty"`
	CreatedAt      Time                 `json:"createdAt,omitempty"`
	UpdatedAt      Time                 `json:"updatedAt,omitempty"`
}

type MercuryFeedsFilters struct {
	Name                 *string `json:"name,omitempty"`
	NetworkID            *string `json:"networkID,omitempty"`
	VerifierProxyAddress *string `json:"verifierProxyAddress,omitempty"`
	Limit                *string `json:"limit,omitempty"`
	Offset               *string `json:"offset,omitempty"`
}

type MercuryFeedsInput struct {
	Filter *MercuryFeedsFilters `json:"filter,omitempty"`
}

type MercuryMutations struct {
	CreateNetworkStack *CreateMercuryNetworkStackPayload `json:"createNetworkStack,omitempty"`
	ImportFeed         *ImportMercuryFeedPayload         `json:"importFeed,omitempty"`
	UpdateFeed         *UpdateMercuryFeedPayload         `json:"updateFeed,omitempty"`
	UpdateNetworkStack *UpdateMercuryNetworkStackPayload `json:"updateNetworkStack,omitempty"`
}

type MercuryNetworkStack struct {
	ID                   string           `json:"id,omitempty"`
	Network              *Network         `json:"network,omitempty"`
	VerifierAddress      string           `json:"verifierAddress,omitempty"`
	VerifierProxyAddress string           `json:"verifierProxyAddress,omitempty"`
	ServerURL            string           `json:"serverURL,omitempty"`
	ServerPublicKey      string           `json:"serverPublicKey,omitempty"`
	CreatedAt            Time             `json:"createdAt,omitempty"`
	UpdatedAt            Time             `json:"updatedAt,omitempty"`
	Servers              []*MercuryServer `json:"servers,omitempty"`
}

type MercuryQueries struct {
	NetworkStacks []*MercuryNetworkStack `json:"networkStacks,omitempty"`
	NetworkStack  *MercuryNetworkStack   `json:"networkStack,omitempty"`
	Feed          *MercuryFeed           `json:"feed,omitempty"`
	Feeds         []*MercuryFeed         `json:"feeds,omitempty"`
}

type MercuryServer struct {
	URL       string `json:"url,omitempty"`
	PublicKey string `json:"publicKey,omitempty"`
}

type MercuryV03Feed struct {
	ID                  string                `json:"id,omitempty"`
	Name                string                `json:"name,omitempty"`
	ExternalFeedID      string                `json:"externalFeedID,omitempty"`
	Verifiers           []*MercuryV03Verifier `json:"verifiers,omitempty"`
	ReportSchemaVersion ReportSchemaVersion   `json:"reportSchemaVersion,omitempty"`
	Template            string                `json:"template,omitempty"`
	Don                 *Don                  `json:"don,omitempty"`
	CreatedAt           Time                  `json:"createdAt,omitempty"`
	UpdatedAt           Time                  `json:"updatedAt,omitempty"`
	ArchivedAt          *Time                 `json:"archivedAt,omitempty"`
	Category            *Category             `json:"category,omitempty"`
}

type MercuryV03FeedFilter struct {
	IsArchived       *bool `json:"isArchived,omitempty"`
	TransmitToServer *bool `json:"transmitToServer,omitempty"`
}

type MercuryV03Mutations struct {
	ArchiveFeed                *ArchiveFeedPayload                  `json:"archiveFeed,omitempty"`
	ArchiveNetworkStack        *ArchiveNetworkStackPayload          `json:"archiveNetworkStack,omitempty"`
	AddVerificationProvider    *AddVerificationProviderPayload      `json:"addVerificationProvider,omitempty"`
	RemoveVerificationProvider *RemoveVerificationProviderPayload   `json:"removeVerificationProvider,omitempty"`
	AddNetworkStack            *AddMercuryV03NetworkStackPayload    `json:"addNetworkStack,omitempty"`
	DeployNetworkStack         *DeployMercuryV03NetworkStackPayload `json:"deployNetworkStack,omitempty"`
	ImportFeed                 *ImportMercuryV03FeedPayload         `json:"importFeed,omitempty"`
	ImportNetworkStack         *ImportMercuryV03NetworkStackPayload `json:"importNetworkStack,omitempty"`
	TransferOwnership          *TransferOwnershipPayload            `json:"transferOwnership,omitempty"`
	UpdateNetworkStack         *UpdateMercuryV03NetworkStackPayload `json:"updateNetworkStack,omitempty"`
	UpdateFeed                 *UpdateMercuryV03FeedPayload         `json:"updateFeed,omitempty"`
	VerifyContract             *VerifyMercuryV03ContractPayload     `json:"verifyContract,omitempty"`
}

type MercuryV03NetworkStack struct {
	ID                   string             `json:"id,omitempty"`
	Network              *Network           `json:"network,omitempty"`
	Status               NetworkStackStatus `json:"status,omitempty"`
	VerifierAddress      *string            `json:"verifierAddress,omitempty"`
	VerifierProxyAddress *string            `json:"verifierProxyAddress,omitempty"`
	RewardBankAddress    *string            `json:"rewardBankAddress,omitempty"`
	FeeManagerAddress    *string            `json:"feeManagerAddress,omitempty"`
	MercuryServerURL     string             `json:"mercuryServerURL,omitempty"`
	MercuryServerPubKey  string             `json:"mercuryServerPubKey,omitempty"`
	Contracts            []*Contract        `json:"contracts,omitempty"`
	WorkflowRuns         []*WorkflowRun     `json:"workflowRuns,omitempty"`
	CreatedAt            Time               `json:"createdAt,omitempty"`
	UpdatedAt            Time               `json:"updatedAt,omitempty"`
	ArchivedAt           *Time              `json:"archivedAt,omitempty"`
	Servers              []*MercuryServer   `json:"servers,omitempty"`
}

type MercuryV03NetworkStackFilter struct {
	IsArchived *bool `json:"isArchived,omitempty"`
}

type MercuryV03Queries struct {
	NetworkStack  *MercuryV03NetworkStack   `json:"networkStack,omitempty"`
	NetworkStacks []*MercuryV03NetworkStack `json:"networkStacks,omitempty"`
	Feed          *MercuryV03Feed           `json:"feed,omitempty"`
	Feeds         []*MercuryV03Feed         `json:"feeds,omitempty"`
}

type MercuryV03Verifier struct {
	ID               string                  `json:"id,omitempty"`
	NetworkStack     *MercuryV03NetworkStack `json:"networkStack,omitempty"`
	NetworkStackType NetworkStackType        `json:"networkStackType,omitempty"`
}

type Mutation struct {
}

type Network struct {
	ID                                    string     `json:"id,omitempty"`
	ChainID                               string     `json:"chainID,omitempty"`
	ChainType                             ChainType  `json:"chainType,omitempty"`
	Name                                  string     `json:"name,omitempty"`
	NativeToken                           string     `json:"nativeToken,omitempty"`
	Archived                              bool       `json:"archived,omitempty"`
	NativeTokenContractAddress            *string    `json:"nativeTokenContractAddress,omitempty"`
	ConfigContractAddress                 *string    `json:"configContractAddress,omitempty"`
	LinkUSDProxyAddress                   *string    `json:"linkUSDProxyAddress,omitempty"`
	NativeUSDProxyAddress                 *string    `json:"nativeUSDProxyAddress,omitempty"`
	LinkContractAddress                   *string    `json:"linkContractAddress,omitempty"`
	FlagsContractAddress                  *string    `json:"flagsContractAddress,omitempty"`
	LinkFunding                           string     `json:"linkFunding,omitempty"`
	BillingAdminAccessControllerAddress   *string    `json:"billingAdminAccessControllerAddress,omitempty"`
	RequesterAdminAccessControllerAddress *string    `json:"requesterAdminAccessControllerAddress,omitempty"`
	IconName                              *string    `json:"iconName,omitempty"`
	ExplorerURL                           *string    `json:"explorerURL,omitempty"`
	Relayers                              []*Relayer `json:"relayers,omitempty"`
	Vaults                                []*Vault   `json:"vaults,omitempty"`
	ExplorerAPIKey                        *string    `json:"explorerAPIKey,omitempty"`
	ExplorerAPIURL                        *string    `json:"explorerAPIURL,omitempty"`
}

type NetworksFilters struct {
	Archived  *bool      `json:"archived,omitempty"`
	ChainID   *string    `json:"chainID,omitempty"`
	ChainType *ChainType `json:"chainType,omitempty"`
	Name      *string    `json:"name,omitempty"`
}

type NetworksInput struct {
	Filter *NetworksFilters `json:"filter,omitempty"`
}

type Node struct {
	ID                string             `json:"id,omitempty"`
	Name              string             `json:"name,omitempty"`
	PublicKey         *string            `json:"publicKey,omitempty"`
	ChainConfigs      []*NodeChainConfig `json:"chainConfigs,omitempty"`
	Connected         bool               `json:"connected,omitempty"`
	Enabled           bool               `json:"enabled,omitempty"`
	Metadata          *NodeMetadata      `json:"metadata,omitempty"`
	NodeOperator      *NodeOperator      `json:"nodeOperator,omitempty"`
	Version           *string            `json:"version,omitempty"`
	SupportedProducts []ProductType      `json:"supportedProducts,omitempty"`
	Categories        []*Category        `json:"categories,omitempty"`
	CreatedAt         Time               `json:"createdAt,omitempty"`
}

type NodeChainConfig struct {
	ID                    string          `json:"id,omitempty"`
	Network               *Network        `json:"network,omitempty"`
	AccountAddress        string          `json:"accountAddress,omitempty"`
	AdminAddress          string          `json:"adminAddress,omitempty"`
	Ocr1Config            *NodeOCR1Config `json:"ocr1Config,omitempty"`
	Ocr1BootstrapVerified bool            `json:"ocr1BootstrapVerified,omitempty"`
	Ocr2Config            *NodeOCR2Config `json:"ocr2Config,omitempty"`
	Ocr2BootstrapVerified bool            `json:"ocr2BootstrapVerified,omitempty"`
	CreatedAt             Time            `json:"createdAt,omitempty"`
}

type NodeConnectionInfo struct {
	PublicKey string `json:"publicKey,omitempty"`
	RPCURL    string `json:"rpcURL,omitempty"`
}

type NodeMetadata struct {
	JobCount int `json:"jobCount,omitempty"`
}

type NodeOCR1Config struct {
	Enabled      bool                        `json:"enabled,omitempty"`
	IsBootstrap  bool                        `json:"isBootstrap,omitempty"`
	Multiaddr    *string                     `json:"multiaddr,omitempty"`
	P2pKeyBundle *NodeOCR1ConfigP2PKeyBundle `json:"p2pKeyBundle,omitempty"`
	OcrKeyBundle *NodeOCR1ConfigOCRKeyBundle `json:"ocrKeyBundle,omitempty"`
}

type NodeOCR1ConfigOCRKeyBundle struct {
	BundleID              string `json:"bundleID,omitempty"`
	ConfigPublicKey       string `json:"configPublicKey,omitempty"`
	OffchainPublicKey     string `json:"offchainPublicKey,omitempty"`
	OnchainSigningAddress string `json:"onchainSigningAddress,omitempty"`
}

type NodeOCR1ConfigP2PKeyBundle struct {
	PeerID    string `json:"peerID,omitempty"`
	PublicKey string `json:"publicKey,omitempty"`
}

type NodeOCR2Config struct {
	Enabled          bool                        `json:"enabled,omitempty"`
	IsBootstrap      bool                        `json:"isBootstrap,omitempty"`
	Multiaddr        *string                     `json:"multiaddr,omitempty"`
	ForwarderAddress *string                     `json:"forwarderAddress,omitempty"`
	P2pKeyBundle     *NodeOCR2ConfigP2PKeyBundle `json:"p2pKeyBundle,omitempty"`
	OcrKeyBundle     *NodeOCR2ConfigOCRKeyBundle `json:"ocrKeyBundle,omitempty"`
	Plugins          *NodeOCR2ConfigPlugins      `json:"plugins,omitempty"`
}

type NodeOCR2ConfigOCRKeyBundle struct {
	BundleID              string `json:"bundleID,omitempty"`
	ConfigPublicKey       string `json:"configPublicKey,omitempty"`
	OffchainPublicKey     string `json:"offchainPublicKey,omitempty"`
	OnchainSigningAddress string `json:"onchainSigningAddress,omitempty"`
}

type NodeOCR2ConfigP2PKeyBundle struct {
	PeerID    string `json:"peerID,omitempty"`
	PublicKey string `json:"publicKey,omitempty"`
}

type NodeOCR2ConfigPlugins struct {
	CcipCommit     bool `json:"ccipCommit,omitempty"`
	CcipExecution  bool `json:"ccipExecution,omitempty"`
	CcipRebalancer bool `json:"ccipRebalancer,omitempty"`
	Median         bool `json:"median,omitempty"`
	Mercury        bool `json:"mercury,omitempty"`
}

type NodeOperator struct {
	ID        string                `json:"id,omitempty"`
	Keys      []string              `json:"keys,omitempty"`
	Name      string                `json:"name,omitempty"`
	Email     string                `json:"email,omitempty"`
	Website   string                `json:"website,omitempty"`
	Metadata  *NodeOperatorMetadata `json:"metadata,omitempty"`
	Nodes     []*Node               `json:"nodes,omitempty"`
	CreatedAt Time                  `json:"createdAt,omitempty"`
}

type NodeOperatorMetadata struct {
	NodeCount int `json:"nodeCount,omitempty"`
	JobCount  int `json:"jobCount,omitempty"`
}

type NodesFilters struct {
	NetworkID *string `json:"networkID,omitempty"`
}

type NodesInput struct {
	Filter *NodesFilters `json:"filter,omitempty"`
}

type OCR3Capability struct {
	ID                  string    `json:"id,omitempty"`
	ContractAddress     string    `json:"contractAddress,omitempty"`
	Name                string    `json:"name,omitempty"`
	BootstrapMultiaddrs []string  `json:"bootstrapMultiaddrs,omitempty"`
	Template            string    `json:"template,omitempty"`
	Category            *Category `json:"category,omitempty"`
	Don                 *Don      `json:"don,omitempty"`
}

type OCR3CapabilityMutations struct {
	ImportOCR3Capability *ImportOCR3CapabilityPayload `json:"importOCR3Capability,omitempty"`
	UpdateOCR3Capability *UpdateOCR3CapabilityPayload `json:"updateOCR3Capability,omitempty"`
}

type OCR3CapabilityQueries struct {
	Ocr3Capability   *OCR3Capability   `json:"ocr3Capability,omitempty"`
	Ocr3Capabilities []*OCR3Capability `json:"ocr3Capabilities,omitempty"`
}

type PriceFeed struct {
	AggregatorAddress string `json:"aggregatorAddress,omitempty"`
	Multiplier        string `json:"multiplier,omitempty"`
}

type Profile struct {
	ID        string   `json:"id,omitempty"`
	Name      string   `json:"name,omitempty"`
	Email     string   `json:"email,omitempty"`
	Role      UserRole `json:"role,omitempty"`
	Permits   []string `json:"permits,omitempty"`
	CreatedAt Time     `json:"createdAt,omitempty"`
}

type ProposeJobInput struct {
	ID string `json:"id,omitempty"`
}

type ProposeJobPayload struct {
	Job    *Job    `json:"job,omitempty"`
	Errors []Error `json:"errors,omitempty"`
}

type Query struct {
}

type ReadAccessController struct {
	Address string `json:"address,omitempty"`
}

type Relayer struct {
	ID        string            `json:"id,omitempty"`
	Name      string            `json:"name,omitempty"`
	URL       *URL              `json:"url,omitempty"`
	Config    string            `json:"config,omitempty"`
	IsEnabled bool              `json:"isEnabled,omitempty"`
	Network   *Network          `json:"network,omitempty"`
	Accounts  []*RelayerAccount `json:"accounts,omitempty"`
}

type RelayerAccount struct {
	ID            string   `json:"id,omitempty"`
	Relayer       *Relayer `json:"relayer,omitempty"`
	Address       string   `json:"address,omitempty"`
	NativeBalance string   `json:"nativeBalance,omitempty"`
	LinkBalance   string   `json:"linkBalance,omitempty"`
}

type RelayerURL struct {
	Websocket string `json:"websocket,omitempty"`
	HTTP      string `json:"http,omitempty"`
}

type RemoveLiquidityInput struct {
	ChainID             string `json:"chainID,omitempty"`
	TokenPoolContractID string `json:"tokenPoolContractID,omitempty"`
	Amount              string `json:"amount,omitempty"`
}

type RemoveLiquidityPayload struct {
	Errors      []Error      `json:"errors,omitempty"`
	WorkflowRun *WorkflowRun `json:"workflowRun,omitempty"`
}

type RemoveVerificationProviderInput struct {
	FeedID         string `json:"feedID,omitempty"`
	NetworkStackID string `json:"networkStackID,omitempty"`
}

type RemoveVerificationProviderPayload struct {
	Feed   *MercuryV03Feed `json:"feed,omitempty"`
	Errors []Error         `json:"errors,omitempty"`
}

type RetryActionRunInput struct {
	ActionRunID string `json:"actionRunID,omitempty"`
}

type RetryActionRunPayload struct {
	Status ActionRunStatus `json:"status,omitempty"`
	Errors []Error         `json:"errors,omitempty"`
}

type RetryWebhookCallInput struct {
	WebhookCallID string `json:"webhookCallID,omitempty"`
}

type RetryWebhookCallPayload struct {
	WebhookCall *WebhookCall `json:"webhookCall,omitempty"`
	Errors      []Error      `json:"errors,omitempty"`
}

type RevokeJobInput struct {
	ID string `json:"id,omitempty"`
}

type RevokeJobPayload struct {
	Job    *Job    `json:"job,omitempty"`
	Errors []Error `json:"errors,omitempty"`
}

type Role struct {
	ID      string   `json:"id,omitempty"`
	Name    string   `json:"name,omitempty"`
	Permits []string `json:"permits,omitempty"`
}

type RunCCIPCommandInput struct {
	Command   CCIPCommand `json:"command,omitempty"`
	LaneLegID string      `json:"laneLegID,omitempty"`
	Upgrade   *bool       `json:"upgrade,omitempty"`
}

type RunCCIPCommandPayload struct {
	Errors      []Error      `json:"errors,omitempty"`
	WorkflowRun *WorkflowRun `json:"workflowRun,omitempty"`
}

type SendTestWebhookEventInput struct {
	WebhookID string `json:"webhookID,omitempty"`
}

type SendTestWebhookEventPayload struct {
	WebhookCall *WebhookCall `json:"webhookCall,omitempty"`
	Errors      []Error      `json:"errors,omitempty"`
}

type Session struct {
	ID        string   `json:"id,omitempty"`
	Token     string   `json:"token,omitempty"`
	ExpiresAt Time     `json:"expiresAt,omitempty"`
	Revoked   bool     `json:"revoked,omitempty"`
	Permits   []string `json:"permits,omitempty"`
}

type SetAllowListTokenPoolInput struct {
	ChainID             string   `json:"chainID,omitempty"`
	TokenPoolContractID string   `json:"tokenPoolContractID,omitempty"`
	AllowList           []string `json:"allowList,omitempty"`
}

type SetAllowListTokenPoolPayload struct {
	Errors      []Error      `json:"errors,omitempty"`
	WorkflowRun *WorkflowRun `json:"workflowRun,omitempty"`
}

type SetPasswordInput struct {
	UserID   string `json:"userID,omitempty"`
	Password string `json:"password,omitempty"`
}

type SetPasswordPayload struct {
	Errors []Error `json:"errors,omitempty"`
}

type SetupAppInput struct {
	Token    string `json:"token,omitempty"`
	Email    string `json:"email,omitempty"`
	Name     string `json:"name,omitempty"`
	Password string `json:"password,omitempty"`
}

type SetupAppPayload struct {
	Errors []Error `json:"errors,omitempty"`
}

type SpecConfigOffChainReporting1 struct {
	Decimals int `json:"decimals,omitempty"`
}

func (SpecConfigOffChainReporting1) IsAggregatorSpecConfig() {}

type SpecConfigOffChainReporting2 struct {
	Decimals int `json:"decimals,omitempty"`
}

func (SpecConfigOffChainReporting2) IsAggregatorSpecConfig() {}

type StorageContract struct {
	ID           string         `json:"id,omitempty"`
	Network      *Network       `json:"network,omitempty"`
	DisplayName  *string        `json:"displayName,omitempty"`
	Template     string         `json:"template,omitempty"`
	Contract     *Contract      `json:"contract,omitempty"`
	WorkflowRuns []*WorkflowRun `json:"workflowRuns,omitempty"`
}

type StorageContractFilter struct {
	NetworkID *string `json:"networkID,omitempty"`
}

// Grouping of all mutations related to the Storage contract resource.
type StorageMutations struct {
	// addStorageContract adds a new storage contract to the database and creates
	// a single new resource.
	AddStorageContract *AddStorageContractPayload `json:"addStorageContract,omitempty"`
	// deploySetStorageContract deploys a new storage contract to the network and
	// sets the value on chain to the value provided from the template of the storage.
	DeploySetStorageContract *DeploySetStorageContractPayload `json:"deploySetStorageContract,omitempty"`
}

// Grouping of all queries related to the Storage contract resource.
type StorageQueries struct {
	StorageContracts []*StorageContract `json:"storageContracts,omitempty"`
	StorageContract  *StorageContract   `json:"storageContract,omitempty"`
}

type SyncAggregatorInput struct {
	ID string `json:"id,omitempty"`
}

type SyncAggregatorPayload struct {
	Aggregator *Aggregator `json:"aggregator,omitempty"`
	Errors     []Error     `json:"errors,omitempty"`
}

type SyncAggregatorProxyInput struct {
	ID string `json:"id,omitempty"`
}

type SyncAggregatorProxyPayload struct {
	AggregatorProxy *AggregatorProxy `json:"aggregatorProxy,omitempty"`
	Errors          []Error          `json:"errors,omitempty"`
}

type SyncChainInput struct {
	ChainID string `json:"chainID,omitempty"`
}

type SyncChainPayload struct {
	Chain  *CCIPChain `json:"chain,omitempty"`
	Errors []Error    `json:"errors,omitempty"`
}

type SyncContractsInput struct {
	ContractIDs []string `json:"contractIDs,omitempty"`
}

type SyncContractsPayload struct {
	Contracts []*Contract `json:"contracts,omitempty"`
	Errors    []Error     `json:"errors,omitempty"`
}

type SyncLaneInput struct {
	LaneID string `json:"laneID,omitempty"`
}

type SyncLanePayload struct {
	Lane   *CCIPLane `json:"lane,omitempty"`
	Errors []Error   `json:"errors,omitempty"`
}

type Task struct {
	Name string   `json:"name,omitempty"`
	Run  *TaskRun `json:"run,omitempty"`
}

type TaskRun struct {
	ID     string        `json:"id,omitempty"`
	Input  string        `json:"input,omitempty"`
	Output string        `json:"output,omitempty"`
	Status TaskRunStatus `json:"status,omitempty"`
	Error  *string       `json:"error,omitempty"`
	TxHash *string       `json:"txHash,omitempty"`
}

type Token struct {
	Symbol  string `json:"symbol,omitempty"`
	Address string `json:"address,omitempty"`
}

type TransferAdminRoleInput struct {
	TokenAdminRegistryID string `json:"tokenAdminRegistryID,omitempty"`
	TokenPoolID          string `json:"tokenPoolID,omitempty"`
	VaultID              string `json:"vaultID,omitempty"`
}

type TransferAdminRolePayload struct {
	Errors      []Error      `json:"errors,omitempty"`
	WorkflowRun *WorkflowRun `json:"workflowRun,omitempty"`
}

type TransferOwnershipInput struct {
	ContractIDs []string `json:"contractIDs,omitempty"`
	VaultID     string   `json:"vaultID,omitempty"`
}

type TransferOwnershipPayload struct {
	Errors      []Error      `json:"errors,omitempty"`
	WorkflowRun *WorkflowRun `json:"workflowRun,omitempty"`
}

type URL struct {
	Websocket string  `json:"websocket,omitempty"`
	HTTP      *string `json:"http,omitempty"`
}

type UnarchiveNetworkInput struct {
	ID string `json:"id,omitempty"`
}

type UnarchiveNetworkPayload struct {
	Network *Network `json:"network,omitempty"`
	Errors  []Error  `json:"errors,omitempty"`
}

type UpdateAggregatorDetailsInput struct {
	ID         string `json:"id,omitempty"`
	Name       string `json:"name,omitempty"`
	CategoryID string `json:"categoryID,omitempty"`
}

type UpdateAggregatorDetailsPayload struct {
	Aggregator *Aggregator `json:"aggregator,omitempty"`
	Errors     []Error     `json:"errors,omitempty"`
}

type UpdateAggregatorInput struct {
	ID                 string  `json:"id,omitempty"`
	AggregatorTemplate *string `json:"aggregatorTemplate,omitempty"`
}

type UpdateAggregatorPayload struct {
	Aggregator *Aggregator `json:"aggregator,omitempty"`
	Errors     []Error     `json:"errors,omitempty"`
}

type UpdateAggregatorProxyInput struct {
	ID              string `json:"id,omitempty"`
	ContractAddress string `json:"contractAddress,omitempty"`
}

type UpdateAggregatorProxyPayload struct {
	ID     string  `json:"id,omitempty"`
	Errors []Error `json:"errors,omitempty"`
}

type UpdateCCIPChainInput struct {
	ID       string `json:"id,omitempty"`
	Template string `json:"template,omitempty"`
}

type UpdateCCIPChainPayload struct {
	Chain  *CCIPChain `json:"chain,omitempty"`
	Errors []Error    `json:"errors,omitempty"`
}

type UpdateCategoryInput struct {
	ID    string  `json:"id,omitempty"`
	Name  string  `json:"name,omitempty"`
	Color *string `json:"color,omitempty"`
}

type UpdateCategoryPayload struct {
	Category *Category `json:"category,omitempty"`
	Errors   []Error   `json:"errors,omitempty"`
}

type UpdateFeedInput struct {
	ID   string `json:"id,omitempty"`
	Name string `json:"name,omitempty"`
}

type UpdateFeedPayload struct {
	Feed   *Feed   `json:"feed,omitempty"`
	Errors []Error `json:"errors,omitempty"`
}

type UpdateKeystoneWorkflowInput struct {
	ID         string `json:"id,omitempty"`
	Template   string `json:"template,omitempty"`
	CategoryID string `json:"categoryID,omitempty"`
}

type UpdateKeystoneWorkflowPayload struct {
	Workflow *KeystoneWorkflow `json:"workflow,omitempty"`
	Errors   []Error           `json:"errors,omitempty"`
}

type UpdateLaneInput struct {
	Template          *string                   `json:"template,omitempty"`
	UpdateStartBlocks *bool                     `json:"updateStartBlocks,omitempty"`
	LegA              *CCIPLaneChainUpdateInput `json:"legA,omitempty"`
	LegB              *CCIPLaneChainUpdateInput `json:"legB,omitempty"`
}

type UpdateLanePayload struct {
	Errors []Error   `json:"errors,omitempty"`
	Lane   *CCIPLane `json:"lane,omitempty"`
}

type UpdateMercuryFeedInput struct {
	ID        string  `json:"id,omitempty"`
	FromBlock string  `json:"fromBlock,omitempty"`
	Template  *string `json:"template,omitempty"`
}

type UpdateMercuryFeedPayload struct {
	Feed   *MercuryFeed `json:"feed,omitempty"`
	Errors []Error      `json:"errors,omitempty"`
}

type UpdateMercuryNetworkStackInput struct {
	ID                   string  `json:"id,omitempty"`
	VerifierAddress      string  `json:"verifierAddress,omitempty"`
	VerifierProxyAddress string  `json:"verifierProxyAddress,omitempty"`
	ServerURL            string  `json:"serverURL,omitempty"`
	ServerPublicKey      string  `json:"serverPublicKey,omitempty"`
	Servers              *string `json:"servers,omitempty"`
}

type UpdateMercuryNetworkStackPayload struct {
	NetworkStack *MercuryNetworkStack `json:"networkStack,omitempty"`
	Errors       []Error              `json:"errors,omitempty"`
}

type UpdateMercuryV03FeedInput struct {
	ID         string `json:"id,omitempty"`
	Template   string `json:"template,omitempty"`
	CategoryID string `json:"categoryID,omitempty"`
}

type UpdateMercuryV03FeedPayload struct {
	Feed   *MercuryV03Feed `json:"feed,omitempty"`
	Errors []Error         `json:"errors,omitempty"`
}

type UpdateMercuryV03NetworkStackInput struct {
	ID                   string  `json:"id,omitempty"`
	VerifierAddress      string  `json:"verifierAddress,omitempty"`
	VerifierProxyAddress string  `json:"verifierProxyAddress,omitempty"`
	RewardBankAddress    string  `json:"rewardBankAddress,omitempty"`
	FeeManagerAddress    string  `json:"feeManagerAddress,omitempty"`
	MercuryServerURL     string  `json:"mercuryServerURL,omitempty"`
	MercuryServerPubKey  string  `json:"mercuryServerPubKey,omitempty"`
	Servers              *string `json:"servers,omitempty"`
}

type UpdateMercuryV03NetworkStackPayload struct {
	NetworkStack *MercuryV03NetworkStack `json:"networkStack,omitempty"`
	Errors       []Error                 `json:"errors,omitempty"`
}

type UpdateNetworkInput struct {
	ID                                    string  `json:"id,omitempty"`
	Name                                  string  `json:"name,omitempty"`
	NativeToken                           string  `json:"nativeToken,omitempty"`
	NativeTokenContractAddress            *string `json:"nativeTokenContractAddress,omitempty"`
	ConfigContractAddress                 *string `json:"configContractAddress,omitempty"`
	LinkUSDProxyAddress                   *string `json:"linkUSDProxyAddress,omitempty"`
	NativeUSDProxyAddress                 *string `json:"nativeUSDProxyAddress,omitempty"`
	LinkContractAddress                   *string `json:"linkContractAddress,omitempty"`
	FlagsContractAddress                  *string `json:"flagsContractAddress,omitempty"`
	LinkFunding                           *string `json:"linkFunding,omitempty"`
	BillingAdminAccessControllerAddress   *string `json:"billingAdminAccessControllerAddress,omitempty"`
	RequesterAdminAccessControllerAddress *string `json:"requesterAdminAccessControllerAddress,omitempty"`
	ExplorerAPIKey                        *string `json:"explorerAPIKey,omitempty"`
	ExplorerAPIURL                        *string `json:"explorerAPIURL,omitempty"`
}

type UpdateNetworkPayload struct {
	Network *Network `json:"network,omitempty"`
	Errors  []Error  `json:"errors,omitempty"`
}

type UpdateNodeInput struct {
	ID                   string        `json:"id,omitempty"`
	Name                 string        `json:"name,omitempty"`
	PublicKey            string        `json:"publicKey,omitempty"`
	SupportedCategoryIDs []string      `json:"supportedCategoryIDs,omitempty"`
	SupportedProducts    []ProductType `json:"supportedProducts,omitempty"`
}

type UpdateNodeOperatorInput struct {
	ID      string   `json:"id,omitempty"`
	Keys    []string `json:"keys,omitempty"`
	Name    string   `json:"name,omitempty"`
	Email   string   `json:"email,omitempty"`
	Website string   `json:"website,omitempty"`
}

type UpdateNodeOperatorPayload struct {
	NodeOperator *NodeOperator `json:"nodeOperator,omitempty"`
	Errors       []Error       `json:"errors,omitempty"`
}

type UpdateNodePayload struct {
	Node   *Node   `json:"node,omitempty"`
	Errors []Error `json:"errors,omitempty"`
}

type UpdateOCR3CapabilityInput struct {
	ID         string `json:"id,omitempty"`
	Template   string `json:"template,omitempty"`
	CategoryID string `json:"categoryID,omitempty"`
}

type UpdateOCR3CapabilityPayload struct {
	Ocr3Capability *OCR3Capability `json:"ocr3Capability,omitempty"`
	Errors         []Error         `json:"errors,omitempty"`
}

type UpdatePasswordInput struct {
	OldPassword string `json:"oldPassword,omitempty"`
	NewPassword string `json:"newPassword,omitempty"`
}

type UpdatePasswordPayload struct {
	Errors []Error `json:"errors,omitempty"`
}

type UpdateProfileInput struct {
	Name string `json:"name,omitempty"`
}

type UpdateProfilePayload struct {
	Profile *Profile `json:"profile,omitempty"`
	Errors  []Error  `json:"errors,omitempty"`
}

type UpdateRelayerInput struct {
	ID     string      `json:"id,omitempty"`
	Name   string      `json:"name,omitempty"`
	URL    *RelayerURL `json:"url,omitempty"`
	Config string      `json:"config,omitempty"`
}

type UpdateRelayerPayload struct {
	Relayer *Relayer `json:"relayer,omitempty"`
	Errors  []Error  `json:"errors,omitempty"`
}

type UpdateUserInput struct {
	ID    string   `json:"id,omitempty"`
	Name  string   `json:"name,omitempty"`
	Email string   `json:"email,omitempty"`
	Role  UserRole `json:"role,omitempty"`
}

type UpdateUserPayload struct {
	User   *User   `json:"user,omitempty"`
	Errors []Error `json:"errors,omitempty"`
}

type UpdateVaultInput struct {
	ID                string        `json:"id,omitempty"`
	Name              string        `json:"name,omitempty"`
	Address           string        `json:"address,omitempty"`
	SupportedProducts []ProductType `json:"supportedProducts,omitempty"`
}

type UpdateVaultPayload struct {
	Vault  *Vault  `json:"vault,omitempty"`
	Errors []Error `json:"errors,omitempty"`
}

type UpdateWebhookInput struct {
	ID          string `json:"id,omitempty"`
	Name        string `json:"name,omitempty"`
	EndpointURL string `json:"endpointURL,omitempty"`
	Enabled     bool   `json:"enabled,omitempty"`
}

type UpdateWebhookPayload struct {
	Webhook *Webhook `json:"webhook,omitempty"`
	Errors  []Error  `json:"errors,omitempty"`
}

type User struct {
	ID        string   `json:"id,omitempty"`
	Name      string   `json:"name,omitempty"`
	Email     string   `json:"email,omitempty"`
	Role      UserRole `json:"role,omitempty"`
	Disabled  bool     `json:"disabled,omitempty"`
	CreatedAt Time     `json:"createdAt,omitempty"`
}

type Vault struct {
	ID                string        `json:"id,omitempty"`
	Name              string        `json:"name,omitempty"`
	Address           string        `json:"address,omitempty"`
	Type              VaultType     `json:"type,omitempty"`
	SupportedProducts []ProductType `json:"supportedProducts,omitempty"`
	Network           *Network      `json:"network,omitempty"`
	CreatedAt         Time          `json:"createdAt,omitempty"`
	UpdatedAt         Time          `json:"updatedAt,omitempty"`
}

type VaultsFilters struct {
	Type *VaultType `json:"type,omitempty"`
}

type VaultsInput struct {
	Filter *VaultsFilters `json:"filter,omitempty"`
}

type VerifyMercuryV03ContractInput struct {
	ContractIDs []string `json:"contractIDs,omitempty"`
}

type VerifyMercuryV03ContractPayload struct {
	WorkflowRun *WorkflowRun `json:"workflowRun,omitempty"`
	Errors      []Error      `json:"errors,omitempty"`
}

type Webhook struct {
	ID          string `json:"id,omitempty"`
	Name        string `json:"name,omitempty"`
	EndpointURL string `json:"endpointURL,omitempty"`
	SecretKey   string `json:"secretKey,omitempty"`
	Enabled     bool   `json:"enabled,omitempty"`
	CreatedAt   Time   `json:"createdAt,omitempty"`
	UpdatedAt   Time   `json:"updatedAt,omitempty"`
}

type WebhookCall struct {
	ID          string                `json:"id,omitempty"`
	UUID        string                `json:"uuid,omitempty"`
	Type        string                `json:"type,omitempty"`
	State       string                `json:"state,omitempty"`
	Payload     string                `json:"payload,omitempty"`
	Attempts    []*WebhookCallAttempt `json:"attempts,omitempty"`
	CreatedAt   Time                  `json:"createdAt,omitempty"`
	DeliveredAt *Time                 `json:"deliveredAt,omitempty"`
}

type WebhookCallAttempt struct {
	ID         string `json:"id,omitempty"`
	StatusCode int    `json:"statusCode,omitempty"`
	Timestamp  Time   `json:"timestamp,omitempty"`
}

type WorkflowRun struct {
	ID             string            `json:"id,omitempty"`
	WorkflowType   WorkflowType      `json:"workflowType,omitempty"`
	Status         WorkflowRunStatus `json:"status,omitempty"`
	User           *User             `json:"user,omitempty"`
	AccountAddress *string           `json:"accountAddress,omitempty"`
	Actions        []*Action         `json:"actions,omitempty"`
	CreatedAt      Time              `json:"createdAt,omitempty"`
	Name           *string           `json:"name,omitempty"`
	DeletedAt      *Time             `json:"deletedAt,omitempty"`
}

type WorkflowRunAndContract struct {
	WorkflowRun *WorkflowRun `json:"workflowRun,omitempty"`
	Contract    *Contract    `json:"contract,omitempty"`
}

type WorkflowRunsFilters struct {
	UserID *string `json:"userID,omitempty"`
}

type WorkflowRunsInput struct {
	Filter *WorkflowRunsFilters `json:"filter,omitempty"`
}

type ActionRunStatus string

const (
	ActionRunStatusPending    ActionRunStatus = "PENDING"
	ActionRunStatusInProgress ActionRunStatus = "IN_PROGRESS"
	ActionRunStatusCompleted  ActionRunStatus = "COMPLETED"
	ActionRunStatusErrored    ActionRunStatus = "ERRORED"
)

var AllActionRunStatus = []ActionRunStatus{
	ActionRunStatusPending,
	ActionRunStatusInProgress,
	ActionRunStatusCompleted,
	ActionRunStatusErrored,
}

func (e ActionRunStatus) IsValid() bool {
	switch e {
	case ActionRunStatusPending, ActionRunStatusInProgress, ActionRunStatusCompleted, ActionRunStatusErrored:
		return true
	}
	return false
}

func (e ActionRunStatus) String() string {
	return string(e)
}

func (e *ActionRunStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ActionRunStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ActionRunStatus", str)
	}
	return nil
}

func (e ActionRunStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ActionType string

const (
	ActionTypeGeneric ActionType = "GENERIC"
)

var AllActionType = []ActionType{
	ActionTypeGeneric,
}

func (e ActionType) IsValid() bool {
	switch e {
	case ActionTypeGeneric:
		return true
	}
	return false
}

func (e ActionType) String() string {
	return string(e)
}

func (e *ActionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ActionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ActionType", str)
	}
	return nil
}

func (e ActionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CCIPCommand string

const (
	CCIPCommandSetConfig CCIPCommand = "SET_CONFIG"
)

var AllCCIPCommand = []CCIPCommand{
	CCIPCommandSetConfig,
}

func (e CCIPCommand) IsValid() bool {
	switch e {
	case CCIPCommandSetConfig:
		return true
	}
	return false
}

func (e CCIPCommand) String() string {
	return string(e)
}

func (e *CCIPCommand) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CCIPCommand(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CCIPCommand", str)
	}
	return nil
}

func (e CCIPCommand) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CCIPJobType string

const (
	CCIPJobTypeCommit    CCIPJobType = "COMMIT"
	CCIPJobTypeExecute   CCIPJobType = "EXECUTE"
	CCIPJobTypeBootstrap CCIPJobType = "BOOTSTRAP"
)

var AllCCIPJobType = []CCIPJobType{
	CCIPJobTypeCommit,
	CCIPJobTypeExecute,
	CCIPJobTypeBootstrap,
}

func (e CCIPJobType) IsValid() bool {
	switch e {
	case CCIPJobTypeCommit, CCIPJobTypeExecute, CCIPJobTypeBootstrap:
		return true
	}
	return false
}

func (e CCIPJobType) String() string {
	return string(e)
}

func (e *CCIPJobType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CCIPJobType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CCIPJobType", str)
	}
	return nil
}

func (e CCIPJobType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CCIPLaneLegStatus string

const (
	CCIPLaneLegStatusDraft CCIPLaneLegStatus = "DRAFT"
	CCIPLaneLegStatusReady CCIPLaneLegStatus = "READY"
)

var AllCCIPLaneLegStatus = []CCIPLaneLegStatus{
	CCIPLaneLegStatusDraft,
	CCIPLaneLegStatusReady,
}

func (e CCIPLaneLegStatus) IsValid() bool {
	switch e {
	case CCIPLaneLegStatusDraft, CCIPLaneLegStatusReady:
		return true
	}
	return false
}

func (e CCIPLaneLegStatus) String() string {
	return string(e)
}

func (e *CCIPLaneLegStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CCIPLaneLegStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CCIPLaneLegStatus", str)
	}
	return nil
}

func (e CCIPLaneLegStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CCIPLaneLegTag string

const (
	CCIPLaneLegTagMain        CCIPLaneLegTag = "MAIN"
	CCIPLaneLegTagProvisional CCIPLaneLegTag = "PROVISIONAL"
	CCIPLaneLegTagDead        CCIPLaneLegTag = "DEAD"
)

var AllCCIPLaneLegTag = []CCIPLaneLegTag{
	CCIPLaneLegTagMain,
	CCIPLaneLegTagProvisional,
	CCIPLaneLegTagDead,
}

func (e CCIPLaneLegTag) IsValid() bool {
	switch e {
	case CCIPLaneLegTagMain, CCIPLaneLegTagProvisional, CCIPLaneLegTagDead:
		return true
	}
	return false
}

func (e CCIPLaneLegTag) String() string {
	return string(e)
}

func (e *CCIPLaneLegTag) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CCIPLaneLegTag(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CCIPLaneLegTag", str)
	}
	return nil
}

func (e CCIPLaneLegTag) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ChainType string

const (
	ChainTypeEvm      ChainType = "EVM"
	ChainTypeSolana   ChainType = "SOLANA"
	ChainTypeStarknet ChainType = "STARKNET"
	ChainTypeAptos ChainType = "APTOS"

)

var AllChainType = []ChainType{
	ChainTypeEvm,
	ChainTypeSolana,
	ChainTypeStarknet,
	ChainTypeAptos,
}

func (e ChainType) IsValid() bool {
	switch e {
	case ChainTypeEvm, ChainTypeSolana, ChainTypeStarknet, ChainTypeAptos:
		return true
	}
	return false
}

func (e ChainType) String() string {
	return string(e)
}

func (e *ChainType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChainType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChainType", str)
	}
	return nil
}

func (e ChainType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ContractOwnerType string

const (
	ContractOwnerTypeSystem     ContractOwnerType = "SYSTEM"
	ContractOwnerTypeExternal   ContractOwnerType = "EXTERNAL"
	ContractOwnerTypeVault      ContractOwnerType = "VAULT"
	ContractOwnerTypeNotOwnable ContractOwnerType = "NOT_OWNABLE"
)

var AllContractOwnerType = []ContractOwnerType{
	ContractOwnerTypeSystem,
	ContractOwnerTypeExternal,
	ContractOwnerTypeVault,
	ContractOwnerTypeNotOwnable,
}

func (e ContractOwnerType) IsValid() bool {
	switch e {
	case ContractOwnerTypeSystem, ContractOwnerTypeExternal, ContractOwnerTypeVault, ContractOwnerTypeNotOwnable:
		return true
	}
	return false
}

func (e ContractOwnerType) String() string {
	return string(e)
}

func (e *ContractOwnerType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContractOwnerType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ContractOwnerType", str)
	}
	return nil
}

func (e ContractOwnerType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ContractTag string

const (
	ContractTagMain    ContractTag = "MAIN"
	ContractTagTest    ContractTag = "TEST"
	ContractTagUpgrade ContractTag = "UPGRADE"
	ContractTagDead    ContractTag = "DEAD"
)

var AllContractTag = []ContractTag{
	ContractTagMain,
	ContractTagTest,
	ContractTagUpgrade,
	ContractTagDead,
}

func (e ContractTag) IsValid() bool {
	switch e {
	case ContractTagMain, ContractTagTest, ContractTagUpgrade, ContractTagDead:
		return true
	}
	return false
}

func (e ContractTag) String() string {
	return string(e)
}

func (e *ContractTag) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContractTag(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ContractTag", str)
	}
	return nil
}

func (e ContractTag) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ContractType string

const (
	ContractTypeOcr1 ContractType = "OCR1"
	ContractTypeOcr2 ContractType = "OCR2"
)

var AllContractType = []ContractType{
	ContractTypeOcr1,
	ContractTypeOcr2,
}

func (e ContractType) IsValid() bool {
	switch e {
	case ContractTypeOcr1, ContractTypeOcr2:
		return true
	}
	return false
}

func (e ContractType) String() string {
	return string(e)
}

func (e *ContractType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContractType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ContractType", str)
	}
	return nil
}

func (e ContractType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DONExecutionType string

const (
	DONExecutionTypeMercury          DONExecutionType = "MERCURY"
	DONExecutionTypeMercuryV03       DONExecutionType = "MERCURY_V03"
	DONExecutionTypeAggregator       DONExecutionType = "AGGREGATOR"
	DONExecutionTypeCcipCommit       DONExecutionType = "CCIP_COMMIT"
	DONExecutionTypeCcipExecute      DONExecutionType = "CCIP_EXECUTE"
	DONExecutionTypeKeystoneWorkflow DONExecutionType = "KEYSTONE_WORKFLOW"
)

var AllDONExecutionType = []DONExecutionType{
	DONExecutionTypeMercury,
	DONExecutionTypeMercuryV03,
	DONExecutionTypeAggregator,
	DONExecutionTypeCcipCommit,
	DONExecutionTypeCcipExecute,
	DONExecutionTypeKeystoneWorkflow,
}

func (e DONExecutionType) IsValid() bool {
	switch e {
	case DONExecutionTypeMercury, DONExecutionTypeMercuryV03, DONExecutionTypeAggregator, DONExecutionTypeCcipCommit, DONExecutionTypeCcipExecute, DONExecutionTypeKeystoneWorkflow:
		return true
	}
	return false
}

func (e DONExecutionType) String() string {
	return string(e)
}

func (e *DONExecutionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DONExecutionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DONExecutionType", str)
	}
	return nil
}

func (e DONExecutionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DeploymentStatus string

const (
	DeploymentStatusPending    DeploymentStatus = "PENDING"
	DeploymentStatusQueued     DeploymentStatus = "QUEUED"
	DeploymentStatusInProgress DeploymentStatus = "IN_PROGRESS"
	DeploymentStatusCompleted  DeploymentStatus = "COMPLETED"
	DeploymentStatusErrored    DeploymentStatus = "ERRORED"
)

var AllDeploymentStatus = []DeploymentStatus{
	DeploymentStatusPending,
	DeploymentStatusQueued,
	DeploymentStatusInProgress,
	DeploymentStatusCompleted,
	DeploymentStatusErrored,
}

func (e DeploymentStatus) IsValid() bool {
	switch e {
	case DeploymentStatusPending, DeploymentStatusQueued, DeploymentStatusInProgress, DeploymentStatusCompleted, DeploymentStatusErrored:
		return true
	}
	return false
}

func (e DeploymentStatus) String() string {
	return string(e)
}

func (e *DeploymentStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeploymentStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeploymentStatus", str)
	}
	return nil
}

func (e DeploymentStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type FeedStatus string

const (
	FeedStatusDraft FeedStatus = "DRAFT"
	FeedStatusReady FeedStatus = "READY"
)

var AllFeedStatus = []FeedStatus{
	FeedStatusDraft,
	FeedStatusReady,
}

func (e FeedStatus) IsValid() bool {
	switch e {
	case FeedStatusDraft, FeedStatusReady:
		return true
	}
	return false
}

func (e FeedStatus) String() string {
	return string(e)
}

func (e *FeedStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FeedStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FeedStatus", str)
	}
	return nil
}

func (e FeedStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type JobProposalStatus string

const (
	JobProposalStatusProposed JobProposalStatus = "PROPOSED"
	JobProposalStatusApproved JobProposalStatus = "APPROVED"
	JobProposalStatusRejected JobProposalStatus = "REJECTED"
	JobProposalStatusAccepted JobProposalStatus = "ACCEPTED"
	JobProposalStatusPending  JobProposalStatus = "PENDING"
)

var AllJobProposalStatus = []JobProposalStatus{
	JobProposalStatusProposed,
	JobProposalStatusApproved,
	JobProposalStatusRejected,
	JobProposalStatusAccepted,
	JobProposalStatusPending,
}

func (e JobProposalStatus) IsValid() bool {
	switch e {
	case JobProposalStatusProposed, JobProposalStatusApproved, JobProposalStatusRejected, JobProposalStatusAccepted, JobProposalStatusPending:
		return true
	}
	return false
}

func (e JobProposalStatus) String() string {
	return string(e)
}

func (e *JobProposalStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = JobProposalStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid JobProposalStatus", str)
	}
	return nil
}

func (e JobProposalStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type JobStatus string

const (
	JobStatusDraft     JobStatus = "DRAFT"
	JobStatusProposed  JobStatus = "PROPOSED"
	JobStatusApproved  JobStatus = "APPROVED"
	JobStatusRejected  JobStatus = "REJECTED"
	JobStatusCancelled JobStatus = "CANCELLED"
	JobStatusDisabled  JobStatus = "DISABLED"
	JobStatusDeleted   JobStatus = "DELETED"
	JobStatusRevoked   JobStatus = "REVOKED"
)

var AllJobStatus = []JobStatus{
	JobStatusDraft,
	JobStatusProposed,
	JobStatusApproved,
	JobStatusRejected,
	JobStatusCancelled,
	JobStatusDisabled,
	JobStatusDeleted,
	JobStatusRevoked,
}

func (e JobStatus) IsValid() bool {
	switch e {
	case JobStatusDraft, JobStatusProposed, JobStatusApproved, JobStatusRejected, JobStatusCancelled, JobStatusDisabled, JobStatusDeleted, JobStatusRevoked:
		return true
	}
	return false
}

func (e JobStatus) String() string {
	return string(e)
}

func (e *JobStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = JobStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid JobStatus", str)
	}
	return nil
}

func (e JobStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type JobType string

const (
	JobTypeOffchainreporting  JobType = "OFFCHAINREPORTING"
	JobTypeOffchainreporting2 JobType = "OFFCHAINREPORTING2"
	JobTypeBootstrap          JobType = "BOOTSTRAP"
	JobTypeWorkflow           JobType = "WORKFLOW"
)

var AllJobType = []JobType{
	JobTypeOffchainreporting,
	JobTypeOffchainreporting2,
	JobTypeBootstrap,
	JobTypeWorkflow,
}

func (e JobType) IsValid() bool {
	switch e {
	case JobTypeOffchainreporting, JobTypeOffchainreporting2, JobTypeBootstrap, JobTypeWorkflow:
		return true
	}
	return false
}

func (e JobType) String() string {
	return string(e)
}

func (e *JobType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = JobType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid JobType", str)
	}
	return nil
}

func (e JobType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NetworkStackStatus string

const (
	NetworkStackStatusReady      NetworkStackStatus = "READY"
	NetworkStackStatusInProgress NetworkStackStatus = "IN_PROGRESS"
)

var AllNetworkStackStatus = []NetworkStackStatus{
	NetworkStackStatusReady,
	NetworkStackStatusInProgress,
}

func (e NetworkStackStatus) IsValid() bool {
	switch e {
	case NetworkStackStatusReady, NetworkStackStatusInProgress:
		return true
	}
	return false
}

func (e NetworkStackStatus) String() string {
	return string(e)
}

func (e *NetworkStackStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NetworkStackStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NetworkStackStatus", str)
	}
	return nil
}

func (e NetworkStackStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NetworkStackType string

const (
	NetworkStackTypeMain       NetworkStackType = "MAIN"
	NetworkStackTypeAdditional NetworkStackType = "ADDITIONAL"
)

var AllNetworkStackType = []NetworkStackType{
	NetworkStackTypeMain,
	NetworkStackTypeAdditional,
}

func (e NetworkStackType) IsValid() bool {
	switch e {
	case NetworkStackTypeMain, NetworkStackTypeAdditional:
		return true
	}
	return false
}

func (e NetworkStackType) String() string {
	return string(e)
}

func (e *NetworkStackType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NetworkStackType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NetworkStackType", str)
	}
	return nil
}

func (e NetworkStackType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OCR2PluginType string

const (
	OCR2PluginTypeMedian         OCR2PluginType = "MEDIAN"
	OCR2PluginTypeCcipCommit     OCR2PluginType = "CCIP_COMMIT"
	OCR2PluginTypeCcipExecute    OCR2PluginType = "CCIP_EXECUTE"
	OCR2PluginTypeCcipRebalancer OCR2PluginType = "CCIP_REBALANCER"
	OCR2PluginTypeMercury        OCR2PluginType = "MERCURY"
)

var AllOCR2PluginType = []OCR2PluginType{
	OCR2PluginTypeMedian,
	OCR2PluginTypeCcipCommit,
	OCR2PluginTypeCcipExecute,
	OCR2PluginTypeCcipRebalancer,
	OCR2PluginTypeMercury,
}

func (e OCR2PluginType) IsValid() bool {
	switch e {
	case OCR2PluginTypeMedian, OCR2PluginTypeCcipCommit, OCR2PluginTypeCcipExecute, OCR2PluginTypeCcipRebalancer, OCR2PluginTypeMercury:
		return true
	}
	return false
}

func (e OCR2PluginType) String() string {
	return string(e)
}

func (e *OCR2PluginType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OCR2PluginType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OCR2PluginType", str)
	}
	return nil
}

func (e OCR2PluginType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProductType string

const (
	ProductTypeDataFeeds      ProductType = "DATA_FEEDS"
	ProductTypeDataStreamsV02 ProductType = "DATA_STREAMS_V02"
	ProductTypeDataStreamsV03 ProductType = "DATA_STREAMS_V03"
	ProductTypeCcip           ProductType = "CCIP"
	ProductTypeWorkflow       ProductType = "WORKFLOW"
	ProductTypeOcr3Capability ProductType = "OCR3_CAPABILITY"
)

var AllProductType = []ProductType{
	ProductTypeDataFeeds,
	ProductTypeDataStreamsV02,
	ProductTypeDataStreamsV03,
	ProductTypeCcip,
	ProductTypeWorkflow,
	ProductTypeOcr3Capability,
}

func (e ProductType) IsValid() bool {
	switch e {
	case ProductTypeDataFeeds, ProductTypeDataStreamsV02, ProductTypeDataStreamsV03, ProductTypeCcip, ProductTypeWorkflow, ProductTypeOcr3Capability:
		return true
	}
	return false
}

func (e ProductType) String() string {
	return string(e)
}

func (e *ProductType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductType", str)
	}
	return nil
}

func (e ProductType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ReportSchemaVersion string

const (
	ReportSchemaVersionBasic      ReportSchemaVersion = "BASIC"
	ReportSchemaVersionPremium    ReportSchemaVersion = "PREMIUM"
	ReportSchemaVersionBlockBased ReportSchemaVersion = "BLOCK_BASED"
)

var AllReportSchemaVersion = []ReportSchemaVersion{
	ReportSchemaVersionBasic,
	ReportSchemaVersionPremium,
	ReportSchemaVersionBlockBased,
}

func (e ReportSchemaVersion) IsValid() bool {
	switch e {
	case ReportSchemaVersionBasic, ReportSchemaVersionPremium, ReportSchemaVersionBlockBased:
		return true
	}
	return false
}

func (e ReportSchemaVersion) String() string {
	return string(e)
}

func (e *ReportSchemaVersion) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ReportSchemaVersion(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ReportSchemaVersion", str)
	}
	return nil
}

func (e ReportSchemaVersion) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SelectorOp string

const (
	SelectorOpEq       SelectorOp = "EQ"
	SelectorOpNotEq    SelectorOp = "NOT_EQ"
	SelectorOpIn       SelectorOp = "IN"
	SelectorOpNotIn    SelectorOp = "NOT_IN"
	SelectorOpExist    SelectorOp = "EXIST"
	SelectorOpNotExist SelectorOp = "NOT_EXIST"
)

var AllSelectorOp = []SelectorOp{
	SelectorOpEq,
	SelectorOpNotEq,
	SelectorOpIn,
	SelectorOpNotIn,
	SelectorOpExist,
	SelectorOpNotExist,
}

func (e SelectorOp) IsValid() bool {
	switch e {
	case SelectorOpEq, SelectorOpNotEq, SelectorOpIn, SelectorOpNotIn, SelectorOpExist, SelectorOpNotExist:
		return true
	}
	return false
}

func (e SelectorOp) String() string {
	return string(e)
}

func (e *SelectorOp) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SelectorOp(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SelectorOp", str)
	}
	return nil
}

func (e SelectorOp) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TaskRunStatus string

const (
	TaskRunStatusInProgress TaskRunStatus = "IN_PROGRESS"
	TaskRunStatusCompleted  TaskRunStatus = "COMPLETED"
	TaskRunStatusErrored    TaskRunStatus = "ERRORED"
)

var AllTaskRunStatus = []TaskRunStatus{
	TaskRunStatusInProgress,
	TaskRunStatusCompleted,
	TaskRunStatusErrored,
}

func (e TaskRunStatus) IsValid() bool {
	switch e {
	case TaskRunStatusInProgress, TaskRunStatusCompleted, TaskRunStatusErrored:
		return true
	}
	return false
}

func (e TaskRunStatus) String() string {
	return string(e)
}

func (e *TaskRunStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TaskRunStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TaskRunStatus", str)
	}
	return nil
}

func (e TaskRunStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TokenPoolType string

const (
	TokenPoolTypeLockRelease              TokenPoolType = "LOCK_RELEASE"
	TokenPoolTypeLockReleaseAndProxy      TokenPoolType = "LOCK_RELEASE_AND_PROXY"
	TokenPoolTypeBurnMint                 TokenPoolType = "BURN_MINT"
	TokenPoolTypeBurnMintAndProxy         TokenPoolType = "BURN_MINT_AND_PROXY"
	TokenPoolTypeBurnFromMint             TokenPoolType = "BURN_FROM_MINT"
	TokenPoolTypeBurnWithFromMint         TokenPoolType = "BURN_WITH_FROM_MINT"
	TokenPoolTypeBurnWithFromMintAndProxy TokenPoolType = "BURN_WITH_FROM_MINT_AND_PROXY"
	TokenPoolTypeUsdc                     TokenPoolType = "USDC"
	TokenPoolTypeFeeTokenOnly             TokenPoolType = "FEE_TOKEN_ONLY"
)

var AllTokenPoolType = []TokenPoolType{
	TokenPoolTypeLockRelease,
	TokenPoolTypeLockReleaseAndProxy,
	TokenPoolTypeBurnMint,
	TokenPoolTypeBurnMintAndProxy,
	TokenPoolTypeBurnFromMint,
	TokenPoolTypeBurnWithFromMint,
	TokenPoolTypeBurnWithFromMintAndProxy,
	TokenPoolTypeUsdc,
	TokenPoolTypeFeeTokenOnly,
}

func (e TokenPoolType) IsValid() bool {
	switch e {
	case TokenPoolTypeLockRelease, TokenPoolTypeLockReleaseAndProxy, TokenPoolTypeBurnMint, TokenPoolTypeBurnMintAndProxy, TokenPoolTypeBurnFromMint, TokenPoolTypeBurnWithFromMint, TokenPoolTypeBurnWithFromMintAndProxy, TokenPoolTypeUsdc, TokenPoolTypeFeeTokenOnly:
		return true
	}
	return false
}

func (e TokenPoolType) String() string {
	return string(e)
}

func (e *TokenPoolType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TokenPoolType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TokenPoolType", str)
	}
	return nil
}

func (e TokenPoolType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TokenPriceType string

const (
	TokenPriceTypeFixed TokenPriceType = "FIXED"
	TokenPriceTypeFeed  TokenPriceType = "FEED"
)

var AllTokenPriceType = []TokenPriceType{
	TokenPriceTypeFixed,
	TokenPriceTypeFeed,
}

func (e TokenPriceType) IsValid() bool {
	switch e {
	case TokenPriceTypeFixed, TokenPriceTypeFeed:
		return true
	}
	return false
}

func (e TokenPriceType) String() string {
	return string(e)
}

func (e *TokenPriceType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TokenPriceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TokenPriceType", str)
	}
	return nil
}

func (e TokenPriceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TransferOwnershipStatus string

const (
	TransferOwnershipStatusNone                  TransferOwnershipStatus = "NONE"
	TransferOwnershipStatusProcessingTransaction TransferOwnershipStatus = "PROCESSING_TRANSACTION"
	TransferOwnershipStatusAwaitingConfirmation  TransferOwnershipStatus = "AWAITING_CONFIRMATION"
	TransferOwnershipStatusError                 TransferOwnershipStatus = "ERROR"
)

var AllTransferOwnershipStatus = []TransferOwnershipStatus{
	TransferOwnershipStatusNone,
	TransferOwnershipStatusProcessingTransaction,
	TransferOwnershipStatusAwaitingConfirmation,
	TransferOwnershipStatusError,
}

func (e TransferOwnershipStatus) IsValid() bool {
	switch e {
	case TransferOwnershipStatusNone, TransferOwnershipStatusProcessingTransaction, TransferOwnershipStatusAwaitingConfirmation, TransferOwnershipStatusError:
		return true
	}
	return false
}

func (e TransferOwnershipStatus) String() string {
	return string(e)
}

func (e *TransferOwnershipStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TransferOwnershipStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TransferOwnershipStatus", str)
	}
	return nil
}

func (e TransferOwnershipStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserRole string

const (
	UserRoleViewer         UserRole = "VIEWER"
	UserRoleOps            UserRole = "OPS"
	UserRoleMaintainer     UserRole = "MAINTAINER"
	UserRoleAdmin          UserRole = "ADMIN"
	UserRoleFoundation     UserRole = "FOUNDATION"
	UserRoleDataProvider   UserRole = "DATA_PROVIDER"
	UserRoleCcipValidator  UserRole = "CCIP_VALIDATOR"
	UserRoleDataStreamsOps UserRole = "DATA_STREAMS_OPS"
)

var AllUserRole = []UserRole{
	UserRoleViewer,
	UserRoleOps,
	UserRoleMaintainer,
	UserRoleAdmin,
	UserRoleFoundation,
	UserRoleDataProvider,
	UserRoleCcipValidator,
	UserRoleDataStreamsOps,
}

func (e UserRole) IsValid() bool {
	switch e {
	case UserRoleViewer, UserRoleOps, UserRoleMaintainer, UserRoleAdmin, UserRoleFoundation, UserRoleDataProvider, UserRoleCcipValidator, UserRoleDataStreamsOps:
		return true
	}
	return false
}

func (e UserRole) String() string {
	return string(e)
}

func (e *UserRole) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserRole(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserRole", str)
	}
	return nil
}

func (e UserRole) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VaultType string

const (
	VaultTypeEoa      VaultType = "EOA"
	VaultTypeSafe     VaultType = "SAFE"
	VaultTypeTimelock VaultType = "TIMELOCK"
)

var AllVaultType = []VaultType{
	VaultTypeEoa,
	VaultTypeSafe,
	VaultTypeTimelock,
}

func (e VaultType) IsValid() bool {
	switch e {
	case VaultTypeEoa, VaultTypeSafe, VaultTypeTimelock:
		return true
	}
	return false
}

func (e VaultType) String() string {
	return string(e)
}

func (e *VaultType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VaultType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VaultType", str)
	}
	return nil
}

func (e VaultType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type VerificationStatus string

const (
	VerificationStatusUnknown VerificationStatus = "UNKNOWN"
	VerificationStatusSuccess VerificationStatus = "SUCCESS"
	VerificationStatusPending VerificationStatus = "PENDING"
	VerificationStatusError   VerificationStatus = "ERROR"
)

var AllVerificationStatus = []VerificationStatus{
	VerificationStatusUnknown,
	VerificationStatusSuccess,
	VerificationStatusPending,
	VerificationStatusError,
}

func (e VerificationStatus) IsValid() bool {
	switch e {
	case VerificationStatusUnknown, VerificationStatusSuccess, VerificationStatusPending, VerificationStatusError:
		return true
	}
	return false
}

func (e VerificationStatus) String() string {
	return string(e)
}

func (e *VerificationStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VerificationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VerificationStatus", str)
	}
	return nil
}

func (e VerificationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WebhookCallState string

const (
	WebhookCallStatePending WebhookCallState = "PENDING"
	WebhookCallStateSuccess WebhookCallState = "SUCCESS"
	WebhookCallStateError   WebhookCallState = "ERROR"
	WebhookCallStateFailed  WebhookCallState = "FAILED"
)

var AllWebhookCallState = []WebhookCallState{
	WebhookCallStatePending,
	WebhookCallStateSuccess,
	WebhookCallStateError,
	WebhookCallStateFailed,
}

func (e WebhookCallState) IsValid() bool {
	switch e {
	case WebhookCallStatePending, WebhookCallStateSuccess, WebhookCallStateError, WebhookCallStateFailed:
		return true
	}
	return false
}

func (e WebhookCallState) String() string {
	return string(e)
}

func (e *WebhookCallState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WebhookCallState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WebhookCallState", str)
	}
	return nil
}

func (e WebhookCallState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WorkflowRunStatus string

const (
	WorkflowRunStatusPending    WorkflowRunStatus = "PENDING"
	WorkflowRunStatusInProgress WorkflowRunStatus = "IN_PROGRESS"
	WorkflowRunStatusCompleted  WorkflowRunStatus = "COMPLETED"
	WorkflowRunStatusErrored    WorkflowRunStatus = "ERRORED"
)

var AllWorkflowRunStatus = []WorkflowRunStatus{
	WorkflowRunStatusPending,
	WorkflowRunStatusInProgress,
	WorkflowRunStatusCompleted,
	WorkflowRunStatusErrored,
}

func (e WorkflowRunStatus) IsValid() bool {
	switch e {
	case WorkflowRunStatusPending, WorkflowRunStatusInProgress, WorkflowRunStatusCompleted, WorkflowRunStatusErrored:
		return true
	}
	return false
}

func (e WorkflowRunStatus) String() string {
	return string(e)
}

func (e *WorkflowRunStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowRunStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowRunStatus", str)
	}
	return nil
}

func (e WorkflowRunStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WorkflowType string

const (
	WorkflowTypeGeneric WorkflowType = "GENERIC"
)

var AllWorkflowType = []WorkflowType{
	WorkflowTypeGeneric,
}

func (e WorkflowType) IsValid() bool {
	switch e {
	case WorkflowTypeGeneric:
		return true
	}
	return false
}

func (e WorkflowType) String() string {
	return string(e)
}

func (e *WorkflowType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorkflowType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorkflowType", str)
	}
	return nil
}

func (e WorkflowType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
